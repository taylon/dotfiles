   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  51:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  54:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  55:tmk_core/common/action.c **** #endif
  56:tmk_core/common/action.c **** /** \brief Called to execute an action.
  57:tmk_core/common/action.c ****  *
  58:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  59:tmk_core/common/action.c ****  */
  60:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 60 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  61:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  62:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  63:tmk_core/common/action.c ****         dprint("EVENT: ");
  64:tmk_core/common/action.c ****         debug_event(event);
  65:tmk_core/common/action.c ****         dprintln();
  66:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  67:tmk_core/common/action.c ****         retro_tapping_counter++;
  68:tmk_core/common/action.c **** #endif
  69:tmk_core/common/action.c ****     }
  70:tmk_core/common/action.c **** 
  71:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  72:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  73:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  74:tmk_core/common/action.c ****     }
  75:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  76:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c ****     fauxclicky_check();
  79:tmk_core/common/action.c **** #endif
  80:tmk_core/common/action.c **** 
  81:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  82:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  83:tmk_core/common/action.c ****         process_hand_swap(&event);
  84:tmk_core/common/action.c ****     }
  85:tmk_core/common/action.c **** #endif
  86:tmk_core/common/action.c **** 
  87:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  48               		.loc 1 87 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
  88:tmk_core/common/action.c **** 
  89:tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:tmk_core/common/action.c ****     }
  93:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:tmk_core/common/action.c ****         clear_oneshot_mods();
  95:tmk_core/common/action.c ****     }
  96:tmk_core/common/action.c **** #endif
  97:tmk_core/common/action.c **** 
  98:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  99:tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 99 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
 100:tmk_core/common/action.c **** #else
 101:tmk_core/common/action.c ****     process_record(&record);
 102:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 103:tmk_core/common/action.c ****         dprint("processed: ");
 104:tmk_core/common/action.c ****         debug_record(record);
 105:tmk_core/common/action.c ****         dprintln();
 106:tmk_core/common/action.c ****     }
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** }
  77               		.loc 1 108 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE13:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB15:
 109:tmk_core/common/action.c **** 
 110:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 111:tmk_core/common/action.c **** bool swap_hands = false;
 112:tmk_core/common/action.c **** bool swap_held  = false;
 113:tmk_core/common/action.c **** 
 114:tmk_core/common/action.c **** /** \brief Process Hand Swap
 115:tmk_core/common/action.c ****  *
 116:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 117:tmk_core/common/action.c ****  */
 118:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 119:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 122:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 123:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c ****     if (do_swap) {
 126:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 127:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 128:tmk_core/common/action.c ****     } else {
 129:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 130:tmk_core/common/action.c ****     }
 131:tmk_core/common/action.c **** }
 132:tmk_core/common/action.c **** #endif
 133:tmk_core/common/action.c **** 
 134:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 135:tmk_core/common/action.c **** bool disable_action_cache = false;
 136:tmk_core/common/action.c **** 
 137:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 138:tmk_core/common/action.c ****     disable_action_cache = true;
 139:tmk_core/common/action.c ****     process_record(record);
 140:tmk_core/common/action.c ****     disable_action_cache = false;
 141:tmk_core/common/action.c **** }
 142:tmk_core/common/action.c **** #else
 143:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 144:tmk_core/common/action.c **** #endif
 145:tmk_core/common/action.c **** 
 146:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
  95               		.loc 1 146 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 102               		.loc 1 146 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE15:
 109               		.section	.text.process_record_tap_hint,"ax",@progbits
 110               	.global	process_record_tap_hint
 112               	process_record_tap_hint:
 113               	.LFB16:
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 149:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 150:tmk_core/common/action.c ****  *
 151:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 152:tmk_core/common/action.c ****  */
 153:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 114               		.loc 1 153 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 154:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 121               		.loc 1 154 0
 122 0000 FC01      		movw r30,r24
 123 0002 8081      		ld r24,Z
 124 0004 9181      		ldd r25,Z+1
 125               	.LVL7:
 126 0006 0E94 0000 		call layer_switch_get_action
 127               	.LVL8:
 128 000a 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.register_code,"ax",@progbits
 133               	.global	register_code
 135               	register_code:
 136               	.LFB19:
 155:tmk_core/common/action.c **** 
 156:tmk_core/common/action.c ****     switch (action.kind.id) {
 157:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 158:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 159:tmk_core/common/action.c ****             switch (action.swap.code) {
 160:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 161:tmk_core/common/action.c ****                 default:
 162:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 163:tmk_core/common/action.c ****                     swap_held  = true;
 164:tmk_core/common/action.c ****             }
 165:tmk_core/common/action.c ****             break;
 166:tmk_core/common/action.c **** #    endif
 167:tmk_core/common/action.c ****     }
 168:tmk_core/common/action.c **** }
 169:tmk_core/common/action.c **** #endif
 170:tmk_core/common/action.c **** 
 171:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 172:tmk_core/common/action.c ****  *
 173:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 174:tmk_core/common/action.c ****  */
 175:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 176:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 177:tmk_core/common/action.c ****         return;
 178:tmk_core/common/action.c ****     }
 179:tmk_core/common/action.c **** 
 180:tmk_core/common/action.c ****     if (!process_record_quantum(record)) return;
 181:tmk_core/common/action.c **** 
 182:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 183:tmk_core/common/action.c ****     dprint("ACTION: ");
 184:tmk_core/common/action.c ****     debug_action(action);
 185:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 186:tmk_core/common/action.c ****     dprint(" layer_state: ");
 187:tmk_core/common/action.c ****     layer_debug();
 188:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 189:tmk_core/common/action.c ****     default_layer_debug();
 190:tmk_core/common/action.c **** #endif
 191:tmk_core/common/action.c ****     dprintln();
 192:tmk_core/common/action.c **** 
 193:tmk_core/common/action.c ****     process_action(record, action);
 194:tmk_core/common/action.c **** }
 195:tmk_core/common/action.c **** 
 196:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 197:tmk_core/common/action.c ****  *
 198:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 199:tmk_core/common/action.c ****  */
 200:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 201:tmk_core/common/action.c ****     keyevent_t event = record->event;
 202:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 203:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 204:tmk_core/common/action.c **** #endif
 205:tmk_core/common/action.c **** 
 206:tmk_core/common/action.c ****     if (event.pressed) {
 207:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 208:tmk_core/common/action.c ****         clear_weak_mods();
 209:tmk_core/common/action.c ****     }
 210:tmk_core/common/action.c **** 
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 212:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 213:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 214:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 215:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 216:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 217:tmk_core/common/action.c ****     }
 218:tmk_core/common/action.c **** #endif
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     switch (action.kind.id) {
 221:tmk_core/common/action.c ****         /* Key and Mods */
 222:tmk_core/common/action.c ****         case ACT_LMODS:
 223:tmk_core/common/action.c ****         case ACT_RMODS: {
 224:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 225:tmk_core/common/action.c ****             if (event.pressed) {
 226:tmk_core/common/action.c ****                 if (mods) {
 227:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 228:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 229:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 230:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 231:tmk_core/common/action.c ****                         add_mods(mods);
 232:tmk_core/common/action.c ****                     } else {
 233:tmk_core/common/action.c ****                         add_weak_mods(mods);
 234:tmk_core/common/action.c ****                     }
 235:tmk_core/common/action.c ****                     send_keyboard_report();
 236:tmk_core/common/action.c ****                 }
 237:tmk_core/common/action.c ****                 register_code(action.key.code);
 238:tmk_core/common/action.c ****             } else {
 239:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 240:tmk_core/common/action.c ****                 if (mods) {
 241:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 242:tmk_core/common/action.c ****                         del_mods(mods);
 243:tmk_core/common/action.c ****                     } else {
 244:tmk_core/common/action.c ****                         del_weak_mods(mods);
 245:tmk_core/common/action.c ****                     }
 246:tmk_core/common/action.c ****                     send_keyboard_report();
 247:tmk_core/common/action.c ****                 }
 248:tmk_core/common/action.c ****             }
 249:tmk_core/common/action.c ****         } break;
 250:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 251:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 252:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 253:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 254:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 255:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 256:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 257:tmk_core/common/action.c ****                     // Oneshot modifier
 258:tmk_core/common/action.c ****                     if (event.pressed) {
 259:tmk_core/common/action.c ****                         if (tap_count == 0) {
 260:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 261:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 262:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 263:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 264:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 265:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 268:tmk_core/common/action.c ****                             clear_oneshot_mods();
 269:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 270:tmk_core/common/action.c ****                             register_mods(mods);
 271:tmk_core/common/action.c **** #        endif
 272:tmk_core/common/action.c ****                         } else {
 273:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 274:tmk_core/common/action.c ****                         }
 275:tmk_core/common/action.c ****                     } else {
 276:tmk_core/common/action.c ****                         if (tap_count == 0) {
 277:tmk_core/common/action.c ****                             clear_oneshot_mods();
 278:tmk_core/common/action.c ****                             unregister_mods(mods);
 279:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 280:tmk_core/common/action.c ****                             // Retain Oneshot mods
 281:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 283:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 284:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 285:tmk_core/common/action.c ****                                 unregister_mods(mods);
 286:tmk_core/common/action.c ****                             }
 287:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 289:tmk_core/common/action.c **** #        endif
 290:tmk_core/common/action.c ****                         } else {
 291:tmk_core/common/action.c ****                             clear_oneshot_mods();
 292:tmk_core/common/action.c ****                             unregister_mods(mods);
 293:tmk_core/common/action.c ****                         }
 294:tmk_core/common/action.c ****                     }
 295:tmk_core/common/action.c ****                     break;
 296:tmk_core/common/action.c **** #    endif
 297:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 298:tmk_core/common/action.c ****                     if (event.pressed) {
 299:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 300:tmk_core/common/action.c ****                             register_mods(mods);
 301:tmk_core/common/action.c ****                         }
 302:tmk_core/common/action.c ****                     } else {
 303:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 304:tmk_core/common/action.c ****                             unregister_mods(mods);
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     }
 307:tmk_core/common/action.c ****                     break;
 308:tmk_core/common/action.c ****                 default:
 309:tmk_core/common/action.c ****                     if (event.pressed) {
 310:tmk_core/common/action.c ****                         if (tap_count > 0) {
 311:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 312:tmk_core/common/action.c ****                             if (record->tap.interrupted) {
 313:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 314:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 315:tmk_core/common/action.c ****                                 record->tap.count = 0;
 316:tmk_core/common/action.c ****                                 register_mods(mods);
 317:tmk_core/common/action.c ****                             } else
 318:tmk_core/common/action.c **** #    endif
 319:tmk_core/common/action.c ****                             {
 320:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 321:tmk_core/common/action.c ****                                 register_code(action.key.code);
 322:tmk_core/common/action.c ****                             }
 323:tmk_core/common/action.c ****                         } else {
 324:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 325:tmk_core/common/action.c ****                             register_mods(mods);
 326:tmk_core/common/action.c ****                         }
 327:tmk_core/common/action.c ****                     } else {
 328:tmk_core/common/action.c ****                         if (tap_count > 0) {
 329:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 330:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 331:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 332:tmk_core/common/action.c ****                             }
 333:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 334:tmk_core/common/action.c ****                         } else {
 335:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 336:tmk_core/common/action.c ****                             unregister_mods(mods);
 337:tmk_core/common/action.c ****                         }
 338:tmk_core/common/action.c ****                     }
 339:tmk_core/common/action.c ****                     break;
 340:tmk_core/common/action.c ****             }
 341:tmk_core/common/action.c ****         } break;
 342:tmk_core/common/action.c **** #endif
 343:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 344:tmk_core/common/action.c ****         /* other HID usage */
 345:tmk_core/common/action.c ****         case ACT_USAGE:
 346:tmk_core/common/action.c ****             switch (action.usage.page) {
 347:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 348:tmk_core/common/action.c ****                     if (event.pressed) {
 349:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 350:tmk_core/common/action.c ****                     } else {
 351:tmk_core/common/action.c ****                         host_system_send(0);
 352:tmk_core/common/action.c ****                     }
 353:tmk_core/common/action.c ****                     break;
 354:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 355:tmk_core/common/action.c ****                     if (event.pressed) {
 356:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 357:tmk_core/common/action.c ****                     } else {
 358:tmk_core/common/action.c ****                         host_consumer_send(0);
 359:tmk_core/common/action.c ****                     }
 360:tmk_core/common/action.c ****                     break;
 361:tmk_core/common/action.c ****             }
 362:tmk_core/common/action.c ****             break;
 363:tmk_core/common/action.c **** #endif
 364:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 365:tmk_core/common/action.c ****         /* Mouse key */
 366:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 367:tmk_core/common/action.c ****             if (event.pressed) {
 368:tmk_core/common/action.c ****                 switch (action.key.code) {
 369:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 370:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 371:tmk_core/common/action.c ****                         break;
 372:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 373:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 374:tmk_core/common/action.c ****                         break;
 375:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 376:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 377:tmk_core/common/action.c ****                         break;
 378:tmk_core/common/action.c ****                     default:
 379:tmk_core/common/action.c ****                         break;
 380:tmk_core/common/action.c ****                 }
 381:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 382:tmk_core/common/action.c ****                 mousekey_send();
 383:tmk_core/common/action.c ****             } else {
 384:tmk_core/common/action.c ****                 switch (action.key.code) {
 385:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 386:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 387:tmk_core/common/action.c ****                         break;
 388:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 389:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 390:tmk_core/common/action.c ****                         break;
 391:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 392:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 393:tmk_core/common/action.c ****                         break;
 394:tmk_core/common/action.c ****                     default:
 395:tmk_core/common/action.c ****                         break;
 396:tmk_core/common/action.c ****                 }
 397:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 398:tmk_core/common/action.c ****                 mousekey_send();
 399:tmk_core/common/action.c ****             }
 400:tmk_core/common/action.c ****             break;
 401:tmk_core/common/action.c **** #endif
 402:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 403:tmk_core/common/action.c ****         case ACT_LAYER:
 404:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 405:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 406:tmk_core/common/action.c ****                 if (!event.pressed) {
 407:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 408:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 409:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 410:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 411:tmk_core/common/action.c ****                         case OP_BIT_AND:
 412:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 413:tmk_core/common/action.c ****                             break;
 414:tmk_core/common/action.c ****                         case OP_BIT_OR:
 415:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 416:tmk_core/common/action.c ****                             break;
 417:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 418:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 419:tmk_core/common/action.c ****                             break;
 420:tmk_core/common/action.c ****                         case OP_BIT_SET:
 421:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 422:tmk_core/common/action.c ****                             break;
 423:tmk_core/common/action.c ****                     }
 424:tmk_core/common/action.c ****                 }
 425:tmk_core/common/action.c ****             } else {
 426:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 427:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 428:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 429:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 430:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 431:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 432:tmk_core/common/action.c ****                         case OP_BIT_AND:
 433:tmk_core/common/action.c ****                             layer_and(bits | mask);
 434:tmk_core/common/action.c ****                             break;
 435:tmk_core/common/action.c ****                         case OP_BIT_OR:
 436:tmk_core/common/action.c ****                             layer_or(bits | mask);
 437:tmk_core/common/action.c ****                             break;
 438:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 439:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 440:tmk_core/common/action.c ****                             break;
 441:tmk_core/common/action.c ****                         case OP_BIT_SET:
 442:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 443:tmk_core/common/action.c ****                             break;
 444:tmk_core/common/action.c ****                     }
 445:tmk_core/common/action.c ****                 }
 446:tmk_core/common/action.c ****             }
 447:tmk_core/common/action.c ****             break;
 448:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 449:tmk_core/common/action.c ****             if (event.pressed) {
 450:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 451:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 452:tmk_core/common/action.c ****             } else {
 453:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 454:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 455:tmk_core/common/action.c ****             }
 456:tmk_core/common/action.c ****             break;
 457:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 458:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 459:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 460:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 461:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 462:tmk_core/common/action.c ****                     /* tap toggle */
 463:tmk_core/common/action.c ****                     if (event.pressed) {
 464:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 465:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 466:tmk_core/common/action.c ****                         }
 467:tmk_core/common/action.c ****                     } else {
 468:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 469:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 470:tmk_core/common/action.c ****                         }
 471:tmk_core/common/action.c ****                     }
 472:tmk_core/common/action.c ****                     break;
 473:tmk_core/common/action.c ****                 case OP_ON_OFF:
 474:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 475:tmk_core/common/action.c ****                     break;
 476:tmk_core/common/action.c ****                 case OP_OFF_ON:
 477:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 478:tmk_core/common/action.c ****                     break;
 479:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 480:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 481:tmk_core/common/action.c ****                     break;
 482:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 483:tmk_core/common/action.c ****                 case OP_ONESHOT:
 484:tmk_core/common/action.c ****                     // Oneshot modifier
 485:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 486:tmk_core/common/action.c ****                     do_release_oneshot = false;
 487:tmk_core/common/action.c ****                     if (event.pressed) {
 488:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 489:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 490:tmk_core/common/action.c ****                             reset_oneshot_layer();
 491:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 492:tmk_core/common/action.c ****                             break;
 493:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 494:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 495:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 496:tmk_core/common/action.c ****                         }
 497:tmk_core/common/action.c ****                     } else {
 498:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 499:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 500:tmk_core/common/action.c ****                             reset_oneshot_layer();
 501:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 502:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 503:tmk_core/common/action.c ****                         } else {
 504:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 505:tmk_core/common/action.c ****                         }
 506:tmk_core/common/action.c ****                     }
 507:tmk_core/common/action.c **** #            else
 508:tmk_core/common/action.c ****                     if (event.pressed) {
 509:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 510:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 511:tmk_core/common/action.c ****                     } else {
 512:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 513:tmk_core/common/action.c ****                         if (tap_count > 1) {
 514:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 515:tmk_core/common/action.c ****                         }
 516:tmk_core/common/action.c ****                     }
 517:tmk_core/common/action.c **** #            endif
 518:tmk_core/common/action.c ****                     break;
 519:tmk_core/common/action.c **** #        endif
 520:tmk_core/common/action.c ****                 default:
 521:tmk_core/common/action.c ****                     /* tap key */
 522:tmk_core/common/action.c ****                     if (event.pressed) {
 523:tmk_core/common/action.c ****                         if (tap_count > 0) {
 524:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 525:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 526:tmk_core/common/action.c ****                         } else {
 527:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 528:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 529:tmk_core/common/action.c ****                         }
 530:tmk_core/common/action.c ****                     } else {
 531:tmk_core/common/action.c ****                         if (tap_count > 0) {
 532:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 533:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 534:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 535:tmk_core/common/action.c ****                             } else {
 536:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 537:tmk_core/common/action.c ****                             }
 538:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 539:tmk_core/common/action.c ****                         } else {
 540:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 541:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 542:tmk_core/common/action.c ****                         }
 543:tmk_core/common/action.c ****                     }
 544:tmk_core/common/action.c ****                     break;
 545:tmk_core/common/action.c ****             }
 546:tmk_core/common/action.c ****             break;
 547:tmk_core/common/action.c **** #    endif
 548:tmk_core/common/action.c **** #endif
 549:tmk_core/common/action.c ****             /* Extentions */
 550:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 551:tmk_core/common/action.c ****         case ACT_MACRO:
 552:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 553:tmk_core/common/action.c ****             break;
 554:tmk_core/common/action.c **** #endif
 555:tmk_core/common/action.c **** #if defined(BACKLIGHT_ENABLE) | defined(LED_MATRIX_ENABLE)
 556:tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 557:tmk_core/common/action.c ****             if (!event.pressed) {
 558:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 559:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 560:tmk_core/common/action.c ****                         backlight_increase();
 561:tmk_core/common/action.c ****                         break;
 562:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 563:tmk_core/common/action.c ****                         backlight_decrease();
 564:tmk_core/common/action.c ****                         break;
 565:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 566:tmk_core/common/action.c ****                         backlight_toggle();
 567:tmk_core/common/action.c ****                         break;
 568:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 569:tmk_core/common/action.c ****                         backlight_step();
 570:tmk_core/common/action.c ****                         break;
 571:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 572:tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 573:tmk_core/common/action.c ****                         break;
 574:tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 575:tmk_core/common/action.c ****                         backlight_level(0);
 576:tmk_core/common/action.c ****                         break;
 577:tmk_core/common/action.c ****                 }
 578:tmk_core/common/action.c ****             }
 579:tmk_core/common/action.c ****             break;
 580:tmk_core/common/action.c **** #endif
 581:tmk_core/common/action.c ****         case ACT_COMMAND:
 582:tmk_core/common/action.c ****             break;
 583:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 584:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 585:tmk_core/common/action.c ****             switch (action.swap.code) {
 586:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 587:tmk_core/common/action.c ****                     if (event.pressed) {
 588:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 589:tmk_core/common/action.c ****                     }
 590:tmk_core/common/action.c ****                     break;
 591:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 592:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 595:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_ON:
 598:tmk_core/common/action.c ****                     if (!event.pressed) {
 599:tmk_core/common/action.c ****                         swap_hands = true;
 600:tmk_core/common/action.c ****                     }
 601:tmk_core/common/action.c ****                     break;
 602:tmk_core/common/action.c ****                 case OP_SH_OFF:
 603:tmk_core/common/action.c ****                     if (!event.pressed) {
 604:tmk_core/common/action.c ****                         swap_hands = false;
 605:tmk_core/common/action.c ****                     }
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 608:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 609:tmk_core/common/action.c ****                     /* tap toggle */
 610:tmk_core/common/action.c **** 
 611:tmk_core/common/action.c ****                     if (event.pressed) {
 612:tmk_core/common/action.c ****                         if (swap_held) {
 613:tmk_core/common/action.c ****                             swap_held = false;
 614:tmk_core/common/action.c ****                         } else {
 615:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 616:tmk_core/common/action.c ****                         }
 617:tmk_core/common/action.c ****                     } else {
 618:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 619:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 620:tmk_core/common/action.c ****                         }
 621:tmk_core/common/action.c ****                     }
 622:tmk_core/common/action.c ****                     break;
 623:tmk_core/common/action.c ****                 default:
 624:tmk_core/common/action.c ****                     /* tap key */
 625:tmk_core/common/action.c ****                     if (tap_count > 0) {
 626:tmk_core/common/action.c ****                         if (swap_held) {
 627:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 628:tmk_core/common/action.c ****                             swap_held  = false;
 629:tmk_core/common/action.c ****                         }
 630:tmk_core/common/action.c ****                         if (event.pressed) {
 631:tmk_core/common/action.c ****                             register_code(action.swap.code);
 632:tmk_core/common/action.c ****                         } else {
 633:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 634:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 635:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 636:tmk_core/common/action.c ****                         }
 637:tmk_core/common/action.c ****                     } else {
 638:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 639:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 640:tmk_core/common/action.c ****                             swap_held  = false;
 641:tmk_core/common/action.c ****                         }
 642:tmk_core/common/action.c ****                     }
 643:tmk_core/common/action.c **** #    endif
 644:tmk_core/common/action.c ****             }
 645:tmk_core/common/action.c **** #endif
 646:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 647:tmk_core/common/action.c ****         case ACT_FUNCTION:
 648:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 649:tmk_core/common/action.c ****             break;
 650:tmk_core/common/action.c **** #endif
 651:tmk_core/common/action.c ****         default:
 652:tmk_core/common/action.c ****             break;
 653:tmk_core/common/action.c ****     }
 654:tmk_core/common/action.c **** 
 655:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 656:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 657:tmk_core/common/action.c ****     switch (action.kind.id) {
 658:tmk_core/common/action.c ****         case ACT_LAYER:
 659:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 660:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 661:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 662:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 663:tmk_core/common/action.c **** #    endif
 664:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 665:tmk_core/common/action.c ****             break;
 666:tmk_core/common/action.c ****         default:
 667:tmk_core/common/action.c ****             break;
 668:tmk_core/common/action.c ****     }
 669:tmk_core/common/action.c **** #endif
 670:tmk_core/common/action.c **** 
 671:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 672:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 673:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 674:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 675:tmk_core/common/action.c ****     } else {
 676:tmk_core/common/action.c ****         if (event.pressed) {
 677:tmk_core/common/action.c ****             if (tap_count > 0) {
 678:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 679:tmk_core/common/action.c ****             } else {
 680:tmk_core/common/action.c ****             }
 681:tmk_core/common/action.c ****         } else {
 682:tmk_core/common/action.c ****             if (tap_count > 0) {
 683:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 684:tmk_core/common/action.c ****             } else {
 685:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 686:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 687:tmk_core/common/action.c ****                 }
 688:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 689:tmk_core/common/action.c ****             }
 690:tmk_core/common/action.c ****         }
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #    endif
 693:tmk_core/common/action.c **** #endif
 694:tmk_core/common/action.c **** 
 695:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 696:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 697:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 698:tmk_core/common/action.c ****      */
 699:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 700:tmk_core/common/action.c ****         record->event.pressed = false;
 701:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 702:tmk_core/common/action.c ****         process_record(record);
 703:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 704:tmk_core/common/action.c ****     }
 705:tmk_core/common/action.c **** #endif
 706:tmk_core/common/action.c **** }
 707:tmk_core/common/action.c **** 
 708:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 709:tmk_core/common/action.c ****  *
 710:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 711:tmk_core/common/action.c ****  */
 712:tmk_core/common/action.c **** void register_code(uint8_t code) {
 137               		.loc 1 712 0
 138               		.cfi_startproc
 139               	.LVL9:
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 0 */
 143               	.L__stack_usage = 0
 713:tmk_core/common/action.c ****     if (code == KC_NO) {
 144               		.loc 1 713 0
 145 0000 8823      		tst r24
 146 0002 01F4      		brne .+2
 147 0004 00C0      		rjmp .L4
 714:tmk_core/common/action.c ****         return;
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 717:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 718:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 719:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 720:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 721:tmk_core/common/action.c **** #    endif
 722:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 723:tmk_core/common/action.c ****         send_keyboard_report();
 724:tmk_core/common/action.c ****         wait_ms(100);
 725:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 726:tmk_core/common/action.c ****         send_keyboard_report();
 727:tmk_core/common/action.c ****     }
 728:tmk_core/common/action.c **** 
 729:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 730:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 731:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 732:tmk_core/common/action.c **** #    endif
 733:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 734:tmk_core/common/action.c ****         send_keyboard_report();
 735:tmk_core/common/action.c ****         wait_ms(100);
 736:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 737:tmk_core/common/action.c ****         send_keyboard_report();
 738:tmk_core/common/action.c ****     }
 739:tmk_core/common/action.c **** 
 740:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 741:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 742:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 743:tmk_core/common/action.c **** #    endif
 744:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 745:tmk_core/common/action.c ****         send_keyboard_report();
 746:tmk_core/common/action.c ****         wait_ms(100);
 747:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 748:tmk_core/common/action.c ****         send_keyboard_report();
 749:tmk_core/common/action.c ****     }
 750:tmk_core/common/action.c **** #endif
 751:tmk_core/common/action.c **** 
 752:tmk_core/common/action.c ****     else if
 753:tmk_core/common/action.c ****         IS_KEY(code) {
 148               		.loc 1 753 0
 149 0006 9CEF      		ldi r25,lo8(-4)
 150 0008 980F      		add r25,r24
 151 000a 913A      		cpi r25,lo8(-95)
 152 000c 00F4      		brsh .L6
 153               	.LVL10:
 154               	.LBB22:
 155               	.LBB23:
 156               		.file 2 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) { add_key_to_report(keyboard_report, key); }
 157               		.loc 2 32 0
 158 000e 682F      		mov r22,r24
 159 0010 8091 0000 		lds r24,keyboard_report
 160 0014 9091 0000 		lds r25,keyboard_report+1
 161               	.LVL11:
 162 0018 0E94 0000 		call add_key_to_report
 163               	.LVL12:
 164 001c 00C0      		rjmp .L40
 165               	.LVL13:
 166               	.L6:
 167               	.LBE23:
 168               	.LBE22:
 754:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 755:tmk_core/common/action.c ****             if (command_proc(code)) return;
 756:tmk_core/common/action.c **** 
 757:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 758:tmk_core/common/action.c **** /* TODO: remove
 759:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 760:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 761:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 762:tmk_core/common/action.c **** 
 763:tmk_core/common/action.c ****             add_key(code);
 764:tmk_core/common/action.c ****             send_keyboard_report();
 765:tmk_core/common/action.c **** 
 766:tmk_core/common/action.c ****             set_mods(tmp_mods);
 767:tmk_core/common/action.c ****             send_keyboard_report();
 768:tmk_core/common/action.c ****             oneshot_cancel();
 769:tmk_core/common/action.c ****         } else
 770:tmk_core/common/action.c **** */
 771:tmk_core/common/action.c **** #endif
 772:tmk_core/common/action.c ****             {
 773:tmk_core/common/action.c ****                 add_key(code);
 774:tmk_core/common/action.c ****                 send_keyboard_report();
 775:tmk_core/common/action.c ****             }
 776:tmk_core/common/action.c ****         }
 777:tmk_core/common/action.c ****     else if
 778:tmk_core/common/action.c ****         IS_MOD(code) {
 169               		.loc 1 778 0
 170 001e 90E2      		ldi r25,lo8(32)
 171 0020 980F      		add r25,r24
 172 0022 9830      		cpi r25,lo8(8)
 173 0024 00F4      		brsh .L7
 779:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 174               		.loc 1 779 0
 175 0026 8770      		andi r24,lo8(7)
 176               	.LVL14:
 177 0028 91E0      		ldi r25,lo8(1)
 178 002a 00C0      		rjmp 2f
 179               		1:
 180 002c 990F      		lsl r25
 181               		2:
 182 002e 8A95      		dec r24
 183 0030 02F4      		brpl 1b
 184 0032 892F      		mov r24,r25
 185 0034 0E94 0000 		call add_mods
 186               	.LVL15:
 187               	.L40:
 780:tmk_core/common/action.c ****             send_keyboard_report();
 188               		.loc 1 780 0
 189 0038 0C94 0000 		jmp send_keyboard_report
 190               	.LVL16:
 191               	.L7:
 781:tmk_core/common/action.c ****         }
 782:tmk_core/common/action.c ****     else if
 783:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 192               		.loc 1 783 0
 193 003c 9BE5      		ldi r25,lo8(91)
 194 003e 980F      		add r25,r24
 195 0040 9330      		cpi r25,lo8(3)
 196 0042 00F4      		brsh .L8
 197               		.loc 1 783 0 is_stmt 0 discriminator 1
 198 0044 853A      		cpi r24,lo8(-91)
 199 0046 01F0      		breq .L12
 200               		.loc 1 783 0 discriminator 2
 201 0048 863A      		cpi r24,lo8(-90)
 202 004a 01F0      		breq .L13
 203               		.loc 1 783 0
 204 004c 83E8      		ldi r24,lo8(-125)
 205 004e 90E0      		ldi r25,0
 206               	.LVL17:
 207 0050 00C0      		rjmp .L9
 208               	.LVL18:
 209               	.L12:
 210 0052 81E8      		ldi r24,lo8(-127)
 211 0054 90E0      		ldi r25,0
 212               	.LVL19:
 213 0056 00C0      		rjmp .L9
 214               	.LVL20:
 215               	.L13:
 216 0058 82E8      		ldi r24,lo8(-126)
 217 005a 90E0      		ldi r25,0
 218               	.LVL21:
 219               	.L9:
 220               		.loc 1 783 0 discriminator 13
 221 005c 0C94 0000 		jmp host_system_send
 222               	.LVL22:
 223               	.L8:
 784:tmk_core/common/action.c ****     else if
 785:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 224               		.loc 1 785 0 is_stmt 1
 225 0060 98E5      		ldi r25,lo8(88)
 226 0062 980F      		add r25,r24
 227 0064 9731      		cpi r25,lo8(23)
 228 0066 00F0      		brlo .+2
 229 0068 00C0      		rjmp .L10
 230               		.loc 1 785 0 is_stmt 0 discriminator 1
 231 006a 883A      		cpi r24,lo8(-88)
 232 006c 01F4      		brne .+2
 233 006e 00C0      		rjmp .L14
 234               		.loc 1 785 0 discriminator 2
 235 0070 893A      		cpi r24,lo8(-87)
 236 0072 01F4      		brne .+2
 237 0074 00C0      		rjmp .L15
 238               		.loc 1 785 0 discriminator 4
 239 0076 8A3A      		cpi r24,lo8(-86)
 240 0078 01F4      		brne .+2
 241 007a 00C0      		rjmp .L16
 242               		.loc 1 785 0 discriminator 6
 243 007c 8B3A      		cpi r24,lo8(-85)
 244 007e 01F4      		brne .+2
 245 0080 00C0      		rjmp .L17
 246               		.loc 1 785 0 discriminator 8
 247 0082 8C3A      		cpi r24,lo8(-84)
 248 0084 01F4      		brne .+2
 249 0086 00C0      		rjmp .L18
 250               		.loc 1 785 0 discriminator 10
 251 0088 8B3B      		cpi r24,lo8(-69)
 252 008a 01F4      		brne .+2
 253 008c 00C0      		rjmp .L19
 254               		.loc 1 785 0 discriminator 12
 255 008e 8C3B      		cpi r24,lo8(-68)
 256 0090 01F4      		brne .+2
 257 0092 00C0      		rjmp .L20
 258               		.loc 1 785 0 discriminator 14
 259 0094 8D3A      		cpi r24,lo8(-83)
 260 0096 01F4      		brne .+2
 261 0098 00C0      		rjmp .L21
 262               		.loc 1 785 0 discriminator 16
 263 009a 803B      		cpi r24,lo8(-80)
 264 009c 01F4      		brne .+2
 265 009e 00C0      		rjmp .L22
 266               		.loc 1 785 0 discriminator 18
 267 00a0 8E3A      		cpi r24,lo8(-82)
 268 00a2 01F4      		brne .+2
 269 00a4 00C0      		rjmp .L23
 270               		.loc 1 785 0 discriminator 20
 271 00a6 8F3A      		cpi r24,lo8(-81)
 272 00a8 01F4      		brne .+2
 273 00aa 00C0      		rjmp .L24
 274               		.loc 1 785 0 discriminator 22
 275 00ac 813B      		cpi r24,lo8(-79)
 276 00ae 01F4      		brne .+2
 277 00b0 00C0      		rjmp .L25
 278               		.loc 1 785 0 discriminator 24
 279 00b2 823B      		cpi r24,lo8(-78)
 280 00b4 01F4      		brne .+2
 281 00b6 00C0      		rjmp .L26
 282               		.loc 1 785 0 discriminator 26
 283 00b8 833B      		cpi r24,lo8(-77)
 284 00ba 01F4      		brne .+2
 285 00bc 00C0      		rjmp .L27
 286               		.loc 1 785 0 discriminator 28
 287 00be 843B      		cpi r24,lo8(-76)
 288 00c0 01F4      		brne .+2
 289 00c2 00C0      		rjmp .L28
 290               		.loc 1 785 0 discriminator 30
 291 00c4 853B      		cpi r24,lo8(-75)
 292 00c6 01F4      		brne .+2
 293 00c8 00C0      		rjmp .L29
 294               		.loc 1 785 0 discriminator 32
 295 00ca 863B      		cpi r24,lo8(-74)
 296 00cc 01F4      		brne .+2
 297 00ce 00C0      		rjmp .L30
 298               		.loc 1 785 0 discriminator 34
 299 00d0 873B      		cpi r24,lo8(-73)
 300 00d2 01F4      		brne .+2
 301 00d4 00C0      		rjmp .L31
 302               		.loc 1 785 0 discriminator 36
 303 00d6 883B      		cpi r24,lo8(-72)
 304 00d8 01F4      		brne .+2
 305 00da 00C0      		rjmp .L32
 306               		.loc 1 785 0 discriminator 38
 307 00dc 893B      		cpi r24,lo8(-71)
 308 00de 01F4      		brne .+2
 309 00e0 00C0      		rjmp .L33
 310               		.loc 1 785 0 discriminator 40
 311 00e2 8D3B      		cpi r24,lo8(-67)
 312 00e4 01F4      		brne .+2
 313 00e6 00C0      		rjmp .L34
 314               		.loc 1 785 0 discriminator 42
 315 00e8 8E3B      		cpi r24,lo8(-66)
 316 00ea 01F4      		brne .+2
 317 00ec 00C0      		rjmp .L35
 318               		.loc 1 785 0 discriminator 44
 319 00ee 8A3B      		cpi r24,lo8(-70)
 320 00f0 01F4      		brne .+2
 321 00f2 00C0      		rjmp .L36
 322               		.loc 1 785 0
 323 00f4 80E0      		ldi r24,0
 324 00f6 90E0      		ldi r25,0
 325               	.LVL23:
 326 00f8 00C0      		rjmp .L11
 327               	.LVL24:
 328               	.L14:
 329 00fa 82EE      		ldi r24,lo8(-30)
 330 00fc 90E0      		ldi r25,0
 331               	.LVL25:
 332 00fe 00C0      		rjmp .L11
 333               	.LVL26:
 334               	.L15:
 335 0100 89EE      		ldi r24,lo8(-23)
 336 0102 90E0      		ldi r25,0
 337               	.LVL27:
 338 0104 00C0      		rjmp .L11
 339               	.LVL28:
 340               	.L16:
 341 0106 8AEE      		ldi r24,lo8(-22)
 342 0108 90E0      		ldi r25,0
 343               	.LVL29:
 344 010a 00C0      		rjmp .L11
 345               	.LVL30:
 346               	.L17:
 347 010c 85EB      		ldi r24,lo8(-75)
 348 010e 90E0      		ldi r25,0
 349               	.LVL31:
 350 0110 00C0      		rjmp .L11
 351               	.LVL32:
 352               	.L18:
 353 0112 86EB      		ldi r24,lo8(-74)
 354 0114 90E0      		ldi r25,0
 355               	.LVL33:
 356 0116 00C0      		rjmp .L11
 357               	.LVL34:
 358               	.L19:
 359 0118 83EB      		ldi r24,lo8(-77)
 360 011a 90E0      		ldi r25,0
 361               	.LVL35:
 362 011c 00C0      		rjmp .L11
 363               	.LVL36:
 364               	.L20:
 365 011e 84EB      		ldi r24,lo8(-76)
 366 0120 90E0      		ldi r25,0
 367               	.LVL37:
 368 0122 00C0      		rjmp .L11
 369               	.LVL38:
 370               	.L21:
 371 0124 87EB      		ldi r24,lo8(-73)
 372 0126 90E0      		ldi r25,0
 373               	.LVL39:
 374 0128 00C0      		rjmp .L11
 375               	.LVL40:
 376               	.L22:
 377 012a 8CEC      		ldi r24,lo8(-52)
 378 012c 90E0      		ldi r25,0
 379               	.LVL41:
 380 012e 00C0      		rjmp .L11
 381               	.LVL42:
 382               	.L23:
 383 0130 8DEC      		ldi r24,lo8(-51)
 384 0132 90E0      		ldi r25,0
 385               	.LVL43:
 386 0134 00C0      		rjmp .L11
 387               	.LVL44:
 388               	.L24:
 389 0136 83E8      		ldi r24,lo8(-125)
 390 0138 91E0      		ldi r25,lo8(1)
 391               	.LVL45:
 392 013a 00C0      		rjmp .L11
 393               	.LVL46:
 394               	.L25:
 395 013c 8AE8      		ldi r24,lo8(-118)
 396 013e 91E0      		ldi r25,lo8(1)
 397               	.LVL47:
 398 0140 00C0      		rjmp .L11
 399               	.LVL48:
 400               	.L26:
 401 0142 82E9      		ldi r24,lo8(-110)
 402 0144 91E0      		ldi r25,lo8(1)
 403               	.LVL49:
 404 0146 00C0      		rjmp .L11
 405               	.LVL50:
 406               	.L27:
 407 0148 84E9      		ldi r24,lo8(-108)
 408 014a 91E0      		ldi r25,lo8(1)
 409               	.LVL51:
 410 014c 00C0      		rjmp .L11
 411               	.LVL52:
 412               	.L28:
 413 014e 81E2      		ldi r24,lo8(33)
 414 0150 92E0      		ldi r25,lo8(2)
 415               	.LVL53:
 416 0152 00C0      		rjmp .L11
 417               	.LVL54:
 418               	.L29:
 419 0154 83E2      		ldi r24,lo8(35)
 420 0156 92E0      		ldi r25,lo8(2)
 421               	.LVL55:
 422 0158 00C0      		rjmp .L11
 423               	.LVL56:
 424               	.L30:
 425 015a 84E2      		ldi r24,lo8(36)
 426 015c 92E0      		ldi r25,lo8(2)
 427               	.LVL57:
 428 015e 00C0      		rjmp .L11
 429               	.LVL58:
 430               	.L31:
 431 0160 85E2      		ldi r24,lo8(37)
 432 0162 92E0      		ldi r25,lo8(2)
 433               	.LVL59:
 434 0164 00C0      		rjmp .L11
 435               	.LVL60:
 436               	.L32:
 437 0166 86E2      		ldi r24,lo8(38)
 438 0168 92E0      		ldi r25,lo8(2)
 439               	.LVL61:
 440 016a 00C0      		rjmp .L11
 441               	.LVL62:
 442               	.L33:
 443 016c 87E2      		ldi r24,lo8(39)
 444 016e 92E0      		ldi r25,lo8(2)
 445               	.LVL63:
 446 0170 00C0      		rjmp .L11
 447               	.LVL64:
 448               	.L34:
 449 0172 8FE6      		ldi r24,lo8(111)
 450 0174 90E0      		ldi r25,0
 451               	.LVL65:
 452 0176 00C0      		rjmp .L11
 453               	.LVL66:
 454               	.L35:
 455 0178 80E7      		ldi r24,lo8(112)
 456 017a 90E0      		ldi r25,0
 457               	.LVL67:
 458 017c 00C0      		rjmp .L11
 459               	.LVL68:
 460               	.L36:
 461 017e 8AE2      		ldi r24,lo8(42)
 462 0180 92E0      		ldi r25,lo8(2)
 463               	.LVL69:
 464               	.L11:
 465               		.loc 1 785 0 discriminator 93
 466 0182 0C94 0000 		jmp host_consumer_send
 467               	.LVL70:
 468               	.L10:
 786:tmk_core/common/action.c **** 
 787:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 788:tmk_core/common/action.c ****     else if
 789:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 469               		.loc 1 789 0 is_stmt 1
 470 0186 803F      		cpi r24,lo8(-16)
 471 0188 00F0      		brlo .L4
 790:tmk_core/common/action.c ****             mousekey_on(code);
 472               		.loc 1 790 0
 473 018a 0E94 0000 		call mousekey_on
 474               	.LVL71:
 791:tmk_core/common/action.c ****             mousekey_send();
 475               		.loc 1 791 0
 476 018e 0C94 0000 		jmp mousekey_send
 477               	.LVL72:
 478               	.L4:
 479 0192 0895      		ret
 480               		.cfi_endproc
 481               	.LFE19:
 483               		.section	.text.unregister_code,"ax",@progbits
 484               	.global	unregister_code
 486               	unregister_code:
 487               	.LFB20:
 792:tmk_core/common/action.c ****         }
 793:tmk_core/common/action.c **** #endif
 794:tmk_core/common/action.c **** }
 795:tmk_core/common/action.c **** 
 796:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 797:tmk_core/common/action.c ****  *
 798:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 799:tmk_core/common/action.c ****  */
 800:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 488               		.loc 1 800 0
 489               		.cfi_startproc
 490               	.LVL73:
 491               	/* prologue: function */
 492               	/* frame size = 0 */
 493               	/* stack size = 0 */
 494               	.L__stack_usage = 0
 801:tmk_core/common/action.c ****     if (code == KC_NO) {
 495               		.loc 1 801 0
 496 0000 8823      		tst r24
 497 0002 01F0      		breq .L42
 802:tmk_core/common/action.c ****         return;
 803:tmk_core/common/action.c ****     }
 804:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 805:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 806:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 807:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 808:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 809:tmk_core/common/action.c **** #    endif
 810:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 811:tmk_core/common/action.c ****         send_keyboard_report();
 812:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 813:tmk_core/common/action.c ****         send_keyboard_report();
 814:tmk_core/common/action.c ****     }
 815:tmk_core/common/action.c **** 
 816:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 817:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 818:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 819:tmk_core/common/action.c **** #    endif
 820:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 821:tmk_core/common/action.c ****         send_keyboard_report();
 822:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 823:tmk_core/common/action.c ****         send_keyboard_report();
 824:tmk_core/common/action.c ****     }
 825:tmk_core/common/action.c **** 
 826:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 827:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 828:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 829:tmk_core/common/action.c **** #    endif
 830:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 831:tmk_core/common/action.c ****         send_keyboard_report();
 832:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 833:tmk_core/common/action.c ****         send_keyboard_report();
 834:tmk_core/common/action.c ****     }
 835:tmk_core/common/action.c **** #endif
 836:tmk_core/common/action.c **** 
 837:tmk_core/common/action.c ****     else if
 838:tmk_core/common/action.c ****         IS_KEY(code) {
 498               		.loc 1 838 0
 499 0004 9CEF      		ldi r25,lo8(-4)
 500 0006 980F      		add r25,r24
 501 0008 913A      		cpi r25,lo8(-95)
 502 000a 00F4      		brsh .L44
 503               	.LVL74:
 504               	.LBB24:
 505               	.LBB25:
  33:tmk_core/common/action_util.h **** 
  34:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) { del_key_from_report(keyboard_report, key); }
 506               		.loc 2 34 0
 507 000c 682F      		mov r22,r24
 508 000e 8091 0000 		lds r24,keyboard_report
 509 0012 9091 0000 		lds r25,keyboard_report+1
 510               	.LVL75:
 511 0016 0E94 0000 		call del_key_from_report
 512               	.LVL76:
 513 001a 00C0      		rjmp .L51
 514               	.LVL77:
 515               	.L44:
 516               	.LBE25:
 517               	.LBE24:
 839:tmk_core/common/action.c ****             del_key(code);
 840:tmk_core/common/action.c ****             send_keyboard_report();
 841:tmk_core/common/action.c ****         }
 842:tmk_core/common/action.c ****     else if
 843:tmk_core/common/action.c ****         IS_MOD(code) {
 518               		.loc 1 843 0
 519 001c 90E2      		ldi r25,lo8(32)
 520 001e 980F      		add r25,r24
 521 0020 9830      		cpi r25,lo8(8)
 522 0022 00F4      		brsh .L45
 844:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 523               		.loc 1 844 0
 524 0024 8770      		andi r24,lo8(7)
 525               	.LVL78:
 526 0026 91E0      		ldi r25,lo8(1)
 527 0028 00C0      		rjmp 2f
 528               		1:
 529 002a 990F      		lsl r25
 530               		2:
 531 002c 8A95      		dec r24
 532 002e 02F4      		brpl 1b
 533 0030 892F      		mov r24,r25
 534 0032 0E94 0000 		call del_mods
 535               	.LVL79:
 536               	.L51:
 845:tmk_core/common/action.c ****             send_keyboard_report();
 537               		.loc 1 845 0
 538 0036 0C94 0000 		jmp send_keyboard_report
 539               	.LVL80:
 540               	.L45:
 846:tmk_core/common/action.c ****         }
 847:tmk_core/common/action.c ****     else if
 848:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 541               		.loc 1 848 0
 542 003a 9BE5      		ldi r25,lo8(91)
 543 003c 980F      		add r25,r24
 544 003e 9330      		cpi r25,lo8(3)
 545 0040 00F4      		brsh .L46
 546               		.loc 1 848 0 is_stmt 0 discriminator 1
 547 0042 80E0      		ldi r24,0
 548 0044 90E0      		ldi r25,0
 549               	.LVL81:
 550 0046 0C94 0000 		jmp host_system_send
 551               	.LVL82:
 552               	.L46:
 849:tmk_core/common/action.c ****     else if
 850:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 553               		.loc 1 850 0 is_stmt 1
 554 004a 98E5      		ldi r25,lo8(88)
 555 004c 980F      		add r25,r24
 556 004e 9731      		cpi r25,lo8(23)
 557 0050 00F4      		brsh .L47
 558               		.loc 1 850 0 is_stmt 0 discriminator 1
 559 0052 80E0      		ldi r24,0
 560 0054 90E0      		ldi r25,0
 561               	.LVL83:
 562 0056 0C94 0000 		jmp host_consumer_send
 563               	.LVL84:
 564               	.L47:
 851:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 852:tmk_core/common/action.c ****     else if
 853:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 565               		.loc 1 853 0 is_stmt 1
 566 005a 803F      		cpi r24,lo8(-16)
 567 005c 00F0      		brlo .L42
 854:tmk_core/common/action.c ****             mousekey_off(code);
 568               		.loc 1 854 0
 569 005e 0E94 0000 		call mousekey_off
 570               	.LVL85:
 855:tmk_core/common/action.c ****             mousekey_send();
 571               		.loc 1 855 0
 572 0062 0C94 0000 		jmp mousekey_send
 573               	.LVL86:
 574               	.L42:
 575 0066 0895      		ret
 576               		.cfi_endproc
 577               	.LFE20:
 579               		.section	.text.tap_code,"ax",@progbits
 580               	.global	tap_code
 582               	tap_code:
 583               	.LFB21:
 856:tmk_core/common/action.c ****         }
 857:tmk_core/common/action.c **** #endif
 858:tmk_core/common/action.c **** }
 859:tmk_core/common/action.c **** 
 860:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 861:tmk_core/common/action.c ****  *
 862:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 863:tmk_core/common/action.c ****  */
 864:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 584               		.loc 1 864 0
 585               		.cfi_startproc
 586               	.LVL87:
 587 0000 CF93      		push r28
 588               	.LCFI4:
 589               		.cfi_def_cfa_offset 3
 590               		.cfi_offset 28, -2
 591               	/* prologue: function */
 592               	/* frame size = 0 */
 593               	/* stack size = 1 */
 594               	.L__stack_usage = 1
 595 0002 C82F      		mov r28,r24
 865:tmk_core/common/action.c ****     register_code(code);
 596               		.loc 1 865 0
 597 0004 0E94 0000 		call register_code
 598               	.LVL88:
 866:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 599               		.loc 1 866 0
 600 0008 C933      		cpi r28,lo8(57)
 601 000a 01F4      		brne .L54
 602               	.LVL89:
 603               	.LBB26:
 604               	.LBB27:
 605               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 606               		.loc 3 163 0
 607 000c 2FEF      		ldi r18,lo8(255999)
 608 000e 87EE      		ldi r24,hi8(255999)
 609 0010 93E0      		ldi r25,hlo8(255999)
 610 0012 2150      	1:	subi r18,1
 611 0014 8040      		sbci r24,0
 612 0016 9040      		sbci r25,0
 613 0018 01F4      		brne 1b
 614 001a 00C0      		rjmp .
 615 001c 0000      		nop
 616               	.LVL90:
 617               	.L54:
 618               	.LBE27:
 619               	.LBE26:
 867:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 868:tmk_core/common/action.c ****     } else {
 869:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 870:tmk_core/common/action.c ****     }
 871:tmk_core/common/action.c ****     unregister_code(code);
 620               		.loc 1 871 0
 621 001e 8C2F      		mov r24,r28
 622               	/* epilogue start */
 872:tmk_core/common/action.c **** }
 623               		.loc 1 872 0
 624 0020 CF91      		pop r28
 625               	.LVL91:
 871:tmk_core/common/action.c **** }
 626               		.loc 1 871 0
 627 0022 0C94 0000 		jmp unregister_code
 628               	.LVL92:
 629               		.cfi_endproc
 630               	.LFE21:
 632               		.section	.text.register_mods,"ax",@progbits
 633               	.global	register_mods
 635               	register_mods:
 636               	.LFB22:
 873:tmk_core/common/action.c **** 
 874:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 875:tmk_core/common/action.c ****  *
 876:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 877:tmk_core/common/action.c ****  */
 878:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 637               		.loc 1 878 0
 638               		.cfi_startproc
 639               	.LVL93:
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 0 */
 643               	.L__stack_usage = 0
 879:tmk_core/common/action.c ****     if (mods) {
 644               		.loc 1 879 0
 645 0000 8823      		tst r24
 646 0002 01F0      		breq .L55
 880:tmk_core/common/action.c ****         add_mods(mods);
 647               		.loc 1 880 0
 648 0004 0E94 0000 		call add_mods
 649               	.LVL94:
 881:tmk_core/common/action.c ****         send_keyboard_report();
 650               		.loc 1 881 0
 651 0008 0C94 0000 		jmp send_keyboard_report
 652               	.LVL95:
 653               	.L55:
 654 000c 0895      		ret
 655               		.cfi_endproc
 656               	.LFE22:
 658               		.section	.text.unregister_mods,"ax",@progbits
 659               	.global	unregister_mods
 661               	unregister_mods:
 662               	.LFB23:
 882:tmk_core/common/action.c ****     }
 883:tmk_core/common/action.c **** }
 884:tmk_core/common/action.c **** 
 885:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 886:tmk_core/common/action.c ****  *
 887:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 888:tmk_core/common/action.c ****  */
 889:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 663               		.loc 1 889 0
 664               		.cfi_startproc
 665               	.LVL96:
 666               	/* prologue: function */
 667               	/* frame size = 0 */
 668               	/* stack size = 0 */
 669               	.L__stack_usage = 0
 890:tmk_core/common/action.c ****     if (mods) {
 670               		.loc 1 890 0
 671 0000 8823      		tst r24
 672 0002 01F0      		breq .L57
 891:tmk_core/common/action.c ****         del_mods(mods);
 673               		.loc 1 891 0
 674 0004 0E94 0000 		call del_mods
 675               	.LVL97:
 892:tmk_core/common/action.c ****         send_keyboard_report();
 676               		.loc 1 892 0
 677 0008 0C94 0000 		jmp send_keyboard_report
 678               	.LVL98:
 679               	.L57:
 680 000c 0895      		ret
 681               		.cfi_endproc
 682               	.LFE23:
 684               		.section	.text.process_action,"ax",@progbits
 685               	.global	process_action
 687               	process_action:
 688               	.LFB18:
 200:tmk_core/common/action.c ****     keyevent_t event = record->event;
 689               		.loc 1 200 0
 690               		.cfi_startproc
 691               	.LVL99:
 692 0000 BF92      		push r11
 693               	.LCFI5:
 694               		.cfi_def_cfa_offset 3
 695               		.cfi_offset 11, -2
 696 0002 CF92      		push r12
 697               	.LCFI6:
 698               		.cfi_def_cfa_offset 4
 699               		.cfi_offset 12, -3
 700 0004 DF92      		push r13
 701               	.LCFI7:
 702               		.cfi_def_cfa_offset 5
 703               		.cfi_offset 13, -4
 704 0006 EF92      		push r14
 705               	.LCFI8:
 706               		.cfi_def_cfa_offset 6
 707               		.cfi_offset 14, -5
 708 0008 FF92      		push r15
 709               	.LCFI9:
 710               		.cfi_def_cfa_offset 7
 711               		.cfi_offset 15, -6
 712 000a 0F93      		push r16
 713               	.LCFI10:
 714               		.cfi_def_cfa_offset 8
 715               		.cfi_offset 16, -7
 716 000c 1F93      		push r17
 717               	.LCFI11:
 718               		.cfi_def_cfa_offset 9
 719               		.cfi_offset 17, -8
 720 000e CF93      		push r28
 721               	.LCFI12:
 722               		.cfi_def_cfa_offset 10
 723               		.cfi_offset 28, -9
 724 0010 DF93      		push r29
 725               	.LCFI13:
 726               		.cfi_def_cfa_offset 11
 727               		.cfi_offset 29, -10
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 9 */
 731               	.L__stack_usage = 9
 732 0012 7C01      		movw r14,r24
 733 0014 062F      		mov r16,r22
 734 0016 C72F      		mov r28,r23
 735               	.LVL100:
 203:tmk_core/common/action.c **** #endif
 736               		.loc 1 203 0
 737 0018 FC01      		movw r30,r24
 738 001a 1581      		ldd r17,Z+5
 739 001c 1295      		swap r17
 740 001e 1F70      		andi r17,lo8(15)
 741               	.LVL101:
 206:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 742               		.loc 1 206 0
 743 0020 D281      		ldd r29,Z+2
 744 0022 D111      		cpse r29,__zero_reg__
 208:tmk_core/common/action.c ****     }
 745               		.loc 1 208 0
 746 0024 0E94 0000 		call clear_weak_mods
 747               	.LVL102:
 748               	.L60:
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 749               		.loc 1 214 0
 750 0028 0E94 0000 		call is_oneshot_layer_active
 751               	.LVL103:
 752 002c 8823      		tst r24
 753 002e 01F0      		breq .L159
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 754               		.loc 1 214 0 is_stmt 0 discriminator 1
 755 0030 DD23      		tst r29
 756 0032 01F0      		breq .L159
 214:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 757               		.loc 1 214 0 discriminator 2
 758 0034 80E2      		ldi r24,lo8(32)
 759 0036 800F      		add r24,r16
 760 0038 8830      		cpi r24,lo8(8)
 761 003a 00F0      		brlo .L159
 215:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 762               		.loc 1 215 0 is_stmt 1
 763 003c 82E0      		ldi r24,lo8(2)
 764 003e 0E94 0000 		call clear_oneshot_layer_state
 765               	.LVL104:
 216:tmk_core/common/action.c ****     }
 766               		.loc 1 216 0
 767 0042 0E94 0000 		call is_oneshot_layer_active
 768               	.LVL105:
 769 0046 91E0      		ldi r25,lo8(1)
 770 0048 B82E      		mov r11,r24
 771 004a B926      		eor r11,r25
 772               	.LVL106:
 773 004c 00C0      		rjmp .L61
 774               	.LVL107:
 775               	.L159:
 212:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 776               		.loc 1 212 0
 777 004e B12C      		mov r11,__zero_reg__
 778               	.LVL108:
 779               	.L61:
 220:tmk_core/common/action.c ****         /* Key and Mods */
 780               		.loc 1 220 0
 781 0050 CC2E      		mov r12,r28
 782 0052 C294      		swap r12
 783 0054 8FE0      		ldi r24,lo8(15)
 784 0056 C822      		and r12,r24
 785 0058 D12C      		mov r13,__zero_reg__
 786 005a F601      		movw r30,r12
 787 005c E050      		subi r30,lo8(-(gs(.L64)))
 788 005e F040      		sbci r31,hi8(-(gs(.L64)))
 789 0060 0C94 0000 		jmp __tablejump2__
 790               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 791               		.p2align	1
 792               	.L64:
 793 0000 0000      		.word gs(.L63)
 794 0002 0000      		.word gs(.L63)
 795 0004 0000      		.word gs(.L65)
 796 0006 0000      		.word gs(.L65)
 797 0008 0000      		.word gs(.L66)
 798 000a 0000      		.word gs(.L67)
 799 000c 0000      		.word gs(.L62)
 800 000e 0000      		.word gs(.L62)
 801 0010 0000      		.word gs(.L68)
 802 0012 0000      		.word gs(.L69)
 803 0014 0000      		.word gs(.L70)
 804 0016 0000      		.word gs(.L70)
 805 0018 0000      		.word gs(.L71)
 806 001a 0000      		.word gs(.L72)
 807 001c 0000      		.word gs(.L62)
 808 001e 0000      		.word gs(.L73)
 809               		.section	.text.process_action
 810               	.L63:
 811               	.LBB28:
 224:tmk_core/common/action.c ****             if (event.pressed) {
 812               		.loc 1 224 0
 813 0064 8C2F      		mov r24,r28
 814 0066 807F      		andi r24,lo8(-16)
 815 0068 CF70      		andi r28,lo8(15)
 816               	.LVL109:
 817 006a 8823      		tst r24
 818 006c 01F0      		breq .L75
 224:tmk_core/common/action.c ****             if (event.pressed) {
 819               		.loc 1 224 0 is_stmt 0 discriminator 2
 820 006e C295      		swap r28
 821 0070 C07F      		andi r28,lo8(-16)
 822               	.L75:
 823               	.LVL110:
 225:tmk_core/common/action.c ****                 if (mods) {
 824               		.loc 1 225 0 is_stmt 1 discriminator 4
 825 0072 DD23      		tst r29
 826 0074 01F0      		breq .L76
 226:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 827               		.loc 1 226 0
 828 0076 CC23      		tst r28
 829 0078 01F4      		brne .+2
 830 007a 00C0      		rjmp .L186
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 831               		.loc 1 227 0
 832 007c 80E2      		ldi r24,lo8(32)
 833 007e 800F      		add r24,r16
 834 0080 8830      		cpi r24,lo8(8)
 835 0082 00F0      		brlo .L78
 227:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 836               		.loc 1 227 0 is_stmt 0 discriminator 1
 837 0084 0111      		cpse r16,__zero_reg__
 838 0086 00C0      		rjmp .L79
 839               	.L78:
 231:tmk_core/common/action.c ****                     } else {
 840               		.loc 1 231 0 is_stmt 1
 841 0088 8C2F      		mov r24,r28
 842 008a 0E94 0000 		call add_mods
 843               	.LVL111:
 844 008e 00C0      		rjmp .L80
 845               	.L79:
 233:tmk_core/common/action.c ****                     }
 846               		.loc 1 233 0
 847 0090 8C2F      		mov r24,r28
 848 0092 0E94 0000 		call add_weak_mods
 849               	.LVL112:
 850               	.L80:
 235:tmk_core/common/action.c ****                 }
 851               		.loc 1 235 0
 852 0096 0E94 0000 		call send_keyboard_report
 853               	.LVL113:
 854 009a 00C0      		rjmp .L186
 855               	.L76:
 239:tmk_core/common/action.c ****                 if (mods) {
 856               		.loc 1 239 0
 857 009c 802F      		mov r24,r16
 858 009e 0E94 0000 		call unregister_code
 859               	.LVL114:
 240:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 860               		.loc 1 240 0
 861 00a2 CC23      		tst r28
 862 00a4 01F4      		brne .+2
 863 00a6 00C0      		rjmp .L62
 241:tmk_core/common/action.c ****                         del_mods(mods);
 864               		.loc 1 241 0
 865 00a8 80E2      		ldi r24,lo8(32)
 866 00aa 800F      		add r24,r16
 867 00ac 8830      		cpi r24,lo8(8)
 868 00ae 00F0      		brlo .L82
 241:tmk_core/common/action.c ****                         del_mods(mods);
 869               		.loc 1 241 0 is_stmt 0 discriminator 1
 870 00b0 0111      		cpse r16,__zero_reg__
 871 00b2 00C0      		rjmp .L83
 872               	.L82:
 242:tmk_core/common/action.c ****                     } else {
 873               		.loc 1 242 0 is_stmt 1
 874 00b4 8C2F      		mov r24,r28
 875 00b6 0E94 0000 		call del_mods
 876               	.LVL115:
 877 00ba 00C0      		rjmp .L84
 878               	.L83:
 244:tmk_core/common/action.c ****                     }
 879               		.loc 1 244 0
 880 00bc 8C2F      		mov r24,r28
 881 00be 0E94 0000 		call del_weak_mods
 882               	.LVL116:
 883               	.L84:
 246:tmk_core/common/action.c ****                 }
 884               		.loc 1 246 0
 885 00c2 0E94 0000 		call send_keyboard_report
 886               	.LVL117:
 887 00c6 00C0      		rjmp .L62
 888               	.LVL118:
 889               	.L65:
 890               	.LBE28:
 891               	.LBB29:
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 892               		.loc 1 253 0
 893 00c8 8C2F      		mov r24,r28
 894 00ca 807F      		andi r24,lo8(-16)
 895 00cc CF70      		andi r28,lo8(15)
 896               	.LVL119:
 897 00ce 8032      		cpi r24,lo8(32)
 898 00d0 01F0      		breq .L86
 253:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 899               		.loc 1 253 0 is_stmt 0 discriminator 2
 900 00d2 C295      		swap r28
 901 00d4 C07F      		andi r28,lo8(-16)
 902               	.L86:
 903               	.LVL120:
 254:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 904               		.loc 1 254 0 is_stmt 1 discriminator 4
 905 00d6 0023      		tst r16
 906 00d8 01F0      		breq .L88
 907 00da 0130      		cpi r16,lo8(1)
 908 00dc 01F0      		breq .L89
 909 00de 00C0      		rjmp .L194
 910               	.L88:
 258:tmk_core/common/action.c ****                         if (tap_count == 0) {
 911               		.loc 1 258 0
 912 00e0 DD23      		tst r29
 913 00e2 01F0      		breq .L90
 259:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 914               		.loc 1 259 0
 915 00e4 1123      		tst r17
 916 00e6 01F0      		breq .L92
 262:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 917               		.loc 1 262 0
 918 00e8 1130      		cpi r17,lo8(1)
 919 00ea 01F4      		brne .L92
 264:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 920               		.loc 1 264 0
 921 00ec 0E94 0000 		call get_oneshot_mods
 922               	.LVL121:
 923 00f0 8C2B      		or r24,r28
 924 00f2 0E94 0000 		call set_oneshot_mods
 925               	.LVL122:
 926 00f6 00C0      		rjmp .L62
 927               	.L92:
 273:tmk_core/common/action.c ****                         }
 928               		.loc 1 273 0
 929 00f8 0E94 0000 		call get_oneshot_mods
 930               	.LVL123:
 931 00fc 8C2B      		or r24,r28
 932 00fe 00C0      		rjmp .L187
 933               	.L90:
 276:tmk_core/common/action.c ****                             clear_oneshot_mods();
 934               		.loc 1 276 0
 935 0100 1123      		tst r17
 936 0102 01F0      		breq .L192
 279:tmk_core/common/action.c ****                             // Retain Oneshot mods
 937               		.loc 1 279 0
 938 0104 1130      		cpi r17,lo8(1)
 939 0106 01F4      		brne .+2
 940 0108 00C0      		rjmp .L62
 941               	.L192:
 291:tmk_core/common/action.c ****                             unregister_mods(mods);
 942               		.loc 1 291 0
 943 010a 0E94 0000 		call clear_oneshot_mods
 944               	.LVL124:
 945 010e 00C0      		rjmp .L98
 946               	.L89:
 298:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 947               		.loc 1 298 0
 948 0110 DD23      		tst r29
 949 0112 01F0      		breq .L95
 299:tmk_core/common/action.c ****                             register_mods(mods);
 950               		.loc 1 299 0
 951 0114 1630      		cpi r17,lo8(6)
 952 0116 00F0      		brlo .+2
 953 0118 00C0      		rjmp .L62
 954 011a 00C0      		rjmp .L97
 955               	.L95:
 303:tmk_core/common/action.c ****                             unregister_mods(mods);
 956               		.loc 1 303 0
 957 011c 1530      		cpi r17,lo8(5)
 958 011e 00F0      		brlo .+2
 959 0120 00C0      		rjmp .L62
 960 0122 00C0      		rjmp .L98
 961               	.L194:
 309:tmk_core/common/action.c ****                         if (tap_count > 0) {
 962               		.loc 1 309 0
 963 0124 DD23      		tst r29
 964 0126 01F0      		breq .L96
 310:tmk_core/common/action.c **** #    ifndef IGNORE_MOD_TAP_INTERRUPT
 965               		.loc 1 310 0
 966 0128 1111      		cpse r17,__zero_reg__
 967 012a 00C0      		rjmp .L186
 968               	.L97:
 325:tmk_core/common/action.c ****                         }
 969               		.loc 1 325 0
 970 012c 8C2F      		mov r24,r28
 971               	.L187:
 972 012e 0E94 0000 		call register_mods
 973               	.LVL125:
 974 0132 00C0      		rjmp .L62
 975               	.L96:
 328:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 976               		.loc 1 328 0
 977 0134 1123      		tst r17
 978 0136 01F0      		breq .L98
 330:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 979               		.loc 1 330 0
 980 0138 0933      		cpi r16,lo8(57)
 981 013a 01F0      		breq .+2
 982 013c 00C0      		rjmp .L144
 983               	.LVL126:
 984               	.LBB30:
 985               	.LBB31:
 986               		.loc 3 163 0
 987 013e FFEF      		ldi r31,lo8(255999)
 988 0140 27EE      		ldi r18,hi8(255999)
 989 0142 83E0      		ldi r24,hlo8(255999)
 990 0144 F150      	1:	subi r31,1
 991 0146 2040      		sbci r18,0
 992 0148 8040      		sbci r24,0
 993 014a 01F4      		brne 1b
 994 014c 00C0      		rjmp .L193
 995               	.LVL127:
 996               	.L98:
 997               	.LBE31:
 998               	.LBE30:
 336:tmk_core/common/action.c ****                         }
 999               		.loc 1 336 0
 1000 014e 8C2F      		mov r24,r28
 1001 0150 0E94 0000 		call unregister_mods
 1002               	.LVL128:
 1003 0154 00C0      		rjmp .L62
 1004               	.LVL129:
 1005               	.L66:
 1006               	.LBE29:
 346:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1007               		.loc 1 346 0
 1008 0156 8C2F      		mov r24,r28
 1009 0158 8695      		lsr r24
 1010 015a 8695      		lsr r24
 1011 015c 8370      		andi r24,lo8(3)
 1012 015e 90E0      		ldi r25,0
 1013 0160 0097      		sbiw r24,0
 1014 0162 01F0      		breq .L100
 1015 0164 0197      		sbiw r24,1
 1016 0166 01F0      		breq .L101
 1017 0168 00C0      		rjmp .L62
 1018               	.L100:
 348:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1019               		.loc 1 348 0
 1020 016a DD23      		tst r29
 1021 016c 01F0      		breq .L102
 349:tmk_core/common/action.c ****                     } else {
 1022               		.loc 1 349 0
 1023 016e 802F      		mov r24,r16
 1024 0170 9C2F      		mov r25,r28
 1025 0172 9370      		andi r25,lo8(3)
 1026 0174 00C0      		rjmp .L189
 1027               	.L102:
 351:tmk_core/common/action.c ****                     }
 1028               		.loc 1 351 0
 1029 0176 80E0      		ldi r24,0
 1030 0178 90E0      		ldi r25,0
 1031               	.L189:
 1032 017a 0E94 0000 		call host_system_send
 1033               	.LVL130:
 1034 017e 00C0      		rjmp .L152
 1035               	.L101:
 355:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1036               		.loc 1 355 0
 1037 0180 DD23      		tst r29
 1038 0182 01F0      		breq .L104
 356:tmk_core/common/action.c ****                     } else {
 1039               		.loc 1 356 0
 1040 0184 802F      		mov r24,r16
 1041 0186 9C2F      		mov r25,r28
 1042 0188 9370      		andi r25,lo8(3)
 1043 018a 00C0      		rjmp .L190
 1044               	.L104:
 358:tmk_core/common/action.c ****                     }
 1045               		.loc 1 358 0
 1046 018c 80E0      		ldi r24,0
 1047 018e 90E0      		ldi r25,0
 1048               	.L190:
 1049 0190 0E94 0000 		call host_consumer_send
 1050               	.LVL131:
 1051 0194 00C0      		rjmp .L152
 1052               	.L67:
 367:tmk_core/common/action.c ****                 switch (action.key.code) {
 1053               		.loc 1 367 0
 1054 0196 DD23      		tst r29
 1055 0198 01F0      		breq .L105
 368:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1056               		.loc 1 368 0
 1057 019a 053F      		cpi r16,lo8(-11)
 1058 019c 01F0      		breq .L107
 1059 019e 063F      		cpi r16,lo8(-10)
 1060 01a0 01F0      		breq .L108
 1061 01a2 043F      		cpi r16,lo8(-12)
 1062 01a4 01F4      		brne .L106
 370:tmk_core/common/action.c ****                         break;
 1063               		.loc 1 370 0
 1064 01a6 8091 0000 		lds r24,tp_buttons
 1065 01aa 9091 0000 		lds r25,tp_buttons+1
 1066 01ae 8160      		ori r24,1
 1067 01b0 00C0      		rjmp .L184
 1068               	.L107:
 373:tmk_core/common/action.c ****                         break;
 1069               		.loc 1 373 0
 1070 01b2 8091 0000 		lds r24,tp_buttons
 1071 01b6 9091 0000 		lds r25,tp_buttons+1
 1072 01ba 8260      		ori r24,2
 1073 01bc 00C0      		rjmp .L184
 1074               	.L108:
 376:tmk_core/common/action.c ****                         break;
 1075               		.loc 1 376 0
 1076 01be 8091 0000 		lds r24,tp_buttons
 1077 01c2 9091 0000 		lds r25,tp_buttons+1
 1078 01c6 8460      		ori r24,4
 1079               	.L184:
 1080 01c8 9093 0000 		sts tp_buttons+1,r25
 1081 01cc 8093 0000 		sts tp_buttons,r24
 1082               	.L106:
 381:tmk_core/common/action.c ****                 mousekey_send();
 1083               		.loc 1 381 0
 1084 01d0 802F      		mov r24,r16
 1085 01d2 0E94 0000 		call mousekey_on
 1086               	.LVL132:
 1087 01d6 00C0      		rjmp .L191
 1088               	.L105:
 384:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1089               		.loc 1 384 0
 1090 01d8 053F      		cpi r16,lo8(-11)
 1091 01da 01F0      		breq .L111
 1092 01dc 063F      		cpi r16,lo8(-10)
 1093 01de 01F0      		breq .L112
 1094 01e0 043F      		cpi r16,lo8(-12)
 1095 01e2 01F4      		brne .L110
 386:tmk_core/common/action.c ****                         break;
 1096               		.loc 1 386 0
 1097 01e4 8091 0000 		lds r24,tp_buttons
 1098 01e8 9091 0000 		lds r25,tp_buttons+1
 1099 01ec 8E7F      		andi r24,254
 1100 01ee 00C0      		rjmp .L185
 1101               	.L111:
 389:tmk_core/common/action.c ****                         break;
 1102               		.loc 1 389 0
 1103 01f0 8091 0000 		lds r24,tp_buttons
 1104 01f4 9091 0000 		lds r25,tp_buttons+1
 1105 01f8 8D7F      		andi r24,253
 1106 01fa 00C0      		rjmp .L185
 1107               	.L112:
 392:tmk_core/common/action.c ****                         break;
 1108               		.loc 1 392 0
 1109 01fc 8091 0000 		lds r24,tp_buttons
 1110 0200 9091 0000 		lds r25,tp_buttons+1
 1111 0204 8B7F      		andi r24,251
 1112               	.L185:
 1113 0206 9093 0000 		sts tp_buttons+1,r25
 1114 020a 8093 0000 		sts tp_buttons,r24
 1115               	.L110:
 397:tmk_core/common/action.c ****                 mousekey_send();
 1116               		.loc 1 397 0
 1117 020e 802F      		mov r24,r16
 1118 0210 0E94 0000 		call mousekey_off
 1119               	.LVL133:
 1120               	.L191:
 398:tmk_core/common/action.c ****             }
 1121               		.loc 1 398 0
 1122 0214 0E94 0000 		call mousekey_send
 1123               	.LVL134:
 1124 0218 00C0      		rjmp .L152
 1125               	.L68:
 404:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1126               		.loc 1 404 0
 1127 021a 8C2F      		mov r24,r28
 1128 021c 8370      		andi r24,lo8(3)
 1129 021e 01F0      		breq .+2
 1130 0220 00C0      		rjmp .L114
 406:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1131               		.loc 1 406 0
 1132 0222 D111      		cpse r29,__zero_reg__
 1133 0224 00C0      		rjmp .L153
 1134               	.LVL135:
 1135               	.LBB32:
 407:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1136               		.loc 1 407 0
 1137 0226 402F      		mov r20,r16
 1138 0228 4295      		swap r20
 1139 022a 4695      		lsr r20
 1140 022c 4770      		andi r20,lo8(7)
 1141 022e 440F      		lsl r20
 1142 0230 440F      		lsl r20
 408:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1143               		.loc 1 408 0
 1144 0232 602F      		mov r22,r16
 1145 0234 6F70      		andi r22,lo8(15)
 1146 0236 862F      		mov r24,r22
 1147 0238 90E0      		ldi r25,0
 1148 023a A0E0      		ldi r26,0
 1149 023c B0E0      		ldi r27,0
 1150 023e 042E      		mov r0,r20
 1151 0240 00C0      		rjmp 2f
 1152               		1:
 1153 0242 880F      		lsl r24
 1154 0244 991F      		rol r25
 1155 0246 AA1F      		rol r26
 1156 0248 BB1F      		rol r27
 1157               		2:
 1158 024a 0A94      		dec r0
 1159 024c 02F4      		brpl 1b
 1160               	.LVL136:
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1161               		.loc 1 409 0
 1162 024e 04FF      		sbrs r16,4
 1163 0250 00C0      		rjmp .L160
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1164               		.loc 1 409 0 is_stmt 0 discriminator 1
 1165 0252 0FE0      		ldi r16,lo8(15)
 1166 0254 10E0      		ldi r17,0
 1167 0256 20E0      		ldi r18,0
 1168 0258 30E0      		ldi r19,0
 1169               	.LVL137:
 1170 025a 00C0      		rjmp 2f
 1171               		1:
 1172 025c 000F      		lsl r16
 1173 025e 111F      		rol r17
 1174 0260 221F      		rol r18
 1175 0262 331F      		rol r19
 1176               		2:
 1177 0264 4A95      		dec r20
 1178 0266 02F4      		brpl 1b
 1179 0268 0095      		com r16
 1180 026a 1095      		com r17
 1181 026c 2095      		com r18
 1182 026e 3095      		com r19
 1183 0270 00C0      		rjmp .L116
 1184               	.LVL138:
 1185               	.L160:
 409:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1186               		.loc 1 409 0
 1187 0272 00E0      		ldi r16,0
 1188 0274 10E0      		ldi r17,0
 1189 0276 9801      		movw r18,r16
 1190               	.LVL139:
 1191               	.L116:
 410:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1192               		.loc 1 410 0 is_stmt 1 discriminator 4
 1193 0278 C695      		lsr r28
 1194 027a C695      		lsr r28
 1195 027c C370      		andi r28,lo8(3)
 1196 027e D0E0      		ldi r29,0
 1197               	.LVL140:
 1198 0280 BC01      		movw r22,r24
 1199 0282 CD01      		movw r24,r26
 1200 0284 602B      		or r22,r16
 1201 0286 712B      		or r23,r17
 1202 0288 822B      		or r24,r18
 1203 028a 932B      		or r25,r19
 1204 028c C230      		cpi r28,2
 1205 028e D105      		cpc r29,__zero_reg__
 1206 0290 01F0      		breq .L118
 1207 0292 C330      		cpi r28,3
 1208 0294 D105      		cpc r29,__zero_reg__
 1209 0296 01F0      		breq .L119
 1210 0298 2197      		sbiw r28,1
 1211 029a 01F0      		breq .L120
 412:tmk_core/common/action.c ****                             break;
 1212               		.loc 1 412 0 discriminator 4
 1213 029c 0E94 0000 		call default_layer_and
 1214               	.LVL141:
 413:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1215               		.loc 1 413 0 discriminator 4
 1216 02a0 00C0      		rjmp .L153
 1217               	.LVL142:
 1218               	.L120:
 415:tmk_core/common/action.c ****                             break;
 1219               		.loc 1 415 0
 1220 02a2 0E94 0000 		call default_layer_or
 1221               	.LVL143:
 416:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1222               		.loc 1 416 0
 1223 02a6 00C0      		rjmp .L153
 1224               	.LVL144:
 1225               	.L118:
 418:tmk_core/common/action.c ****                             break;
 1226               		.loc 1 418 0
 1227 02a8 0E94 0000 		call default_layer_xor
 1228               	.LVL145:
 419:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1229               		.loc 1 419 0
 1230 02ac 00C0      		rjmp .L153
 1231               	.LVL146:
 1232               	.L119:
 421:tmk_core/common/action.c ****                             break;
 1233               		.loc 1 421 0
 1234 02ae 0E94 0000 		call default_layer_set
 1235               	.LVL147:
 422:tmk_core/common/action.c ****                     }
 1236               		.loc 1 422 0
 1237 02b2 00C0      		rjmp .L153
 1238               	.LVL148:
 1239               	.L114:
 1240               	.LBE32:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1241               		.loc 1 427 0
 1242 02b4 DD23      		tst r29
 1243 02b6 01F0      		breq .L121
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1244               		.loc 1 427 0 is_stmt 0 discriminator 1
 1245 02b8 8C2F      		mov r24,r28
 1246 02ba 8170      		andi r24,lo8(1)
 1247 02bc 00C0      		rjmp .L122
 1248               	.L121:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1249               		.loc 1 427 0 discriminator 2
 1250 02be 8695      		lsr r24
 1251               	.L122:
 427:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1252               		.loc 1 427 0 discriminator 4
 1253 02c0 8823      		tst r24
 1254 02c2 01F4      		brne .+2
 1255 02c4 00C0      		rjmp .L153
 1256               	.LVL149:
 1257               	.LBB33:
 428:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1258               		.loc 1 428 0 is_stmt 1
 1259 02c6 402F      		mov r20,r16
 1260 02c8 4295      		swap r20
 1261 02ca 4695      		lsr r20
 1262 02cc 4770      		andi r20,lo8(7)
 1263 02ce 440F      		lsl r20
 1264 02d0 440F      		lsl r20
 429:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1265               		.loc 1 429 0
 1266 02d2 602F      		mov r22,r16
 1267 02d4 6F70      		andi r22,lo8(15)
 1268 02d6 862F      		mov r24,r22
 1269 02d8 90E0      		ldi r25,0
 1270 02da A0E0      		ldi r26,0
 1271 02dc B0E0      		ldi r27,0
 1272 02de 042E      		mov r0,r20
 1273 02e0 00C0      		rjmp 2f
 1274               		1:
 1275 02e2 880F      		lsl r24
 1276 02e4 991F      		rol r25
 1277 02e6 AA1F      		rol r26
 1278 02e8 BB1F      		rol r27
 1279               		2:
 1280 02ea 0A94      		dec r0
 1281 02ec 02F4      		brpl 1b
 1282               	.LVL150:
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1283               		.loc 1 430 0
 1284 02ee 04FF      		sbrs r16,4
 1285 02f0 00C0      		rjmp .L161
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1286               		.loc 1 430 0 is_stmt 0 discriminator 1
 1287 02f2 0FE0      		ldi r16,lo8(15)
 1288 02f4 10E0      		ldi r17,0
 1289 02f6 20E0      		ldi r18,0
 1290 02f8 30E0      		ldi r19,0
 1291               	.LVL151:
 1292 02fa 00C0      		rjmp 2f
 1293               		1:
 1294 02fc 000F      		lsl r16
 1295 02fe 111F      		rol r17
 1296 0300 221F      		rol r18
 1297 0302 331F      		rol r19
 1298               		2:
 1299 0304 4A95      		dec r20
 1300 0306 02F4      		brpl 1b
 1301 0308 0095      		com r16
 1302 030a 1095      		com r17
 1303 030c 2095      		com r18
 1304 030e 3095      		com r19
 1305 0310 00C0      		rjmp .L123
 1306               	.LVL152:
 1307               	.L161:
 430:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1308               		.loc 1 430 0
 1309 0312 00E0      		ldi r16,0
 1310 0314 10E0      		ldi r17,0
 1311 0316 9801      		movw r18,r16
 1312               	.LVL153:
 1313               	.L123:
 431:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1314               		.loc 1 431 0 is_stmt 1 discriminator 4
 1315 0318 C695      		lsr r28
 1316 031a C695      		lsr r28
 1317 031c C370      		andi r28,lo8(3)
 1318 031e D0E0      		ldi r29,0
 1319               	.LVL154:
 1320 0320 BC01      		movw r22,r24
 1321 0322 CD01      		movw r24,r26
 1322 0324 602B      		or r22,r16
 1323 0326 712B      		or r23,r17
 1324 0328 822B      		or r24,r18
 1325 032a 932B      		or r25,r19
 1326 032c C230      		cpi r28,2
 1327 032e D105      		cpc r29,__zero_reg__
 1328 0330 01F0      		breq .L125
 1329 0332 C330      		cpi r28,3
 1330 0334 D105      		cpc r29,__zero_reg__
 1331 0336 01F0      		breq .L126
 1332 0338 2197      		sbiw r28,1
 1333 033a 01F0      		breq .L127
 433:tmk_core/common/action.c ****                             break;
 1334               		.loc 1 433 0 discriminator 4
 1335 033c 0E94 0000 		call layer_and
 1336               	.LVL155:
 434:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1337               		.loc 1 434 0 discriminator 4
 1338 0340 00C0      		rjmp .L153
 1339               	.LVL156:
 1340               	.L127:
 436:tmk_core/common/action.c ****                             break;
 1341               		.loc 1 436 0
 1342 0342 0E94 0000 		call layer_or
 1343               	.LVL157:
 437:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1344               		.loc 1 437 0
 1345 0346 00C0      		rjmp .L153
 1346               	.LVL158:
 1347               	.L125:
 439:tmk_core/common/action.c ****                             break;
 1348               		.loc 1 439 0
 1349 0348 0E94 0000 		call layer_xor
 1350               	.LVL159:
 440:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1351               		.loc 1 440 0
 1352 034c 00C0      		rjmp .L153
 1353               	.LVL160:
 1354               	.L126:
 442:tmk_core/common/action.c ****                             break;
 1355               		.loc 1 442 0
 1356 034e 0E94 0000 		call layer_state_set
 1357               	.LVL161:
 443:tmk_core/common/action.c ****                     }
 1358               		.loc 1 443 0
 1359 0352 00C0      		rjmp .L153
 1360               	.LVL162:
 1361               	.L69:
 1362 0354 CF70      		andi r28,lo8(15)
 1363               	.LVL163:
 1364               	.LBE33:
 449:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1365               		.loc 1 449 0
 1366 0356 DD23      		tst r29
 1367 0358 01F0      		breq .L128
 450:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1368               		.loc 1 450 0
 1369 035a 8C2F      		mov r24,r28
 1370 035c 0E94 0000 		call layer_on
 1371               	.LVL164:
 451:tmk_core/common/action.c ****             } else {
 1372               		.loc 1 451 0
 1373 0360 802F      		mov r24,r16
 1374 0362 0E94 0000 		call register_mods
 1375               	.LVL165:
 1376 0366 00C0      		rjmp .L153
 1377               	.L128:
 453:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1378               		.loc 1 453 0
 1379 0368 802F      		mov r24,r16
 1380 036a 0E94 0000 		call unregister_mods
 1381               	.LVL166:
 454:tmk_core/common/action.c ****             }
 1382               		.loc 1 454 0
 1383 036e 8C2F      		mov r24,r28
 1384 0370 0E94 0000 		call layer_off
 1385               	.LVL167:
 1386 0374 00C0      		rjmp .L153
 1387               	.LVL168:
 1388               	.L70:
 460:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1389               		.loc 1 460 0
 1390 0376 023F      		cpi r16,lo8(-14)
 1391 0378 01F0      		breq .L130
 1392 037a 00F4      		brsh .L131
 1393 037c 003F      		cpi r16,lo8(-16)
 1394 037e 01F0      		breq .L132
 1395 0380 013F      		cpi r16,lo8(-15)
 1396 0382 01F0      		breq .L133
 1397 0384 00C0      		rjmp .L129
 1398               	.L131:
 1399 0386 033F      		cpi r16,lo8(-13)
 1400 0388 01F0      		breq .L134
 1401 038a 043F      		cpi r16,lo8(-12)
 1402 038c 01F0      		breq .L135
 1403 038e 00C0      		rjmp .L129
 1404               	.L132:
 463:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1405               		.loc 1 463 0
 1406 0390 DD23      		tst r29
 1407 0392 01F0      		breq .L136
 464:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1408               		.loc 1 464 0
 1409 0394 1530      		cpi r17,lo8(5)
 1410 0396 00F0      		brlo .+2
 1411 0398 00C0      		rjmp .L62
 1412               	.L137:
 465:tmk_core/common/action.c ****                         }
 1413               		.loc 1 465 0
 1414 039a 8C2F      		mov r24,r28
 1415 039c 8F71      		andi r24,lo8(31)
 1416 039e 0E94 0000 		call layer_invert
 1417               	.LVL169:
 1418 03a2 00C0      		rjmp .L62
 1419               	.L136:
 468:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1420               		.loc 1 468 0
 1421 03a4 1630      		cpi r17,lo8(6)
 1422 03a6 00F0      		brlo .+2
 1423 03a8 00C0      		rjmp .L62
 1424 03aa 00C0      		rjmp .L137
 1425               	.L133:
 474:tmk_core/common/action.c ****                     break;
 1426               		.loc 1 474 0
 1427 03ac DD23      		tst r29
 1428 03ae 01F0      		breq .L138
 1429               	.L139:
 474:tmk_core/common/action.c ****                     break;
 1430               		.loc 1 474 0 is_stmt 0 discriminator 1
 1431 03b0 8C2F      		mov r24,r28
 1432 03b2 8F71      		andi r24,lo8(31)
 1433 03b4 0E94 0000 		call layer_on
 1434               	.LVL170:
 1435 03b8 00C0      		rjmp .L62
 1436               	.L130:
 477:tmk_core/common/action.c ****                     break;
 1437               		.loc 1 477 0 is_stmt 1
 1438 03ba DD23      		tst r29
 1439 03bc 01F0      		breq .L139
 1440               	.L138:
 474:tmk_core/common/action.c ****                     break;
 1441               		.loc 1 474 0 discriminator 2
 1442 03be 8C2F      		mov r24,r28
 1443 03c0 8F71      		andi r24,lo8(31)
 1444 03c2 0E94 0000 		call layer_off
 1445               	.LVL171:
 1446 03c6 00C0      		rjmp .L62
 1447               	.L134:
 480:tmk_core/common/action.c ****                     break;
 1448               		.loc 1 480 0
 1449 03c8 DD23      		tst r29
 1450 03ca 01F0      		breq .L140
 480:tmk_core/common/action.c ****                     break;
 1451               		.loc 1 480 0 is_stmt 0 discriminator 1
 1452 03cc 8C2F      		mov r24,r28
 1453 03ce 8F71      		andi r24,lo8(31)
 1454 03d0 0E94 0000 		call layer_move
 1455               	.LVL172:
 1456 03d4 00C0      		rjmp .L62
 1457               	.L140:
 480:tmk_core/common/action.c ****                     break;
 1458               		.loc 1 480 0 discriminator 2
 1459 03d6 0E94 0000 		call layer_clear
 1460               	.LVL173:
 1461 03da 00C0      		rjmp .L62
 1462               	.L135:
 508:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1463               		.loc 1 508 0 is_stmt 1
 1464 03dc DD23      		tst r29
 1465 03de 01F0      		breq .L141
 509:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1466               		.loc 1 509 0
 1467 03e0 CF71      		andi r28,lo8(31)
 1468               	.LVL174:
 1469 03e2 8C2F      		mov r24,r28
 1470 03e4 0E94 0000 		call layer_on
 1471               	.LVL175:
 510:tmk_core/common/action.c ****                     } else {
 1472               		.loc 1 510 0
 1473 03e8 63E0      		ldi r22,lo8(3)
 1474 03ea 8C2F      		mov r24,r28
 1475 03ec 0E94 0000 		call set_oneshot_layer
 1476               	.LVL176:
 1477 03f0 00C0      		rjmp .L62
 1478               	.LVL177:
 1479               	.L141:
 512:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1480               		.loc 1 512 0
 1481 03f2 81E0      		ldi r24,lo8(1)
 1482 03f4 0E94 0000 		call clear_oneshot_layer_state
 1483               	.LVL178:
 513:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1484               		.loc 1 513 0
 1485 03f8 1230      		cpi r17,lo8(2)
 1486 03fa 00F4      		brsh .+2
 1487 03fc 00C0      		rjmp .L62
 514:tmk_core/common/action.c ****                         }
 1488               		.loc 1 514 0
 1489 03fe 82E0      		ldi r24,lo8(2)
 1490 0400 0E94 0000 		call clear_oneshot_layer_state
 1491               	.LVL179:
 1492 0404 00C0      		rjmp .L62
 1493               	.L129:
 522:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1494               		.loc 1 522 0
 1495 0406 DD23      		tst r29
 1496 0408 01F0      		breq .L142
 523:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1497               		.loc 1 523 0
 1498 040a 1123      		tst r17
 1499 040c 01F0      		breq .L139
 1500               	.L186:
 525:tmk_core/common/action.c ****                         } else {
 1501               		.loc 1 525 0
 1502 040e 802F      		mov r24,r16
 1503 0410 0E94 0000 		call register_code
 1504               	.LVL180:
 1505 0414 00C0      		rjmp .L62
 1506               	.L142:
 531:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1507               		.loc 1 531 0
 1508 0416 1123      		tst r17
 1509 0418 01F0      		breq .L138
 533:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1510               		.loc 1 533 0
 1511 041a 0933      		cpi r16,lo8(57)
 1512 041c 01F4      		brne .L144
 1513               	.LVL181:
 1514               	.LBB34:
 1515               	.LBB35:
 1516               		.loc 3 163 0
 1517 041e 9FEF      		ldi r25,lo8(255999)
 1518 0420 E7EE      		ldi r30,hi8(255999)
 1519 0422 F3E0      		ldi r31,hlo8(255999)
 1520 0424 9150      	1:	subi r25,1
 1521 0426 E040      		sbci r30,0
 1522 0428 F040      		sbci r31,0
 1523 042a 01F4      		brne 1b
 1524               	.LVL182:
 1525               	.L193:
 1526 042c 00C0      		rjmp .
 1527 042e 0000      		nop
 1528               	.L144:
 1529               	.LBE35:
 1530               	.LBE34:
 538:tmk_core/common/action.c ****                         } else {
 1531               		.loc 1 538 0
 1532 0430 802F      		mov r24,r16
 1533 0432 0E94 0000 		call unregister_code
 1534               	.LVL183:
 1535 0436 00C0      		rjmp .L62
 1536               	.L71:
 552:tmk_core/common/action.c ****             break;
 1537               		.loc 1 552 0
 1538 0438 4C2F      		mov r20,r28
 1539 043a 4F70      		andi r20,lo8(15)
 1540 043c 602F      		mov r22,r16
 1541 043e C701      		movw r24,r14
 1542 0440 0E94 0000 		call action_get_macro
 1543               	.LVL184:
 1544 0444 0E94 0000 		call action_macro_play
 1545               	.LVL185:
 553:tmk_core/common/action.c **** #endif
 1546               		.loc 1 553 0
 1547 0448 00C0      		rjmp .L152
 1548               	.L72:
 557:tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 1549               		.loc 1 557 0
 1550 044a D111      		cpse r29,__zero_reg__
 1551 044c 00C0      		rjmp .L152
 558:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1552               		.loc 1 558 0
 1553 044e CF70      		andi r28,lo8(15)
 1554               	.LVL186:
 1555 0450 D0E0      		ldi r29,0
 1556               	.LVL187:
 1557 0452 C230      		cpi r28,2
 1558 0454 D105      		cpc r29,__zero_reg__
 1559 0456 01F0      		breq .L145
 1560 0458 04F4      		brge .L146
 1561 045a 2097      		sbiw r28,0
 1562 045c 01F0      		breq .L147
 1563 045e 2197      		sbiw r28,1
 1564 0460 01F4      		brne .L62
 563:tmk_core/common/action.c ****                         break;
 1565               		.loc 1 563 0
 1566 0462 0E94 0000 		call backlight_decrease
 1567               	.LVL188:
 564:tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 1568               		.loc 1 564 0
 1569 0466 00C0      		rjmp .L152
 1570               	.L146:
 558:tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 1571               		.loc 1 558 0
 1572 0468 C430      		cpi r28,4
 1573 046a D105      		cpc r29,__zero_reg__
 1574 046c 01F0      		breq .L149
 1575 046e 04F0      		brlt .L150
 1576 0470 2597      		sbiw r28,5
 1577 0472 01F4      		brne .L62
 575:tmk_core/common/action.c ****                         break;
 1578               		.loc 1 575 0
 1579 0474 80E0      		ldi r24,0
 1580 0476 00C0      		rjmp .L188
 1581               	.L147:
 560:tmk_core/common/action.c ****                         break;
 1582               		.loc 1 560 0
 1583 0478 0E94 0000 		call backlight_increase
 1584               	.LVL189:
 561:tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 1585               		.loc 1 561 0
 1586 047c 00C0      		rjmp .L152
 1587               	.L145:
 566:tmk_core/common/action.c ****                         break;
 1588               		.loc 1 566 0
 1589 047e 0E94 0000 		call backlight_toggle
 1590               	.LVL190:
 567:tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 1591               		.loc 1 567 0
 1592 0482 00C0      		rjmp .L152
 1593               	.L150:
 569:tmk_core/common/action.c ****                         break;
 1594               		.loc 1 569 0
 1595 0484 0E94 0000 		call backlight_step
 1596               	.LVL191:
 570:tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 1597               		.loc 1 570 0
 1598 0488 00C0      		rjmp .L152
 1599               	.L149:
 572:tmk_core/common/action.c ****                         break;
 1600               		.loc 1 572 0
 1601 048a 87E0      		ldi r24,lo8(7)
 1602               	.L188:
 575:tmk_core/common/action.c ****                         break;
 1603               		.loc 1 575 0
 1604 048c 0E94 0000 		call backlight_level
 1605               	.LVL192:
 576:tmk_core/common/action.c ****                 }
 1606               		.loc 1 576 0
 1607 0490 00C0      		rjmp .L152
 1608               	.LVL193:
 1609               	.L73:
 648:tmk_core/common/action.c ****             break;
 1610               		.loc 1 648 0
 1611 0492 4C2F      		mov r20,r28
 1612 0494 4F70      		andi r20,lo8(15)
 1613 0496 602F      		mov r22,r16
 1614 0498 C701      		movw r24,r14
 1615 049a 0E94 0000 		call action_function
 1616               	.LVL194:
 649:tmk_core/common/action.c **** #endif
 1617               		.loc 1 649 0
 1618 049e 00C0      		rjmp .L152
 1619               	.LVL195:
 1620               	.L62:
 657:tmk_core/common/action.c ****         case ACT_LAYER:
 1621               		.loc 1 657 0
 1622 04a0 28E0      		ldi r18,8
 1623 04a2 C21A      		sub r12,r18
 1624 04a4 D108      		sbc r13,__zero_reg__
 1625 04a6 84E0      		ldi r24,4
 1626 04a8 C816      		cp r12,r24
 1627 04aa D104      		cpc r13,__zero_reg__
 1628 04ac 00F4      		brsh .L152
 1629               	.L153:
 664:tmk_core/common/action.c ****             break;
 1630               		.loc 1 664 0
 1631 04ae 0E94 0000 		call host_keyboard_leds
 1632               	.LVL196:
 1633 04b2 0E94 0000 		call led_set
 1634               	.LVL197:
 1635               	.L152:
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1636               		.loc 1 699 0
 1637 04b6 BB20      		tst r11
 1638 04b8 01F0      		breq .L59
 699:tmk_core/common/action.c ****         record->event.pressed = false;
 1639               		.loc 1 699 0 is_stmt 0 discriminator 1
 1640 04ba 0E94 0000 		call get_oneshot_layer_state
 1641               	.LVL198:
 1642 04be 80FD      		sbrc r24,0
 1643 04c0 00C0      		rjmp .L59
 700:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1644               		.loc 1 700 0 is_stmt 1
 1645 04c2 F701      		movw r30,r14
 1646 04c4 1282      		std Z+2,__zero_reg__
 701:tmk_core/common/action.c ****         process_record(record);
 1647               		.loc 1 701 0
 1648 04c6 0E94 0000 		call get_oneshot_layer
 1649               	.LVL199:
 1650 04ca 0E94 0000 		call layer_on
 1651               	.LVL200:
 702:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1652               		.loc 1 702 0
 1653 04ce C701      		movw r24,r14
 1654 04d0 0E94 0000 		call process_record
 1655               	.LVL201:
 703:tmk_core/common/action.c ****     }
 1656               		.loc 1 703 0
 1657 04d4 0E94 0000 		call get_oneshot_layer
 1658               	.LVL202:
 1659               	/* epilogue start */
 706:tmk_core/common/action.c **** 
 1660               		.loc 1 706 0
 1661 04d8 DF91      		pop r29
 1662 04da CF91      		pop r28
 1663               	.LVL203:
 1664 04dc 1F91      		pop r17
 1665               	.LVL204:
 1666 04de 0F91      		pop r16
 1667 04e0 FF90      		pop r15
 1668 04e2 EF90      		pop r14
 1669               	.LVL205:
 1670 04e4 DF90      		pop r13
 1671 04e6 CF90      		pop r12
 1672 04e8 BF90      		pop r11
 1673               	.LVL206:
 703:tmk_core/common/action.c ****     }
 1674               		.loc 1 703 0
 1675 04ea 0C94 0000 		jmp layer_off
 1676               	.LVL207:
 1677               	.L59:
 1678               	/* epilogue start */
 706:tmk_core/common/action.c **** 
 1679               		.loc 1 706 0
 1680 04ee DF91      		pop r29
 1681 04f0 CF91      		pop r28
 1682               	.LVL208:
 1683 04f2 1F91      		pop r17
 1684               	.LVL209:
 1685 04f4 0F91      		pop r16
 1686 04f6 FF90      		pop r15
 1687 04f8 EF90      		pop r14
 1688               	.LVL210:
 1689 04fa DF90      		pop r13
 1690 04fc CF90      		pop r12
 1691 04fe BF90      		pop r11
 1692               	.LVL211:
 1693 0500 0895      		ret
 1694               		.cfi_endproc
 1695               	.LFE18:
 1697               		.section	.text.process_record,"ax",@progbits
 1698               	.global	process_record
 1700               	process_record:
 1701               	.LFB17:
 175:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1702               		.loc 1 175 0
 1703               		.cfi_startproc
 1704               	.LVL212:
 1705 0000 0F93      		push r16
 1706               	.LCFI14:
 1707               		.cfi_def_cfa_offset 3
 1708               		.cfi_offset 16, -2
 1709 0002 1F93      		push r17
 1710               	.LCFI15:
 1711               		.cfi_def_cfa_offset 4
 1712               		.cfi_offset 17, -3
 1713 0004 CF93      		push r28
 1714               	.LCFI16:
 1715               		.cfi_def_cfa_offset 5
 1716               		.cfi_offset 28, -4
 1717 0006 DF93      		push r29
 1718               	.LCFI17:
 1719               		.cfi_def_cfa_offset 6
 1720               		.cfi_offset 29, -5
 1721               	/* prologue: function */
 1722               	/* frame size = 0 */
 1723               	/* stack size = 4 */
 1724               	.L__stack_usage = 4
 1725 0008 EC01      		movw r28,r24
 1726 000a 8881      		ld r24,Y
 1727               	.LVL213:
 1728 000c 9981      		ldd r25,Y+1
 1729               	.LBB38:
 1730               	.LBB39:
 1731               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1732               		.loc 4 48 0
 1733 000e 2B81      		ldd r18,Y+3
 1734 0010 3C81      		ldd r19,Y+4
 1735 0012 232B      		or r18,r19
 1736 0014 01F0      		breq .L195
 1737 0016 9F3F      		cpi r25,lo8(-1)
 1738 0018 01F4      		brne .L197
 1739 001a 8F3F      		cpi r24,lo8(-1)
 1740 001c 01F0      		breq .L195
 1741               	.L197:
 1742               	.LBE39:
 1743               	.LBE38:
 180:tmk_core/common/action.c **** 
 1744               		.loc 1 180 0
 1745 001e CE01      		movw r24,r28
 1746 0020 0E94 0000 		call process_record_quantum
 1747               	.LVL214:
 1748 0024 8823      		tst r24
 1749 0026 01F0      		breq .L195
 182:tmk_core/common/action.c ****     dprint("ACTION: ");
 1750               		.loc 1 182 0
 1751 0028 6881      		ld r22,Y
 1752 002a 7981      		ldd r23,Y+1
 1753 002c 8A81      		ldd r24,Y+2
 1754 002e 0E94 0000 		call store_or_get_action
 1755               	.LVL215:
 1756 0032 8C01      		movw r16,r24
 1757               	.LVL216:
 187:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1758               		.loc 1 187 0
 1759 0034 0E94 0000 		call layer_debug
 1760               	.LVL217:
 189:tmk_core/common/action.c **** #endif
 1761               		.loc 1 189 0
 1762 0038 0E94 0000 		call default_layer_debug
 1763               	.LVL218:
 193:tmk_core/common/action.c **** }
 1764               		.loc 1 193 0
 1765 003c B801      		movw r22,r16
 1766 003e CE01      		movw r24,r28
 1767 0040 0E94 0000 		call process_action
 1768               	.LVL219:
 1769               	.L195:
 1770               	/* epilogue start */
 194:tmk_core/common/action.c **** 
 1771               		.loc 1 194 0
 1772 0044 DF91      		pop r29
 1773 0046 CF91      		pop r28
 1774               	.LVL220:
 1775 0048 1F91      		pop r17
 1776 004a 0F91      		pop r16
 1777               	.LVL221:
 1778 004c 0895      		ret
 1779               		.cfi_endproc
 1780               	.LFE17:
 1782               		.section	.text.process_record_nocache,"ax",@progbits
 1783               	.global	process_record_nocache
 1785               	process_record_nocache:
 1786               	.LFB14:
 137:tmk_core/common/action.c ****     disable_action_cache = true;
 1787               		.loc 1 137 0
 1788               		.cfi_startproc
 1789               	.LVL222:
 1790               	/* prologue: function */
 1791               	/* frame size = 0 */
 1792               	/* stack size = 0 */
 1793               	.L__stack_usage = 0
 138:tmk_core/common/action.c ****     process_record(record);
 1794               		.loc 1 138 0
 1795 0000 21E0      		ldi r18,lo8(1)
 1796 0002 2093 0000 		sts disable_action_cache,r18
 139:tmk_core/common/action.c ****     disable_action_cache = false;
 1797               		.loc 1 139 0
 1798 0006 0E94 0000 		call process_record
 1799               	.LVL223:
 140:tmk_core/common/action.c **** }
 1800               		.loc 1 140 0
 1801 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1802 000e 0895      		ret
 1803               		.cfi_endproc
 1804               	.LFE14:
 1806               		.section	.text.register_weak_mods,"ax",@progbits
 1807               	.global	register_weak_mods
 1809               	register_weak_mods:
 1810               	.LFB24:
 893:tmk_core/common/action.c ****     }
 894:tmk_core/common/action.c **** }
 895:tmk_core/common/action.c **** 
 896:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 897:tmk_core/common/action.c ****  *
 898:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 899:tmk_core/common/action.c ****  */
 900:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1811               		.loc 1 900 0
 1812               		.cfi_startproc
 1813               	.LVL224:
 1814               	/* prologue: function */
 1815               	/* frame size = 0 */
 1816               	/* stack size = 0 */
 1817               	.L__stack_usage = 0
 901:tmk_core/common/action.c ****     if (mods) {
 1818               		.loc 1 901 0
 1819 0000 8823      		tst r24
 1820 0002 01F0      		breq .L207
 902:tmk_core/common/action.c ****         add_weak_mods(mods);
 1821               		.loc 1 902 0
 1822 0004 0E94 0000 		call add_weak_mods
 1823               	.LVL225:
 903:tmk_core/common/action.c ****         send_keyboard_report();
 1824               		.loc 1 903 0
 1825 0008 0C94 0000 		jmp send_keyboard_report
 1826               	.LVL226:
 1827               	.L207:
 1828 000c 0895      		ret
 1829               		.cfi_endproc
 1830               	.LFE24:
 1832               		.section	.text.unregister_weak_mods,"ax",@progbits
 1833               	.global	unregister_weak_mods
 1835               	unregister_weak_mods:
 1836               	.LFB25:
 904:tmk_core/common/action.c ****     }
 905:tmk_core/common/action.c **** }
 906:tmk_core/common/action.c **** 
 907:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 908:tmk_core/common/action.c ****  *
 909:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 910:tmk_core/common/action.c ****  */
 911:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1837               		.loc 1 911 0
 1838               		.cfi_startproc
 1839               	.LVL227:
 1840               	/* prologue: function */
 1841               	/* frame size = 0 */
 1842               	/* stack size = 0 */
 1843               	.L__stack_usage = 0
 912:tmk_core/common/action.c ****     if (mods) {
 1844               		.loc 1 912 0
 1845 0000 8823      		tst r24
 1846 0002 01F0      		breq .L209
 913:tmk_core/common/action.c ****         del_weak_mods(mods);
 1847               		.loc 1 913 0
 1848 0004 0E94 0000 		call del_weak_mods
 1849               	.LVL228:
 914:tmk_core/common/action.c ****         send_keyboard_report();
 1850               		.loc 1 914 0
 1851 0008 0C94 0000 		jmp send_keyboard_report
 1852               	.LVL229:
 1853               	.L209:
 1854 000c 0895      		ret
 1855               		.cfi_endproc
 1856               	.LFE25:
 1858               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1859               	.global	clear_keyboard_but_mods_and_keys
 1861               	clear_keyboard_but_mods_and_keys:
 1862               	.LFB28:
 915:tmk_core/common/action.c ****     }
 916:tmk_core/common/action.c **** }
 917:tmk_core/common/action.c **** 
 918:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 919:tmk_core/common/action.c ****  *
 920:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 921:tmk_core/common/action.c ****  */
 922:tmk_core/common/action.c **** void clear_keyboard(void) {
 923:tmk_core/common/action.c ****     clear_mods();
 924:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 925:tmk_core/common/action.c **** }
 926:tmk_core/common/action.c **** 
 927:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 928:tmk_core/common/action.c ****  *
 929:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:tmk_core/common/action.c ****  */
 931:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 932:tmk_core/common/action.c ****     clear_keys();
 933:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 934:tmk_core/common/action.c **** }
 935:tmk_core/common/action.c **** 
 936:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 937:tmk_core/common/action.c ****  *
 938:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:tmk_core/common/action.c ****  */
 940:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1863               		.loc 1 940 0
 1864               		.cfi_startproc
 1865               	/* prologue: function */
 1866               	/* frame size = 0 */
 1867               	/* stack size = 0 */
 1868               	.L__stack_usage = 0
 941:tmk_core/common/action.c ****     clear_weak_mods();
 1869               		.loc 1 941 0
 1870 0000 0E94 0000 		call clear_weak_mods
 1871               	.LVL230:
 942:tmk_core/common/action.c ****     clear_macro_mods();
 1872               		.loc 1 942 0
 1873 0004 0E94 0000 		call clear_macro_mods
 1874               	.LVL231:
 943:tmk_core/common/action.c ****     send_keyboard_report();
 1875               		.loc 1 943 0
 1876 0008 0E94 0000 		call send_keyboard_report
 1877               	.LVL232:
 944:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 945:tmk_core/common/action.c ****     mousekey_clear();
 1878               		.loc 1 945 0
 1879 000c 0E94 0000 		call mousekey_clear
 1880               	.LVL233:
 946:tmk_core/common/action.c ****     mousekey_send();
 1881               		.loc 1 946 0
 1882 0010 0E94 0000 		call mousekey_send
 1883               	.LVL234:
 947:tmk_core/common/action.c **** #endif
 948:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 949:tmk_core/common/action.c ****     host_system_send(0);
 1884               		.loc 1 949 0
 1885 0014 80E0      		ldi r24,0
 1886 0016 90E0      		ldi r25,0
 1887 0018 0E94 0000 		call host_system_send
 1888               	.LVL235:
 950:tmk_core/common/action.c ****     host_consumer_send(0);
 1889               		.loc 1 950 0
 1890 001c 80E0      		ldi r24,0
 1891 001e 90E0      		ldi r25,0
 1892 0020 0C94 0000 		jmp host_consumer_send
 1893               	.LVL236:
 1894               		.cfi_endproc
 1895               	.LFE28:
 1897               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1898               	.global	clear_keyboard_but_mods
 1900               	clear_keyboard_but_mods:
 1901               	.LFB27:
 931:tmk_core/common/action.c ****     clear_keys();
 1902               		.loc 1 931 0
 1903               		.cfi_startproc
 1904               	/* prologue: function */
 1905               	/* frame size = 0 */
 1906               	/* stack size = 0 */
 1907               	.L__stack_usage = 0
 1908               	.LBB40:
 1909               	.LBB41:
  35:tmk_core/common/action_util.h **** 
  36:tmk_core/common/action_util.h **** inline void clear_keys(void) { clear_keys_from_report(keyboard_report); }
 1910               		.loc 2 36 0
 1911 0000 8091 0000 		lds r24,keyboard_report
 1912 0004 9091 0000 		lds r25,keyboard_report+1
 1913 0008 0E94 0000 		call clear_keys_from_report
 1914               	.LVL237:
 1915               	.LBE41:
 1916               	.LBE40:
 933:tmk_core/common/action.c **** }
 1917               		.loc 1 933 0
 1918 000c 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1919               	.LVL238:
 1920               		.cfi_endproc
 1921               	.LFE27:
 1923               		.section	.text.clear_keyboard,"ax",@progbits
 1924               	.global	clear_keyboard
 1926               	clear_keyboard:
 1927               	.LFB26:
 922:tmk_core/common/action.c ****     clear_mods();
 1928               		.loc 1 922 0
 1929               		.cfi_startproc
 1930               	/* prologue: function */
 1931               	/* frame size = 0 */
 1932               	/* stack size = 0 */
 1933               	.L__stack_usage = 0
 923:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1934               		.loc 1 923 0
 1935 0000 0E94 0000 		call clear_mods
 1936               	.LVL239:
 924:tmk_core/common/action.c **** }
 1937               		.loc 1 924 0
 1938 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1939               	.LVL240:
 1940               		.cfi_endproc
 1941               	.LFE26:
 1943               		.section	.text.is_tap_action,"ax",@progbits
 1944               	.global	is_tap_action
 1946               	is_tap_action:
 1947               	.LFB30:
 951:tmk_core/common/action.c **** #endif
 952:tmk_core/common/action.c **** }
 953:tmk_core/common/action.c **** 
 954:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 955:tmk_core/common/action.c ****  *
 956:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 957:tmk_core/common/action.c ****  */
 958:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 959:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 960:tmk_core/common/action.c ****     return is_tap_action(action);
 961:tmk_core/common/action.c **** }
 962:tmk_core/common/action.c **** 
 963:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 964:tmk_core/common/action.c ****  *
 965:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 966:tmk_core/common/action.c ****  */
 967:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 1948               		.loc 1 967 0
 1949               		.cfi_startproc
 1950               	.LVL241:
 1951               	/* prologue: function */
 1952               	/* frame size = 0 */
 1953               	/* stack size = 0 */
 1954               	.L__stack_usage = 0
 968:tmk_core/common/action.c ****     switch (action.kind.id) {
 1955               		.loc 1 968 0
 1956 0000 E92F      		mov r30,r25
 1957 0002 E295      		swap r30
 1958 0004 EF70      		andi r30,lo8(15)
 1959 0006 F0E0      		ldi r31,0
 1960 0008 3297      		sbiw r30,2
 1961 000a EE30      		cpi r30,14
 1962 000c F105      		cpc r31,__zero_reg__
 1963 000e 00F4      		brsh .L223
 1964 0010 E050      		subi r30,lo8(-(gs(.L217)))
 1965 0012 F040      		sbci r31,hi8(-(gs(.L217)))
 1966 0014 0C94 0000 		jmp __tablejump2__
 1967               		.section	.progmem.gcc_sw_table.is_tap_action,"a",@progbits
 1968               		.p2align	1
 1969               	.L217:
 1970 0000 0000      		.word gs(.L216)
 1971 0002 0000      		.word gs(.L216)
 1972 0004 0000      		.word gs(.L223)
 1973 0006 0000      		.word gs(.L223)
 1974 0008 0000      		.word gs(.L218)
 1975 000a 0000      		.word gs(.L223)
 1976 000c 0000      		.word gs(.L223)
 1977 000e 0000      		.word gs(.L223)
 1978 0010 0000      		.word gs(.L216)
 1979 0012 0000      		.word gs(.L216)
 1980 0014 0000      		.word gs(.L219)
 1981 0016 0000      		.word gs(.L223)
 1982 0018 0000      		.word gs(.L223)
 1983 001a 0000      		.word gs(.L219)
 1984               		.section	.text.is_tap_action
 1985               	.L216:
 969:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 970:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 971:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 972:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 973:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1986               		.loc 1 973 0
 1987 0018 803F      		cpi r24,lo8(-16)
 1988 001a 01F0      		breq .L225
 1989 001c 00F4      		brsh .L221
 1990 001e 883E      		cpi r24,lo8(-24)
 1991 0020 00F4      		brsh .L223
 1992 0022 00C0      		rjmp .L225
 1993               	.L221:
 1994 0024 843F      		cpi r24,lo8(-12)
 1995 0026 01F4      		brne .L223
 1996 0028 00C0      		rjmp .L225
 1997               	.L218:
 974:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 975:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 976:tmk_core/common/action.c ****                 case OP_ONESHOT:
 977:tmk_core/common/action.c ****                     return true;
 978:tmk_core/common/action.c ****             }
 979:tmk_core/common/action.c ****             return false;
 980:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 981:tmk_core/common/action.c ****             switch (action.swap.code) {
 1998               		.loc 1 981 0
 1999 002a 883E      		cpi r24,lo8(-24)
 2000 002c 00F0      		brlo .L225
 2001 002e 813F      		cpi r24,lo8(-15)
 2002 0030 01F4      		brne .L223
 2003 0032 00C0      		rjmp .L225
 2004               	.L219:
 982:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 983:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 984:tmk_core/common/action.c ****                     return true;
 985:tmk_core/common/action.c ****             }
 986:tmk_core/common/action.c ****             return false;
 987:tmk_core/common/action.c ****         case ACT_MACRO:
 988:tmk_core/common/action.c ****         case ACT_FUNCTION:
 989:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
 2005               		.loc 1 989 0
 2006 0034 93FB      		bst r25,3
 2007 0036 8827      		clr r24
 2008 0038 80F9      		bld r24,0
 2009               	.LVL242:
 2010 003a 0895      		ret
 2011               	.LVL243:
 2012               	.L223:
 990:tmk_core/common/action.c ****                 return true;
 991:tmk_core/common/action.c ****             }
 992:tmk_core/common/action.c ****             return false;
 993:tmk_core/common/action.c ****     }
 994:tmk_core/common/action.c ****     return false;
 2013               		.loc 1 994 0
 2014 003c 80E0      		ldi r24,0
 2015               	.LVL244:
 2016 003e 0895      		ret
 2017               	.LVL245:
 2018               	.L225:
 984:tmk_core/common/action.c ****             }
 2019               		.loc 1 984 0
 2020 0040 81E0      		ldi r24,lo8(1)
 2021               	.LVL246:
 995:tmk_core/common/action.c **** }
 2022               		.loc 1 995 0
 2023 0042 0895      		ret
 2024               		.cfi_endproc
 2025               	.LFE30:
 2027               		.section	.text.is_tap_key,"ax",@progbits
 2028               	.global	is_tap_key
 2030               	is_tap_key:
 2031               	.LFB29:
 958:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2032               		.loc 1 958 0
 2033               		.cfi_startproc
 2034               	.LVL247:
 2035               	/* prologue: function */
 2036               	/* frame size = 0 */
 2037               	/* stack size = 0 */
 2038               	.L__stack_usage = 0
 959:tmk_core/common/action.c ****     return is_tap_action(action);
 2039               		.loc 1 959 0
 2040 0000 0E94 0000 		call layer_switch_get_action
 2041               	.LVL248:
 960:tmk_core/common/action.c **** }
 2042               		.loc 1 960 0
 2043 0004 0E94 0000 		call is_tap_action
 2044               	.LVL249:
 961:tmk_core/common/action.c **** 
 2045               		.loc 1 961 0
 2046 0008 0895      		ret
 2047               		.cfi_endproc
 2048               	.LFE29:
 2050               		.section	.text.debug_event,"ax",@progbits
 2051               	.global	debug_event
 2053               	debug_event:
 2054               	.LFB31:
 996:tmk_core/common/action.c **** 
 997:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 998:tmk_core/common/action.c ****  *
 999:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1000:tmk_core/common/action.c ****  */
1001:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2055               		.loc 1 1001 0
 2056               		.cfi_startproc
 2057 0000 CF93      		push r28
 2058               	.LCFI18:
 2059               		.cfi_def_cfa_offset 3
 2060               		.cfi_offset 28, -2
 2061 0002 DF93      		push r29
 2062               	.LCFI19:
 2063               		.cfi_def_cfa_offset 4
 2064               		.cfi_offset 29, -3
 2065 0004 00D0      		rcall .
 2066 0006 00D0      		rcall .
 2067 0008 1F92      		push __zero_reg__
 2068               	.LCFI20:
 2069               		.cfi_def_cfa_offset 9
 2070 000a CDB7      		in r28,__SP_L__
 2071 000c DEB7      		in r29,__SP_H__
 2072               	.LCFI21:
 2073               		.cfi_def_cfa_register 28
 2074               	/* prologue: function */
 2075               	/* frame size = 5 */
 2076               	/* stack size = 7 */
 2077               	.L__stack_usage = 7
 2078               	/* epilogue start */
 2079               		.loc 1 1001 0
 2080 000e 0F90      		pop __tmp_reg__
 2081 0010 0F90      		pop __tmp_reg__
 2082 0012 0F90      		pop __tmp_reg__
 2083 0014 0F90      		pop __tmp_reg__
 2084 0016 0F90      		pop __tmp_reg__
 2085 0018 DF91      		pop r29
 2086 001a CF91      		pop r28
 2087 001c 0895      		ret
 2088               		.cfi_endproc
 2089               	.LFE31:
 2091               		.section	.text.debug_record,"ax",@progbits
 2092               	.global	debug_record
 2094               	debug_record:
 2095               	.LFB32:
1002:tmk_core/common/action.c **** 
1003:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1004:tmk_core/common/action.c ****  *
1005:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1006:tmk_core/common/action.c ****  */
1007:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2096               		.loc 1 1007 0
 2097               		.cfi_startproc
 2098 0000 CF93      		push r28
 2099               	.LCFI22:
 2100               		.cfi_def_cfa_offset 3
 2101               		.cfi_offset 28, -2
 2102 0002 DF93      		push r29
 2103               	.LCFI23:
 2104               		.cfi_def_cfa_offset 4
 2105               		.cfi_offset 29, -3
 2106 0004 00D0      		rcall .
 2107 0006 00D0      		rcall .
 2108 0008 00D0      		rcall .
 2109               	.LCFI24:
 2110               		.cfi_def_cfa_offset 10
 2111 000a CDB7      		in r28,__SP_L__
 2112 000c DEB7      		in r29,__SP_H__
 2113               	.LCFI25:
 2114               		.cfi_def_cfa_register 28
 2115               	/* prologue: function */
 2116               	/* frame size = 6 */
 2117               	/* stack size = 8 */
 2118               	.L__stack_usage = 8
 2119               	/* epilogue start */
1008:tmk_core/common/action.c ****     debug_event(record.event);
1009:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1010:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
1011:tmk_core/common/action.c **** #endif
1012:tmk_core/common/action.c **** }
 2120               		.loc 1 1012 0
 2121 000e 2696      		adiw r28,6
 2122 0010 0FB6      		in __tmp_reg__,__SREG__
 2123 0012 F894      		cli
 2124 0014 DEBF      		out __SP_H__,r29
 2125 0016 0FBE      		out __SREG__,__tmp_reg__
 2126 0018 CDBF      		out __SP_L__,r28
 2127 001a DF91      		pop r29
 2128 001c CF91      		pop r28
 2129 001e 0895      		ret
 2130               		.cfi_endproc
 2131               	.LFE32:
 2133               		.section	.text.debug_action,"ax",@progbits
 2134               	.global	debug_action
 2136               	debug_action:
 2137               	.LFB33:
1013:tmk_core/common/action.c **** 
1014:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1015:tmk_core/common/action.c ****  *
1016:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1017:tmk_core/common/action.c ****  */
1018:tmk_core/common/action.c **** void debug_action(action_t action) {
 2138               		.loc 1 1018 0
 2139               		.cfi_startproc
 2140               	.LVL250:
 2141               	/* prologue: function */
 2142               	/* frame size = 0 */
 2143               	/* stack size = 0 */
 2144               	.L__stack_usage = 0
 2145 0000 0895      		ret
 2146               		.cfi_endproc
 2147               	.LFE33:
 2149               	.global	disable_action_cache
 2150               		.section	.bss.disable_action_cache,"aw",@nobits
 2153               	disable_action_cache:
 2154 0000 00        		.zero	1
 2155               		.comm	tp_buttons,2,1
 2156               		.text
 2157               	.Letext0:
 2158               		.file 5 "/usr/lib/avr/include/stdint.h"
 2159               		.file 6 "tmk_core/common/keycode.h"
 2160               		.file 7 "tmk_core/common/report.h"
 2161               		.file 8 "tmk_core/common/action_code.h"
 2162               		.file 9 "tmk_core/common/action_macro.h"
 2163               		.file 10 "tmk_core/common/action.h"
 2164               		.file 11 "tmk_core/common/action_layer.h"
 2165               		.file 12 "tmk_core/common/action_tapping.h"
 2166               		.file 13 "tmk_core/common/host.h"
 2167               		.file 14 "tmk_core/common/mousekey.h"
 2168               		.file 15 "quantum/backlight/backlight.h"
 2169               		.file 16 "tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccC5sldN.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccC5sldN.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccC5sldN.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccC5sldN.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccC5sldN.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccC5sldN.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/ccC5sldN.s:93     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccC5sldN.s:112    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccC5sldN.s:135    .text.register_code:0000000000000000 register_code
     /tmp/ccC5sldN.s:486    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccC5sldN.s:582    .text.tap_code:0000000000000000 tap_code
     /tmp/ccC5sldN.s:635    .text.register_mods:0000000000000000 register_mods
     /tmp/ccC5sldN.s:661    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccC5sldN.s:687    .text.process_action:0000000000000000 process_action
                            *COM*:0000000000000002 tp_buttons
     /tmp/ccC5sldN.s:1700   .text.process_record:0000000000000000 process_record
     /tmp/ccC5sldN.s:1785   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccC5sldN.s:2153   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccC5sldN.s:1809   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccC5sldN.s:1835   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccC5sldN.s:1861   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccC5sldN.s:1900   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccC5sldN.s:1926   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccC5sldN.s:1946   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccC5sldN.s:2030   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccC5sldN.s:2053   .text.debug_event:0000000000000000 debug_event
     /tmp/ccC5sldN.s:2094   .text.debug_record:0000000000000000 debug_record
     /tmp/ccC5sldN.s:2136   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
keyboard_report
add_key_to_report
add_mods
send_keyboard_report
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_key_from_report
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
backlight_decrease
backlight_increase
backlight_toggle
backlight_step
backlight_level
action_function
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys_from_report
clear_mods
__do_clear_bss
