   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB30:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** 
  19:quantum/quantum.c **** #if !defined(RGBLIGHT_ENABLE) && !defined(RGB_MATRIX_ENABLE)
  20:quantum/quantum.c **** #    include "rgb.h"
  21:quantum/quantum.c **** #endif
  22:quantum/quantum.c **** 
  23:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  24:quantum/quantum.c **** #    include "outputselect.h"
  25:quantum/quantum.c **** #endif
  26:quantum/quantum.c **** 
  27:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
  28:quantum/quantum.c **** #    include "backlight.h"
  29:quantum/quantum.c ****     extern backlight_config_t backlight_config;
  30:quantum/quantum.c **** #endif
  31:quantum/quantum.c **** 
  32:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  33:quantum/quantum.c **** #    include "fauxclicky.h"
  34:quantum/quantum.c **** #endif
  35:quantum/quantum.c **** 
  36:quantum/quantum.c **** #ifdef API_ENABLE
  37:quantum/quantum.c **** #    include "api.h"
  38:quantum/quantum.c **** #endif
  39:quantum/quantum.c **** 
  40:quantum/quantum.c **** #ifdef MIDI_ENABLE
  41:quantum/quantum.c **** #    include "process_midi.h"
  42:quantum/quantum.c **** #endif
  43:quantum/quantum.c **** 
  44:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  45:quantum/quantum.c **** #    include "velocikey.h"
  46:quantum/quantum.c **** #endif
  47:quantum/quantum.c **** 
  48:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  49:quantum/quantum.c **** #    include "haptic.h"
  50:quantum/quantum.c **** #endif
  51:quantum/quantum.c **** 
  52:quantum/quantum.c **** #ifdef ENCODER_ENABLE
  53:quantum/quantum.c **** #    include "encoder.h"
  54:quantum/quantum.c **** #endif
  55:quantum/quantum.c **** 
  56:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  57:quantum/quantum.c **** #    ifndef GOODBYE_SONG
  58:quantum/quantum.c **** #        define GOODBYE_SONG SONG(GOODBYE_SOUND)
  59:quantum/quantum.c **** #    endif
  60:quantum/quantum.c **** #    ifndef AG_NORM_SONG
  61:quantum/quantum.c **** #        define AG_NORM_SONG SONG(AG_NORM_SOUND)
  62:quantum/quantum.c **** #    endif
  63:quantum/quantum.c **** #    ifndef AG_SWAP_SONG
  64:quantum/quantum.c **** #        define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  65:quantum/quantum.c **** #    endif
  66:quantum/quantum.c **** #    ifndef CG_NORM_SONG
  67:quantum/quantum.c **** #        define CG_NORM_SONG SONG(AG_NORM_SOUND)
  68:quantum/quantum.c **** #    endif
  69:quantum/quantum.c **** #    ifndef CG_SWAP_SONG
  70:quantum/quantum.c **** #        define CG_SWAP_SONG SONG(AG_SWAP_SOUND)
  71:quantum/quantum.c **** #    endif
  72:quantum/quantum.c **** float goodbye_song[][2] = GOODBYE_SONG;
  73:quantum/quantum.c **** float ag_norm_song[][2] = AG_NORM_SONG;
  74:quantum/quantum.c **** float ag_swap_song[][2] = AG_SWAP_SONG;
  75:quantum/quantum.c **** float cg_norm_song[][2] = CG_NORM_SONG;
  76:quantum/quantum.c **** float cg_swap_song[][2] = CG_SWAP_SONG;
  77:quantum/quantum.c **** #    ifdef DEFAULT_LAYER_SONGS
  78:quantum/quantum.c **** float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  79:quantum/quantum.c **** #    endif
  80:quantum/quantum.c **** #endif
  81:quantum/quantum.c **** 
  82:quantum/quantum.c **** static void do_code16(uint16_t code, void (*f)(uint8_t)) {
  15               		.loc 1 82 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  83:quantum/quantum.c ****     switch (code) {
  22               		.loc 1 83 0
  23 0000 9C01      		movw r18,r24
  24 0002 3A95      		dec r19
  25 0004 2115      		cp r18,__zero_reg__
  26 0006 3F41      		sbci r19,31
  27 0008 00F4      		brsh .L1
  28               	.LVL1:
  29 000a DC01      		movw r26,r24
  30 000c AA27      		clr r26
  31 000e B270      		andi r27,2
  32 0010 AC01      		movw r20,r24
  33 0012 4427      		clr r20
  34 0014 5470      		andi r21,4
  35 0016 9C01      		movw r18,r24
  36 0018 2227      		clr r18
  37 001a 3870      		andi r19,8
  84:quantum/quantum.c ****         case QK_MODS ... QK_MODS_MAX:
  85:quantum/quantum.c ****             break;
  86:quantum/quantum.c ****         default:
  87:quantum/quantum.c ****             return;
  88:quantum/quantum.c ****     }
  89:quantum/quantum.c **** 
  90:quantum/quantum.c ****     uint8_t mods_to_send = 0;
  91:quantum/quantum.c **** 
  92:quantum/quantum.c ****     if (code & QK_RMODS_MIN) { // Right mod flag is set
  38               		.loc 1 92 0
  39 001c 94FF      		sbrs r25,4
  40 001e 00C0      		rjmp .L4
  93:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  41               		.loc 1 93 0
  42 0020 90FF      		sbrs r25,0
  43 0022 00C0      		rjmp .L11
  44 0024 80E1      		ldi r24,lo8(16)
  45               	.LVL2:
  46 0026 00C0      		rjmp .L5
  47               	.LVL3:
  48               	.L11:
  90:quantum/quantum.c **** 
  49               		.loc 1 90 0
  50 0028 80E0      		ldi r24,0
  51               	.LVL4:
  52               	.L5:
  94:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_RSFT);
  53               		.loc 1 94 0
  54 002a AB2B      		or r26,r27
  55 002c 01F0      		breq .L6
  56               		.loc 1 94 0 is_stmt 0 discriminator 1
  57 002e 8062      		ori r24,lo8(32)
  58               	.LVL5:
  59               	.L6:
  95:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_RALT);
  60               		.loc 1 95 0 is_stmt 1
  61 0030 452B      		or r20,r21
  62 0032 01F0      		breq .L7
  63               		.loc 1 95 0 is_stmt 0 discriminator 1
  64 0034 8064      		ori r24,lo8(64)
  65               	.LVL6:
  66               	.L7:
  96:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_RGUI);
  67               		.loc 1 96 0 is_stmt 1
  68 0036 232B      		or r18,r19
  69 0038 01F0      		breq .L8
  70               		.loc 1 96 0 is_stmt 0 discriminator 1
  71 003a 8068      		ori r24,lo8(-128)
  72               	.LVL7:
  73 003c 00C0      		rjmp .L8
  74               	.LVL8:
  75               	.L4:
  97:quantum/quantum.c ****     } else {
  98:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_LCTL);
  76               		.loc 1 98 0 is_stmt 1
  77 003e 892F      		mov r24,r25
  78               	.LVL9:
  79 0040 8170      		andi r24,lo8(1)
  80               	.LVL10:
  99:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
  81               		.loc 1 99 0
  82 0042 AB2B      		or r26,r27
  83 0044 01F0      		breq .L9
  84               		.loc 1 99 0 is_stmt 0 discriminator 1
  85 0046 8260      		ori r24,lo8(2)
  86               	.LVL11:
  87               	.L9:
 100:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
  88               		.loc 1 100 0 is_stmt 1
  89 0048 452B      		or r20,r21
  90 004a 01F0      		breq .L10
  91               		.loc 1 100 0 is_stmt 0 discriminator 1
  92 004c 8460      		ori r24,lo8(4)
  93               	.LVL12:
  94               	.L10:
 101:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
  95               		.loc 1 101 0 is_stmt 1
  96 004e 232B      		or r18,r19
  97 0050 01F0      		breq .L8
  98               		.loc 1 101 0 is_stmt 0 discriminator 1
  99 0052 8860      		ori r24,lo8(8)
 100               	.LVL13:
 101               	.L8:
 102:quantum/quantum.c ****     }
 103:quantum/quantum.c **** 
 104:quantum/quantum.c ****     f(mods_to_send);
 102               		.loc 1 104 0 is_stmt 1
 103 0054 FB01      		movw r30,r22
 104 0056 0994      		ijmp
 105               	.LVL14:
 106               	.L1:
 107 0058 0895      		ret
 108               		.cfi_endproc
 109               	.LFE30:
 111               		.section	.text.rgblight_toggle,"ax",@progbits
 112               		.weak	rgblight_toggle
 114               	rgblight_toggle:
 115               	.LFB19:
 116               		.file 2 "quantum/rgb.h"
   1:quantum/rgb.h **** /* Copyright 2017 Jack Humbert
   2:quantum/rgb.h ****  *
   3:quantum/rgb.h ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/rgb.h ****  * it under the terms of the GNU General Public License as published by
   5:quantum/rgb.h ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/rgb.h ****  * (at your option) any later version.
   7:quantum/rgb.h ****  *
   8:quantum/rgb.h ****  * This program is distributed in the hope that it will be useful,
   9:quantum/rgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/rgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/rgb.h ****  * GNU General Public License for more details.
  12:quantum/rgb.h ****  *
  13:quantum/rgb.h ****  * You should have received a copy of the GNU General Public License
  14:quantum/rgb.h ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/rgb.h ****  */
  16:quantum/rgb.h **** 
  17:quantum/rgb.h **** #ifndef RGB_H
  18:quantum/rgb.h **** #define RGB_H
  19:quantum/rgb.h **** 
  20:quantum/rgb.h **** __attribute__((weak)) void rgblight_toggle(void){};
 117               		.loc 2 20 0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 123 0000 0895      		ret
 124               		.cfi_endproc
 125               	.LFE19:
 127               		.section	.text.rgblight_step,"ax",@progbits
 128               		.weak	rgblight_step
 130               	rgblight_step:
 131               	.LFB20:
  21:quantum/rgb.h **** 
  22:quantum/rgb.h **** __attribute__((weak)) void rgblight_step(void){};
 132               		.loc 2 22 0
 133               		.cfi_startproc
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 138 0000 0895      		ret
 139               		.cfi_endproc
 140               	.LFE20:
 142               		.section	.text.rgblight_step_reverse,"ax",@progbits
 143               		.weak	rgblight_step_reverse
 145               	rgblight_step_reverse:
 146               	.LFB21:
  23:quantum/rgb.h **** 
  24:quantum/rgb.h **** __attribute__((weak)) void rgblight_step_reverse(void){};
 147               		.loc 2 24 0
 148               		.cfi_startproc
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151               	/* stack size = 0 */
 152               	.L__stack_usage = 0
 153 0000 0895      		ret
 154               		.cfi_endproc
 155               	.LFE21:
 157               		.section	.text.rgblight_increase_hue,"ax",@progbits
 158               		.weak	rgblight_increase_hue
 160               	rgblight_increase_hue:
 161               	.LFB22:
  25:quantum/rgb.h **** 
  26:quantum/rgb.h **** __attribute__((weak)) void rgblight_increase_hue(void){};
 162               		.loc 2 26 0
 163               		.cfi_startproc
 164               	/* prologue: function */
 165               	/* frame size = 0 */
 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 168 0000 0895      		ret
 169               		.cfi_endproc
 170               	.LFE22:
 172               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 173               		.weak	rgblight_decrease_hue
 175               	rgblight_decrease_hue:
 176               	.LFB23:
  27:quantum/rgb.h **** 
  28:quantum/rgb.h **** __attribute__((weak)) void rgblight_decrease_hue(void){};
 177               		.loc 2 28 0
 178               		.cfi_startproc
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 0 */
 182               	.L__stack_usage = 0
 183 0000 0895      		ret
 184               		.cfi_endproc
 185               	.LFE23:
 187               		.section	.text.rgblight_increase_sat,"ax",@progbits
 188               		.weak	rgblight_increase_sat
 190               	rgblight_increase_sat:
 191               	.LFB24:
  29:quantum/rgb.h **** 
  30:quantum/rgb.h **** __attribute__((weak)) void rgblight_increase_sat(void){};
 192               		.loc 2 30 0
 193               		.cfi_startproc
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 198 0000 0895      		ret
 199               		.cfi_endproc
 200               	.LFE24:
 202               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 203               		.weak	rgblight_decrease_sat
 205               	rgblight_decrease_sat:
 206               	.LFB25:
  31:quantum/rgb.h **** 
  32:quantum/rgb.h **** __attribute__((weak)) void rgblight_decrease_sat(void){};
 207               		.loc 2 32 0
 208               		.cfi_startproc
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
 213 0000 0895      		ret
 214               		.cfi_endproc
 215               	.LFE25:
 217               		.section	.text.rgblight_increase_val,"ax",@progbits
 218               		.weak	rgblight_increase_val
 220               	rgblight_increase_val:
 221               	.LFB26:
  33:quantum/rgb.h **** 
  34:quantum/rgb.h **** __attribute__((weak)) void rgblight_increase_val(void){};
 222               		.loc 2 34 0
 223               		.cfi_startproc
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 228 0000 0895      		ret
 229               		.cfi_endproc
 230               	.LFE26:
 232               		.section	.text.rgblight_decrease_val,"ax",@progbits
 233               		.weak	rgblight_decrease_val
 235               	rgblight_decrease_val:
 236               	.LFB27:
  35:quantum/rgb.h **** 
  36:quantum/rgb.h **** __attribute__((weak)) void rgblight_decrease_val(void){};
 237               		.loc 2 36 0
 238               		.cfi_startproc
 239               	/* prologue: function */
 240               	/* frame size = 0 */
 241               	/* stack size = 0 */
 242               	.L__stack_usage = 0
 243 0000 0895      		ret
 244               		.cfi_endproc
 245               	.LFE27:
 247               		.section	.text.rgblight_increase_speed,"ax",@progbits
 248               		.weak	rgblight_increase_speed
 250               	rgblight_increase_speed:
 251               	.LFB28:
  37:quantum/rgb.h **** 
  38:quantum/rgb.h **** __attribute__((weak)) void rgblight_increase_speed(void){};
 252               		.loc 2 38 0
 253               		.cfi_startproc
 254               	/* prologue: function */
 255               	/* frame size = 0 */
 256               	/* stack size = 0 */
 257               	.L__stack_usage = 0
 258 0000 0895      		ret
 259               		.cfi_endproc
 260               	.LFE28:
 262               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 263               		.weak	rgblight_decrease_speed
 265               	rgblight_decrease_speed:
 266               	.LFB29:
  39:quantum/rgb.h **** 
  40:quantum/rgb.h **** __attribute__((weak)) void rgblight_decrease_speed(void){};
 267               		.loc 2 40 0
 268               		.cfi_startproc
 269               	/* prologue: function */
 270               	/* frame size = 0 */
 271               	/* stack size = 0 */
 272               	.L__stack_usage = 0
 273 0000 0895      		ret
 274               		.cfi_endproc
 275               	.LFE29:
 277               		.section	.text.register_code16,"ax",@progbits
 278               	.global	register_code16
 280               	register_code16:
 281               	.LFB31:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** void register_code16(uint16_t code) {
 282               		.loc 1 107 0
 283               		.cfi_startproc
 284               	.LVL15:
 285               		.loc 1 107 0
 286 0000 CF93      		push r28
 287               	.LCFI0:
 288               		.cfi_def_cfa_offset 3
 289               		.cfi_offset 28, -2
 290 0002 DF93      		push r29
 291               	.LCFI1:
 292               		.cfi_def_cfa_offset 4
 293               		.cfi_offset 29, -3
 294               	/* prologue: function */
 295               	/* frame size = 0 */
 296               	/* stack size = 2 */
 297               	.L__stack_usage = 2
 298 0004 EC01      		movw r28,r24
 108:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 299               		.loc 1 108 0
 300 0006 805E      		subi r24,-32
 301 0008 9109      		sbc r25,__zero_reg__
 302               	.LVL16:
 303 000a 0897      		sbiw r24,8
 304 000c 00F0      		brlo .L43
 305               		.loc 1 108 0 is_stmt 0 discriminator 1
 306 000e 2097      		sbiw r28,0
 307 0010 01F4      		brne .L44
 308               	.L43:
 109:quantum/quantum.c ****         do_code16(code, register_mods);
 309               		.loc 1 109 0 is_stmt 1
 310 0012 60E0      		ldi r22,lo8(gs(register_mods))
 311 0014 70E0      		ldi r23,hi8(gs(register_mods))
 312 0016 00C0      		rjmp .L46
 313               	.L44:
 110:quantum/quantum.c ****     } else {
 111:quantum/quantum.c ****         do_code16(code, register_weak_mods);
 314               		.loc 1 111 0
 315 0018 60E0      		ldi r22,lo8(gs(register_weak_mods))
 316 001a 70E0      		ldi r23,hi8(gs(register_weak_mods))
 317               	.L46:
 318 001c CE01      		movw r24,r28
 319 001e 0E94 0000 		call do_code16
 320               	.LVL17:
 112:quantum/quantum.c ****     }
 113:quantum/quantum.c ****     register_code(code);
 321               		.loc 1 113 0
 322 0022 8C2F      		mov r24,r28
 323               	/* epilogue start */
 114:quantum/quantum.c **** }
 324               		.loc 1 114 0
 325 0024 DF91      		pop r29
 326 0026 CF91      		pop r28
 327               	.LVL18:
 113:quantum/quantum.c **** }
 328               		.loc 1 113 0
 329 0028 0C94 0000 		jmp register_code
 330               	.LVL19:
 331               		.cfi_endproc
 332               	.LFE31:
 334               		.section	.text.unregister_code16,"ax",@progbits
 335               	.global	unregister_code16
 337               	unregister_code16:
 338               	.LFB32:
 115:quantum/quantum.c **** 
 116:quantum/quantum.c **** void unregister_code16(uint16_t code) {
 339               		.loc 1 116 0
 340               		.cfi_startproc
 341               	.LVL20:
 342 0000 CF93      		push r28
 343               	.LCFI2:
 344               		.cfi_def_cfa_offset 3
 345               		.cfi_offset 28, -2
 346 0002 DF93      		push r29
 347               	.LCFI3:
 348               		.cfi_def_cfa_offset 4
 349               		.cfi_offset 29, -3
 350               	/* prologue: function */
 351               	/* frame size = 0 */
 352               	/* stack size = 2 */
 353               	.L__stack_usage = 2
 354 0004 EC01      		movw r28,r24
 117:quantum/quantum.c ****     unregister_code(code);
 355               		.loc 1 117 0
 356 0006 0E94 0000 		call unregister_code
 357               	.LVL21:
 118:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 358               		.loc 1 118 0
 359 000a CE01      		movw r24,r28
 360 000c 805E      		subi r24,-32
 361 000e 9109      		sbc r25,__zero_reg__
 362 0010 0897      		sbiw r24,8
 363 0012 00F0      		brlo .L48
 364               		.loc 1 118 0 is_stmt 0 discriminator 1
 365 0014 2097      		sbiw r28,0
 366 0016 01F4      		brne .L49
 367               	.L48:
 119:quantum/quantum.c ****         do_code16(code, unregister_mods);
 368               		.loc 1 119 0 is_stmt 1
 369 0018 60E0      		ldi r22,lo8(gs(unregister_mods))
 370 001a 70E0      		ldi r23,hi8(gs(unregister_mods))
 371 001c 00C0      		rjmp .L50
 372               	.L49:
 120:quantum/quantum.c ****     } else {
 121:quantum/quantum.c ****         do_code16(code, unregister_weak_mods);
 373               		.loc 1 121 0
 374 001e 60E0      		ldi r22,lo8(gs(unregister_weak_mods))
 375 0020 70E0      		ldi r23,hi8(gs(unregister_weak_mods))
 376               	.L50:
 377 0022 CE01      		movw r24,r28
 378               	/* epilogue start */
 122:quantum/quantum.c ****     }
 123:quantum/quantum.c **** }
 379               		.loc 1 123 0
 380 0024 DF91      		pop r29
 381 0026 CF91      		pop r28
 382               	.LVL22:
 121:quantum/quantum.c ****     }
 383               		.loc 1 121 0
 384 0028 0C94 0000 		jmp do_code16
 385               	.LVL23:
 386               		.cfi_endproc
 387               	.LFE32:
 389               		.section	.text.tap_code16,"ax",@progbits
 390               	.global	tap_code16
 392               	tap_code16:
 393               	.LFB33:
 124:quantum/quantum.c **** 
 125:quantum/quantum.c **** void tap_code16(uint16_t code) {
 394               		.loc 1 125 0
 395               		.cfi_startproc
 396               	.LVL24:
 397 0000 CF93      		push r28
 398               	.LCFI4:
 399               		.cfi_def_cfa_offset 3
 400               		.cfi_offset 28, -2
 401 0002 DF93      		push r29
 402               	.LCFI5:
 403               		.cfi_def_cfa_offset 4
 404               		.cfi_offset 29, -3
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 2 */
 408               	.L__stack_usage = 2
 409 0004 EC01      		movw r28,r24
 126:quantum/quantum.c ****     register_code16(code);
 410               		.loc 1 126 0
 411 0006 0E94 0000 		call register_code16
 412               	.LVL25:
 127:quantum/quantum.c **** #if TAP_CODE_DELAY > 0
 128:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 129:quantum/quantum.c **** #endif
 130:quantum/quantum.c ****     unregister_code16(code);
 413               		.loc 1 130 0
 414 000a CE01      		movw r24,r28
 415               	/* epilogue start */
 131:quantum/quantum.c **** }
 416               		.loc 1 131 0
 417 000c DF91      		pop r29
 418 000e CF91      		pop r28
 419               	.LVL26:
 130:quantum/quantum.c **** }
 420               		.loc 1 130 0
 421 0010 0C94 0000 		jmp unregister_code16
 422               	.LVL27:
 423               		.cfi_endproc
 424               	.LFE33:
 426               		.section	.text.process_action_kb,"ax",@progbits
 427               		.weak	process_action_kb
 429               	process_action_kb:
 430               	.LFB34:
 132:quantum/quantum.c **** 
 133:quantum/quantum.c **** __attribute__((weak)) bool process_action_kb(keyrecord_t *record) { return true; }
 431               		.loc 1 133 0
 432               		.cfi_startproc
 433               	.LVL28:
 434               	/* prologue: function */
 435               	/* frame size = 0 */
 436               	/* stack size = 0 */
 437               	.L__stack_usage = 0
 438               		.loc 1 133 0
 439 0000 81E0      		ldi r24,lo8(1)
 440               	.LVL29:
 441 0002 0895      		ret
 442               		.cfi_endproc
 443               	.LFE34:
 445               		.section	.text.process_record_user,"ax",@progbits
 446               		.weak	process_record_user
 448               	process_record_user:
 449               	.LFB36:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__((weak)) bool process_record_kb(uint16_t keycode, keyrecord_t *record) { return proces
 136:quantum/quantum.c **** 
 137:quantum/quantum.c **** __attribute__((weak)) bool process_record_user(uint16_t keycode, keyrecord_t *record) { return true
 450               		.loc 1 137 0
 451               		.cfi_startproc
 452               	.LVL30:
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 0 */
 456               	.L__stack_usage = 0
 457               		.loc 1 137 0
 458 0000 81E0      		ldi r24,lo8(1)
 459               	.LVL31:
 460 0002 0895      		ret
 461               		.cfi_endproc
 462               	.LFE36:
 464               		.section	.text.process_record_kb,"ax",@progbits
 465               		.weak	process_record_kb
 467               	process_record_kb:
 468               	.LFB35:
 135:quantum/quantum.c **** 
 469               		.loc 1 135 0
 470               		.cfi_startproc
 471               	.LVL32:
 472               	/* prologue: function */
 473               	/* frame size = 0 */
 474               	/* stack size = 0 */
 475               	.L__stack_usage = 0
 135:quantum/quantum.c **** 
 476               		.loc 1 135 0
 477 0000 0C94 0000 		jmp process_record_user
 478               	.LVL33:
 479               		.cfi_endproc
 480               	.LFE35:
 482               		.section	.text.get_event_keycode,"ax",@progbits
 483               	.global	get_event_keycode
 485               	get_event_keycode:
 486               	.LFB39:
 138:quantum/quantum.c **** 
 139:quantum/quantum.c **** void reset_keyboard(void) {
 140:quantum/quantum.c ****     clear_keyboard();
 141:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 142:quantum/quantum.c ****     process_midi_all_notes_off();
 143:quantum/quantum.c **** #endif
 144:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 145:quantum/quantum.c **** #    ifndef NO_MUSIC_MODE
 146:quantum/quantum.c ****     music_all_notes_off();
 147:quantum/quantum.c **** #    endif
 148:quantum/quantum.c ****     uint16_t timer_start = timer_read();
 149:quantum/quantum.c ****     PLAY_SONG(goodbye_song);
 150:quantum/quantum.c ****     shutdown_user();
 151:quantum/quantum.c ****     while (timer_elapsed(timer_start) < 250) wait_ms(1);
 152:quantum/quantum.c ****     stop_all_notes();
 153:quantum/quantum.c **** #else
 154:quantum/quantum.c ****     shutdown_user();
 155:quantum/quantum.c ****     wait_ms(250);
 156:quantum/quantum.c **** #endif
 157:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 158:quantum/quantum.c ****     haptic_shutdown();
 159:quantum/quantum.c **** #endif
 160:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 161:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 162:quantum/quantum.c ****     *(uint16_t *)0x0800 = 0x7777;  // these two are a-star-specific
 163:quantum/quantum.c **** #endif
 164:quantum/quantum.c ****     bootloader_jump();
 165:quantum/quantum.c **** }
 166:quantum/quantum.c **** 
 167:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 168:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 169:quantum/quantum.c ****  */
 170:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 171:quantum/quantum.c **** 
 172:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 173:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record) { return get_event_keycode(record->event); }
 174:quantum/quantum.c **** 
 175:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 176:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 177:quantum/quantum.c ****  */
 178:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event) {
 487               		.loc 1 178 0
 488               		.cfi_startproc
 489 0000 1F93      		push r17
 490               	.LCFI6:
 491               		.cfi_def_cfa_offset 3
 492               		.cfi_offset 17, -2
 493 0002 CF93      		push r28
 494               	.LCFI7:
 495               		.cfi_def_cfa_offset 4
 496               		.cfi_offset 28, -3
 497 0004 DF93      		push r29
 498               	.LCFI8:
 499               		.cfi_def_cfa_offset 5
 500               		.cfi_offset 29, -4
 501 0006 00D0      		rcall .
 502 0008 00D0      		rcall .
 503 000a 1F92      		push __zero_reg__
 504               	.LCFI9:
 505               		.cfi_def_cfa_offset 10
 506 000c CDB7      		in r28,__SP_L__
 507 000e DEB7      		in r29,__SP_H__
 508               	.LCFI10:
 509               		.cfi_def_cfa_register 28
 510               	/* prologue: function */
 511               	/* frame size = 5 */
 512               	/* stack size = 8 */
 513               	.L__stack_usage = 8
 514 0010 4983      		std Y+1,r20
 515 0012 5A83      		std Y+2,r21
 179:quantum/quantum.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 180:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 181:quantum/quantum.c ****     if (!disable_action_cache) {
 516               		.loc 1 181 0
 517 0014 2091 0000 		lds r18,disable_action_cache
 518 0018 8981      		ldd r24,Y+1
 519 001a 9A81      		ldd r25,Y+2
 520 001c 2111      		cpse r18,__zero_reg__
 521 001e 00C0      		rjmp .L56
 522               	.LBB29:
 182:quantum/quantum.c ****         uint8_t layer;
 183:quantum/quantum.c **** 
 184:quantum/quantum.c ****         if (event.pressed) {
 523               		.loc 1 184 0
 524 0020 6623      		tst r22
 525 0022 01F0      		breq .L57
 185:quantum/quantum.c ****             layer = layer_switch_get_layer(event.key);
 526               		.loc 1 185 0
 527 0024 0E94 0000 		call layer_switch_get_layer
 528               	.LVL34:
 529 0028 182F      		mov r17,r24
 530               	.LVL35:
 186:quantum/quantum.c ****             update_source_layers_cache(event.key, layer);
 531               		.loc 1 186 0
 532 002a 682F      		mov r22,r24
 533 002c 8981      		ldd r24,Y+1
 534 002e 9A81      		ldd r25,Y+2
 535 0030 0E94 0000 		call update_source_layers_cache
 536               	.LVL36:
 537 0034 00C0      		rjmp .L58
 538               	.LVL37:
 539               	.L57:
 187:quantum/quantum.c ****         } else {
 188:quantum/quantum.c ****             layer = read_source_layers_cache(event.key);
 540               		.loc 1 188 0
 541 0036 0E94 0000 		call read_source_layers_cache
 542               	.LVL38:
 543 003a 182F      		mov r17,r24
 544               	.LVL39:
 545               	.L58:
 189:quantum/quantum.c ****         }
 190:quantum/quantum.c ****         return keymap_key_to_keycode(layer, event.key);
 546               		.loc 1 190 0
 547 003c 6981      		ldd r22,Y+1
 548 003e 7A81      		ldd r23,Y+2
 549 0040 812F      		mov r24,r17
 550 0042 00C0      		rjmp .L59
 551               	.LVL40:
 552               	.L56:
 553               	.LBE29:
 191:quantum/quantum.c ****     } else
 192:quantum/quantum.c **** #endif
 193:quantum/quantum.c ****         return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 554               		.loc 1 193 0
 555 0044 0E94 0000 		call layer_switch_get_layer
 556               	.LVL41:
 557 0048 6981      		ldd r22,Y+1
 558 004a 7A81      		ldd r23,Y+2
 559               	.L59:
 560               	/* epilogue start */
 194:quantum/quantum.c **** }
 561               		.loc 1 194 0
 562 004c 0F90      		pop __tmp_reg__
 563 004e 0F90      		pop __tmp_reg__
 564 0050 0F90      		pop __tmp_reg__
 565 0052 0F90      		pop __tmp_reg__
 566 0054 0F90      		pop __tmp_reg__
 567 0056 DF91      		pop r29
 568 0058 CF91      		pop r28
 569 005a 1F91      		pop r17
 193:quantum/quantum.c **** }
 570               		.loc 1 193 0
 571 005c 0C94 0000 		jmp keymap_key_to_keycode
 572               	.LVL42:
 573               		.cfi_endproc
 574               	.LFE39:
 576               		.section	.text.get_record_keycode,"ax",@progbits
 577               	.global	get_record_keycode
 579               	get_record_keycode:
 580               	.LFB38:
 173:quantum/quantum.c **** 
 581               		.loc 1 173 0
 582               		.cfi_startproc
 583               	.LVL43:
 584               	/* prologue: function */
 585               	/* frame size = 0 */
 586               	/* stack size = 0 */
 587               	.L__stack_usage = 0
 588 0000 FC01      		movw r30,r24
 173:quantum/quantum.c **** 
 589               		.loc 1 173 0
 590 0002 4081      		ld r20,Z
 591 0004 5181      		ldd r21,Z+1
 592 0006 6281      		ldd r22,Z+2
 593 0008 7381      		ldd r23,Z+3
 594 000a 8481      		ldd r24,Z+4
 595               	.LVL44:
 596 000c 0C94 0000 		jmp get_event_keycode
 597               	.LVL45:
 598               		.cfi_endproc
 599               	.LFE38:
 601               		.section	.text.send_char,"ax",@progbits
 602               	.global	send_char
 604               	send_char:
 605               	.LFB45:
 195:quantum/quantum.c **** 
 196:quantum/quantum.c **** /* Main keycode processing function. Hands off handling to other functions,
 197:quantum/quantum.c ****  * then processes internal Quantum keycodes, then processes ACTIONs.
 198:quantum/quantum.c ****  */
 199:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 200:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 201:quantum/quantum.c **** 
 202:quantum/quantum.c ****     // This is how you use actions here
 203:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 204:quantum/quantum.c ****     //   action_t action;
 205:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 206:quantum/quantum.c ****     //   process_action(record, action);
 207:quantum/quantum.c ****     //   return false;
 208:quantum/quantum.c ****     // }
 209:quantum/quantum.c **** 
 210:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 211:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) {
 212:quantum/quantum.c ****         velocikey_accelerate();
 213:quantum/quantum.c ****     }
 214:quantum/quantum.c **** #endif
 215:quantum/quantum.c **** 
 216:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 217:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 218:quantum/quantum.c **** #endif
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****     if (!(
 221:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 222:quantum/quantum.c ****             // Must run first to be able to mask key_up events.
 223:quantum/quantum.c ****             process_key_lock(&keycode, record) &&
 224:quantum/quantum.c **** #endif
 225:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 226:quantum/quantum.c ****             process_clicky(keycode, record) &&
 227:quantum/quantum.c **** #endif  // AUDIO_CLICKY
 228:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 229:quantum/quantum.c ****             process_haptic(keycode, record) &&
 230:quantum/quantum.c **** #endif  // HAPTIC_ENABLE
 231:quantum/quantum.c **** #if defined(RGB_MATRIX_ENABLE)
 232:quantum/quantum.c ****             process_rgb_matrix(keycode, record) &&
 233:quantum/quantum.c **** #endif
 234:quantum/quantum.c ****             process_record_kb(keycode, record) &&
 235:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 236:quantum/quantum.c ****             process_midi(keycode, record) &&
 237:quantum/quantum.c **** #endif
 238:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 239:quantum/quantum.c ****             process_audio(keycode, record) &&
 240:quantum/quantum.c **** #endif
 241:quantum/quantum.c **** #ifdef STENO_ENABLE
 242:quantum/quantum.c ****             process_steno(keycode, record) &&
 243:quantum/quantum.c **** #endif
 244:quantum/quantum.c **** #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC_M
 245:quantum/quantum.c ****             process_music(keycode, record) &&
 246:quantum/quantum.c **** #endif
 247:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 248:quantum/quantum.c ****             process_tap_dance(keycode, record) &&
 249:quantum/quantum.c **** #endif
 250:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 251:quantum/quantum.c ****             process_unicode_common(keycode, record) &&
 252:quantum/quantum.c **** #endif
 253:quantum/quantum.c **** #ifdef LEADER_ENABLE
 254:quantum/quantum.c ****             process_leader(keycode, record) &&
 255:quantum/quantum.c **** #endif
 256:quantum/quantum.c **** #ifdef COMBO_ENABLE
 257:quantum/quantum.c ****             process_combo(keycode, record) &&
 258:quantum/quantum.c **** #endif
 259:quantum/quantum.c **** #ifdef PRINTING_ENABLE
 260:quantum/quantum.c ****             process_printer(keycode, record) &&
 261:quantum/quantum.c **** #endif
 262:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 263:quantum/quantum.c ****             process_auto_shift(keycode, record) &&
 264:quantum/quantum.c **** #endif
 265:quantum/quantum.c **** #ifdef TERMINAL_ENABLE
 266:quantum/quantum.c ****             process_terminal(keycode, record) &&
 267:quantum/quantum.c **** #endif
 268:quantum/quantum.c **** #ifdef SPACE_CADET_ENABLE
 269:quantum/quantum.c ****             process_space_cadet(keycode, record) &&
 270:quantum/quantum.c **** #endif
 271:quantum/quantum.c ****             true)) {
 272:quantum/quantum.c ****         return false;
 273:quantum/quantum.c ****     }
 274:quantum/quantum.c **** 
 275:quantum/quantum.c ****     // Shift / paren setup
 276:quantum/quantum.c **** 
 277:quantum/quantum.c ****     switch (keycode) {
 278:quantum/quantum.c ****         case RESET:
 279:quantum/quantum.c ****             if (record->event.pressed) {
 280:quantum/quantum.c ****                 reset_keyboard();
 281:quantum/quantum.c ****             }
 282:quantum/quantum.c ****             return false;
 283:quantum/quantum.c ****         case DEBUG:
 284:quantum/quantum.c ****             if (record->event.pressed) {
 285:quantum/quantum.c ****                 debug_enable ^= 1;
 286:quantum/quantum.c ****                 if (debug_enable) {
 287:quantum/quantum.c ****                     print("DEBUG: enabled.\n");
 288:quantum/quantum.c ****                 } else {
 289:quantum/quantum.c ****                     print("DEBUG: disabled.\n");
 290:quantum/quantum.c ****                 }
 291:quantum/quantum.c ****             }
 292:quantum/quantum.c ****             return false;
 293:quantum/quantum.c ****         case EEPROM_RESET:
 294:quantum/quantum.c ****             if (record->event.pressed) {
 295:quantum/quantum.c ****                 eeconfig_init();
 296:quantum/quantum.c ****             }
 297:quantum/quantum.c ****             return false;
 298:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
 299:quantum/quantum.c ****         case FC_TOG:
 300:quantum/quantum.c ****             if (record->event.pressed) {
 301:quantum/quantum.c ****                 FAUXCLICKY_TOGGLE;
 302:quantum/quantum.c ****             }
 303:quantum/quantum.c ****             return false;
 304:quantum/quantum.c ****         case FC_ON:
 305:quantum/quantum.c ****             if (record->event.pressed) {
 306:quantum/quantum.c ****                 FAUXCLICKY_ON;
 307:quantum/quantum.c ****             }
 308:quantum/quantum.c ****             return false;
 309:quantum/quantum.c ****         case FC_OFF:
 310:quantum/quantum.c ****             if (record->event.pressed) {
 311:quantum/quantum.c ****                 FAUXCLICKY_OFF;
 312:quantum/quantum.c ****             }
 313:quantum/quantum.c ****             return false;
 314:quantum/quantum.c **** #endif
 315:quantum/quantum.c **** #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 316:quantum/quantum.c ****         case RGB_TOG:
 317:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 318:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 319:quantum/quantum.c ****             if (record->event.pressed) {
 320:quantum/quantum.c **** #    else
 321:quantum/quantum.c ****             if (!record->event.pressed) {
 322:quantum/quantum.c **** #    endif
 323:quantum/quantum.c ****                 rgblight_toggle();
 324:quantum/quantum.c ****             }
 325:quantum/quantum.c ****             return false;
 326:quantum/quantum.c ****         case RGB_MODE_FORWARD:
 327:quantum/quantum.c ****             if (record->event.pressed) {
 328:quantum/quantum.c ****                 uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT));
 329:quantum/quantum.c ****                 if (shifted) {
 330:quantum/quantum.c ****                     rgblight_step_reverse();
 331:quantum/quantum.c ****                 } else {
 332:quantum/quantum.c ****                     rgblight_step();
 333:quantum/quantum.c ****                 }
 334:quantum/quantum.c ****             }
 335:quantum/quantum.c ****             return false;
 336:quantum/quantum.c ****         case RGB_MODE_REVERSE:
 337:quantum/quantum.c ****             if (record->event.pressed) {
 338:quantum/quantum.c ****                 uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT));
 339:quantum/quantum.c ****                 if (shifted) {
 340:quantum/quantum.c ****                     rgblight_step();
 341:quantum/quantum.c ****                 } else {
 342:quantum/quantum.c ****                     rgblight_step_reverse();
 343:quantum/quantum.c ****                 }
 344:quantum/quantum.c ****             }
 345:quantum/quantum.c ****             return false;
 346:quantum/quantum.c ****         case RGB_HUI:
 347:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 348:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 349:quantum/quantum.c ****             if (record->event.pressed) {
 350:quantum/quantum.c **** #    else
 351:quantum/quantum.c ****             if (!record->event.pressed) {
 352:quantum/quantum.c **** #    endif
 353:quantum/quantum.c ****                 rgblight_increase_hue();
 354:quantum/quantum.c ****             }
 355:quantum/quantum.c ****             return false;
 356:quantum/quantum.c ****         case RGB_HUD:
 357:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 358:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 359:quantum/quantum.c ****             if (record->event.pressed) {
 360:quantum/quantum.c **** #    else
 361:quantum/quantum.c ****             if (!record->event.pressed) {
 362:quantum/quantum.c **** #    endif
 363:quantum/quantum.c ****                 rgblight_decrease_hue();
 364:quantum/quantum.c ****             }
 365:quantum/quantum.c ****             return false;
 366:quantum/quantum.c ****         case RGB_SAI:
 367:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 368:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 369:quantum/quantum.c ****             if (record->event.pressed) {
 370:quantum/quantum.c **** #    else
 371:quantum/quantum.c ****             if (!record->event.pressed) {
 372:quantum/quantum.c **** #    endif
 373:quantum/quantum.c ****                 rgblight_increase_sat();
 374:quantum/quantum.c ****             }
 375:quantum/quantum.c ****             return false;
 376:quantum/quantum.c ****         case RGB_SAD:
 377:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 378:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 379:quantum/quantum.c ****             if (record->event.pressed) {
 380:quantum/quantum.c **** #    else
 381:quantum/quantum.c ****             if (!record->event.pressed) {
 382:quantum/quantum.c **** #    endif
 383:quantum/quantum.c ****                 rgblight_decrease_sat();
 384:quantum/quantum.c ****             }
 385:quantum/quantum.c ****             return false;
 386:quantum/quantum.c ****         case RGB_VAI:
 387:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 388:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 389:quantum/quantum.c ****             if (record->event.pressed) {
 390:quantum/quantum.c **** #    else
 391:quantum/quantum.c ****             if (!record->event.pressed) {
 392:quantum/quantum.c **** #    endif
 393:quantum/quantum.c ****                 rgblight_increase_val();
 394:quantum/quantum.c ****             }
 395:quantum/quantum.c ****             return false;
 396:quantum/quantum.c ****         case RGB_VAD:
 397:quantum/quantum.c **** // Split keyboards need to trigger on key-up for edge-case issue
 398:quantum/quantum.c **** #    ifndef SPLIT_KEYBOARD
 399:quantum/quantum.c ****             if (record->event.pressed) {
 400:quantum/quantum.c **** #    else
 401:quantum/quantum.c ****             if (!record->event.pressed) {
 402:quantum/quantum.c **** #    endif
 403:quantum/quantum.c ****                 rgblight_decrease_val();
 404:quantum/quantum.c ****             }
 405:quantum/quantum.c ****             return false;
 406:quantum/quantum.c ****         case RGB_SPI:
 407:quantum/quantum.c ****             if (record->event.pressed) {
 408:quantum/quantum.c ****                 rgblight_increase_speed();
 409:quantum/quantum.c ****             }
 410:quantum/quantum.c ****             return false;
 411:quantum/quantum.c ****         case RGB_SPD:
 412:quantum/quantum.c ****             if (record->event.pressed) {
 413:quantum/quantum.c ****                 rgblight_decrease_speed();
 414:quantum/quantum.c ****             }
 415:quantum/quantum.c ****             return false;
 416:quantum/quantum.c ****         case RGB_MODE_PLAIN:
 417:quantum/quantum.c ****             if (record->event.pressed) {
 418:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_STATIC_LIGHT);
 419:quantum/quantum.c ****             }
 420:quantum/quantum.c ****             return false;
 421:quantum/quantum.c ****         case RGB_MODE_BREATHE:
 422:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_BREATHING
 423:quantum/quantum.c ****             if (record->event.pressed) {
 424:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_BREATHING <= rgblight_get_mode()) && (rgblight_get_mode() < RGBL
 425:quantum/quantum.c ****                     rgblight_step();
 426:quantum/quantum.c ****                 } else {
 427:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_BREATHING);
 428:quantum/quantum.c ****                 }
 429:quantum/quantum.c ****             }
 430:quantum/quantum.c **** #    endif
 431:quantum/quantum.c ****             return false;
 432:quantum/quantum.c ****         case RGB_MODE_RAINBOW:
 433:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_RAINBOW_MOOD
 434:quantum/quantum.c ****             if (record->event.pressed) {
 435:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_RAINBOW_MOOD <= rgblight_get_mode()) && (rgblight_get_mode() < R
 436:quantum/quantum.c ****                     rgblight_step();
 437:quantum/quantum.c ****                 } else {
 438:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_RAINBOW_MOOD);
 439:quantum/quantum.c ****                 }
 440:quantum/quantum.c ****             }
 441:quantum/quantum.c **** #    endif
 442:quantum/quantum.c ****             return false;
 443:quantum/quantum.c ****         case RGB_MODE_SWIRL:
 444:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_RAINBOW_SWIRL
 445:quantum/quantum.c ****             if (record->event.pressed) {
 446:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_RAINBOW_SWIRL <= rgblight_get_mode()) && (rgblight_get_mode() < 
 447:quantum/quantum.c ****                     rgblight_step();
 448:quantum/quantum.c ****                 } else {
 449:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_RAINBOW_SWIRL);
 450:quantum/quantum.c ****                 }
 451:quantum/quantum.c ****             }
 452:quantum/quantum.c **** #    endif
 453:quantum/quantum.c ****             return false;
 454:quantum/quantum.c ****         case RGB_MODE_SNAKE:
 455:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_SNAKE
 456:quantum/quantum.c ****             if (record->event.pressed) {
 457:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_SNAKE <= rgblight_get_mode()) && (rgblight_get_mode() < RGBLIGHT
 458:quantum/quantum.c ****                     rgblight_step();
 459:quantum/quantum.c ****                 } else {
 460:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_SNAKE);
 461:quantum/quantum.c ****                 }
 462:quantum/quantum.c ****             }
 463:quantum/quantum.c **** #    endif
 464:quantum/quantum.c ****             return false;
 465:quantum/quantum.c ****         case RGB_MODE_KNIGHT:
 466:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_KNIGHT
 467:quantum/quantum.c ****             if (record->event.pressed) {
 468:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_KNIGHT <= rgblight_get_mode()) && (rgblight_get_mode() < RGBLIGH
 469:quantum/quantum.c ****                     rgblight_step();
 470:quantum/quantum.c ****                 } else {
 471:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_KNIGHT);
 472:quantum/quantum.c ****                 }
 473:quantum/quantum.c ****             }
 474:quantum/quantum.c **** #    endif
 475:quantum/quantum.c ****             return false;
 476:quantum/quantum.c ****         case RGB_MODE_XMAS:
 477:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_CHRISTMAS
 478:quantum/quantum.c ****             if (record->event.pressed) {
 479:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_CHRISTMAS);
 480:quantum/quantum.c ****             }
 481:quantum/quantum.c **** #    endif
 482:quantum/quantum.c ****             return false;
 483:quantum/quantum.c ****         case RGB_MODE_GRADIENT:
 484:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_STATIC_GRADIENT
 485:quantum/quantum.c ****             if (record->event.pressed) {
 486:quantum/quantum.c ****                 if ((RGBLIGHT_MODE_STATIC_GRADIENT <= rgblight_get_mode()) && (rgblight_get_mode() 
 487:quantum/quantum.c ****                     rgblight_step();
 488:quantum/quantum.c ****                 } else {
 489:quantum/quantum.c ****                     rgblight_mode(RGBLIGHT_MODE_STATIC_GRADIENT);
 490:quantum/quantum.c ****                 }
 491:quantum/quantum.c ****             }
 492:quantum/quantum.c **** #    endif
 493:quantum/quantum.c ****             return false;
 494:quantum/quantum.c ****         case RGB_MODE_RGBTEST:
 495:quantum/quantum.c **** #    ifdef RGBLIGHT_EFFECT_RGB_TEST
 496:quantum/quantum.c ****             if (record->event.pressed) {
 497:quantum/quantum.c ****                 rgblight_mode(RGBLIGHT_MODE_RGB_TEST);
 498:quantum/quantum.c ****             }
 499:quantum/quantum.c **** #    endif
 500:quantum/quantum.c ****             return false;
 501:quantum/quantum.c **** #endif  // defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 502:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 503:quantum/quantum.c ****         case VLK_TOG:
 504:quantum/quantum.c ****             if (record->event.pressed) {
 505:quantum/quantum.c ****                 velocikey_toggle();
 506:quantum/quantum.c ****             }
 507:quantum/quantum.c ****             return false;
 508:quantum/quantum.c **** #endif
 509:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
 510:quantum/quantum.c ****         case OUT_AUTO:
 511:quantum/quantum.c ****             if (record->event.pressed) {
 512:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 513:quantum/quantum.c ****             }
 514:quantum/quantum.c ****             return false;
 515:quantum/quantum.c ****         case OUT_USB:
 516:quantum/quantum.c ****             if (record->event.pressed) {
 517:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 518:quantum/quantum.c ****             }
 519:quantum/quantum.c ****             return false;
 520:quantum/quantum.c **** #    ifdef BLUETOOTH_ENABLE
 521:quantum/quantum.c ****         case OUT_BT:
 522:quantum/quantum.c ****             if (record->event.pressed) {
 523:quantum/quantum.c ****                 set_output(OUTPUT_BLUETOOTH);
 524:quantum/quantum.c ****             }
 525:quantum/quantum.c ****             return false;
 526:quantum/quantum.c **** #    endif
 527:quantum/quantum.c **** #endif
 528:quantum/quantum.c ****         case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_ALT_GUI:
 529:quantum/quantum.c ****         case MAGIC_SWAP_LCTL_LGUI ... MAGIC_EE_HANDS_RIGHT:
 530:quantum/quantum.c ****             if (record->event.pressed) {
 531:quantum/quantum.c ****                 // MAGIC actions (BOOTMAGIC without the boot)
 532:quantum/quantum.c ****                 if (!eeconfig_is_enabled()) {
 533:quantum/quantum.c ****                     eeconfig_init();
 534:quantum/quantum.c ****                 }
 535:quantum/quantum.c ****                 /* keymap config */
 536:quantum/quantum.c ****                 keymap_config.raw = eeconfig_read_keymap();
 537:quantum/quantum.c ****                 switch (keycode) {
 538:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 539:quantum/quantum.c ****                         keymap_config.swap_control_capslock = true;
 540:quantum/quantum.c ****                         break;
 541:quantum/quantum.c ****                     case MAGIC_CAPSLOCK_TO_CONTROL:
 542:quantum/quantum.c ****                         keymap_config.capslock_to_control = true;
 543:quantum/quantum.c ****                         break;
 544:quantum/quantum.c ****                     case MAGIC_SWAP_LALT_LGUI:
 545:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = true;
 546:quantum/quantum.c ****                         break;
 547:quantum/quantum.c ****                     case MAGIC_SWAP_RALT_RGUI:
 548:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = true;
 549:quantum/quantum.c ****                         break;
 550:quantum/quantum.c ****                     case MAGIC_SWAP_LCTL_LGUI:
 551:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = true;
 552:quantum/quantum.c ****                         break;
 553:quantum/quantum.c ****                     case MAGIC_SWAP_RCTL_RGUI:
 554:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = true;
 555:quantum/quantum.c ****                         break;
 556:quantum/quantum.c ****                     case MAGIC_NO_GUI:
 557:quantum/quantum.c ****                         keymap_config.no_gui = true;
 558:quantum/quantum.c ****                         break;
 559:quantum/quantum.c ****                     case MAGIC_SWAP_GRAVE_ESC:
 560:quantum/quantum.c ****                         keymap_config.swap_grave_esc = true;
 561:quantum/quantum.c ****                         break;
 562:quantum/quantum.c ****                     case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 563:quantum/quantum.c ****                         keymap_config.swap_backslash_backspace = true;
 564:quantum/quantum.c ****                         break;
 565:quantum/quantum.c ****                     case MAGIC_HOST_NKRO:
 566:quantum/quantum.c ****                         clear_keyboard(); // clear first buffer to prevent stuck keys
 567:quantum/quantum.c ****                         keymap_config.nkro = true;
 568:quantum/quantum.c ****                         break;
 569:quantum/quantum.c ****                     case MAGIC_SWAP_ALT_GUI:
 570:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = keymap_config.swap_ralt_rgui = true;
 571:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 572:quantum/quantum.c ****                         PLAY_SONG(ag_swap_song);
 573:quantum/quantum.c **** #endif
 574:quantum/quantum.c ****                         break;
 575:quantum/quantum.c ****                     case MAGIC_SWAP_CTL_GUI:
 576:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = keymap_config.swap_rctl_rgui = true;
 577:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 578:quantum/quantum.c ****                         PLAY_SONG(cg_swap_song);
 579:quantum/quantum.c **** #endif
 580:quantum/quantum.c ****                         break;
 581:quantum/quantum.c ****                     case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 582:quantum/quantum.c ****                         keymap_config.swap_control_capslock = false;
 583:quantum/quantum.c ****                         break;
 584:quantum/quantum.c ****                     case MAGIC_UNCAPSLOCK_TO_CONTROL:
 585:quantum/quantum.c ****                         keymap_config.capslock_to_control = false;
 586:quantum/quantum.c ****                         break;
 587:quantum/quantum.c ****                     case MAGIC_UNSWAP_LALT_LGUI:
 588:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = false;
 589:quantum/quantum.c ****                         break;
 590:quantum/quantum.c ****                     case MAGIC_UNSWAP_RALT_RGUI:
 591:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = false;
 592:quantum/quantum.c ****                         break;
 593:quantum/quantum.c ****                     case MAGIC_UNSWAP_LCTL_LGUI:
 594:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = false;
 595:quantum/quantum.c ****                         break;
 596:quantum/quantum.c ****                     case MAGIC_UNSWAP_RCTL_RGUI:
 597:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = false;
 598:quantum/quantum.c ****                         break;
 599:quantum/quantum.c ****                     case MAGIC_UNNO_GUI:
 600:quantum/quantum.c ****                         keymap_config.no_gui = false;
 601:quantum/quantum.c ****                         break;
 602:quantum/quantum.c ****                     case MAGIC_UNSWAP_GRAVE_ESC:
 603:quantum/quantum.c ****                         keymap_config.swap_grave_esc = false;
 604:quantum/quantum.c ****                         break;
 605:quantum/quantum.c ****                     case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 606:quantum/quantum.c ****                         keymap_config.swap_backslash_backspace = false;
 607:quantum/quantum.c ****                         break;
 608:quantum/quantum.c ****                     case MAGIC_UNHOST_NKRO:
 609:quantum/quantum.c ****                         clear_keyboard(); // clear first buffer to prevent stuck keys
 610:quantum/quantum.c ****                         keymap_config.nkro = false;
 611:quantum/quantum.c ****                         break;
 612:quantum/quantum.c ****                     case MAGIC_UNSWAP_ALT_GUI:
 613:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = keymap_config.swap_ralt_rgui = false;
 614:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 615:quantum/quantum.c ****                         PLAY_SONG(ag_norm_song);
 616:quantum/quantum.c **** #endif
 617:quantum/quantum.c ****                         break;
 618:quantum/quantum.c ****                     case MAGIC_UNSWAP_CTL_GUI:
 619:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = keymap_config.swap_rctl_rgui = false;
 620:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 621:quantum/quantum.c ****                         PLAY_SONG(cg_norm_song);
 622:quantum/quantum.c **** #endif
 623:quantum/quantum.c ****                         break;
 624:quantum/quantum.c ****                     case MAGIC_TOGGLE_ALT_GUI:
 625:quantum/quantum.c ****                         keymap_config.swap_lalt_lgui = !keymap_config.swap_lalt_lgui;
 626:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = keymap_config.swap_lalt_lgui;
 627:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 628:quantum/quantum.c ****                         if (keymap_config.swap_ralt_rgui) {
 629:quantum/quantum.c ****                             PLAY_SONG(ag_swap_song);
 630:quantum/quantum.c ****                         } else {
 631:quantum/quantum.c ****                             PLAY_SONG(ag_norm_song);
 632:quantum/quantum.c ****                         }
 633:quantum/quantum.c **** #endif
 634:quantum/quantum.c ****                         break;
 635:quantum/quantum.c ****                     case MAGIC_TOGGLE_CTL_GUI:
 636:quantum/quantum.c ****                         keymap_config.swap_lctl_lgui = !keymap_config.swap_lctl_lgui;
 637:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = keymap_config.swap_lctl_lgui;
 638:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 639:quantum/quantum.c ****                         if (keymap_config.swap_rctl_rgui) {
 640:quantum/quantum.c ****                             PLAY_SONG(cg_swap_song);
 641:quantum/quantum.c ****                         } else {
 642:quantum/quantum.c ****                             PLAY_SONG(cg_norm_song);
 643:quantum/quantum.c ****                         }
 644:quantum/quantum.c **** #endif
 645:quantum/quantum.c ****                         break;
 646:quantum/quantum.c ****                     case MAGIC_TOGGLE_NKRO:
 647:quantum/quantum.c ****                         clear_keyboard(); // clear first buffer to prevent stuck keys
 648:quantum/quantum.c ****                         keymap_config.nkro = !keymap_config.nkro;
 649:quantum/quantum.c ****                         break;
 650:quantum/quantum.c ****                     case MAGIC_EE_HANDS_LEFT:
 651:quantum/quantum.c ****                         eeconfig_update_handedness(true);
 652:quantum/quantum.c ****                         break;
 653:quantum/quantum.c ****                     case MAGIC_EE_HANDS_RIGHT:
 654:quantum/quantum.c ****                         eeconfig_update_handedness(false);
 655:quantum/quantum.c ****                         break;
 656:quantum/quantum.c ****                     default:
 657:quantum/quantum.c ****                         break;
 658:quantum/quantum.c ****                 }
 659:quantum/quantum.c ****                 eeconfig_update_keymap(keymap_config.raw);
 660:quantum/quantum.c ****                 clear_keyboard();  // clear to prevent stuck keys
 661:quantum/quantum.c **** 
 662:quantum/quantum.c ****                 return false;
 663:quantum/quantum.c ****             }
 664:quantum/quantum.c ****             break;
 665:quantum/quantum.c **** 
 666:quantum/quantum.c ****         case GRAVE_ESC: {
 667:quantum/quantum.c ****             uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT) | MOD_BIT(KC_L
 668:quantum/quantum.c **** 
 669:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 670:quantum/quantum.c ****             // if ALT is pressed, ESC is always sent
 671:quantum/quantum.c ****             // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 672:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 673:quantum/quantum.c ****                 shifted = 0;
 674:quantum/quantum.c ****             }
 675:quantum/quantum.c **** #endif
 676:quantum/quantum.c **** 
 677:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 678:quantum/quantum.c ****             // if CTRL is pressed, ESC is always sent
 679:quantum/quantum.c ****             // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 680:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 681:quantum/quantum.c ****                 shifted = 0;
 682:quantum/quantum.c ****             }
 683:quantum/quantum.c **** #endif
 684:quantum/quantum.c **** 
 685:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 686:quantum/quantum.c ****             // if GUI is pressed, ESC is always sent
 687:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 688:quantum/quantum.c ****                 shifted = 0;
 689:quantum/quantum.c ****             }
 690:quantum/quantum.c **** #endif
 691:quantum/quantum.c **** 
 692:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 693:quantum/quantum.c ****             // if SHIFT is pressed, ESC is always sent
 694:quantum/quantum.c ****             if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 695:quantum/quantum.c ****                 shifted = 0;
 696:quantum/quantum.c ****             }
 697:quantum/quantum.c **** #endif
 698:quantum/quantum.c **** 
 699:quantum/quantum.c ****             if (record->event.pressed) {
 700:quantum/quantum.c ****                 grave_esc_was_shifted = shifted;
 701:quantum/quantum.c ****                 add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 702:quantum/quantum.c ****             } else {
 703:quantum/quantum.c ****                 del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 704:quantum/quantum.c ****             }
 705:quantum/quantum.c **** 
 706:quantum/quantum.c ****             send_keyboard_report();
 707:quantum/quantum.c ****             return false;
 708:quantum/quantum.c ****         }
 709:quantum/quantum.c **** 
 710:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 711:quantum/quantum.c ****         case BL_BRTG: {
 712:quantum/quantum.c ****             if (record->event.pressed) {
 713:quantum/quantum.c ****                 backlight_toggle_breathing();
 714:quantum/quantum.c ****             }
 715:quantum/quantum.c ****             return false;
 716:quantum/quantum.c ****         }
 717:quantum/quantum.c **** #endif
 718:quantum/quantum.c ****     }
 719:quantum/quantum.c **** 
 720:quantum/quantum.c ****     return process_action_kb(record);
 721:quantum/quantum.c **** }
 722:quantum/quantum.c **** 
 723:quantum/quantum.c **** __attribute__((weak)) const bool ascii_to_shift_lut[128] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 724:quantum/quantum.c **** 
 725:quantum/quantum.c ****                                                                     0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1
 726:quantum/quantum.c **** 
 727:quantum/quantum.c **** __attribute__((weak)) const bool ascii_to_altgr_lut[128] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 728:quantum/quantum.c **** 
 729:quantum/quantum.c ****                                                                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
 730:quantum/quantum.c **** 
 731:quantum/quantum.c **** __attribute__((weak)) const uint8_t ascii_to_keycode_lut[128] PROGMEM = {// NUL   SOH      STX     
 732:quantum/quantum.c ****                                                                          XXXXXXX, XXXXXXX, XXXXXXX,
 733:quantum/quantum.c ****                                                                          // BS    TAB      LF      
 734:quantum/quantum.c ****                                                                          KC_BSPC, KC_TAB, KC_ENT, X
 735:quantum/quantum.c ****                                                                          // DLE   DC1      DC2     
 736:quantum/quantum.c ****                                                                          XXXXXXX, XXXXXXX, XXXXXXX,
 737:quantum/quantum.c ****                                                                          // CAN   EM       SUB     
 738:quantum/quantum.c ****                                                                          XXXXXXX, XXXXXXX, XXXXXXX,
 739:quantum/quantum.c **** 
 740:quantum/quantum.c ****                                                                          //       !        "       
 741:quantum/quantum.c ****                                                                          KC_SPC, KC_1, KC_QUOT, KC_
 742:quantum/quantum.c ****                                                                          // (     )        *       
 743:quantum/quantum.c ****                                                                          KC_9, KC_0, KC_8, KC_EQL, 
 744:quantum/quantum.c ****                                                                          // 0     1        2       
 745:quantum/quantum.c ****                                                                          KC_0, KC_1, KC_2, KC_3, KC
 746:quantum/quantum.c ****                                                                          // 8     9        :       
 747:quantum/quantum.c ****                                                                          KC_8, KC_9, KC_SCLN, KC_SC
 748:quantum/quantum.c ****                                                                          // @     A        B       
 749:quantum/quantum.c ****                                                                          KC_2, KC_A, KC_B, KC_C, KC
 750:quantum/quantum.c ****                                                                          // H     I        J       
 751:quantum/quantum.c ****                                                                          KC_H, KC_I, KC_J, KC_K, KC
 752:quantum/quantum.c ****                                                                          // P     Q        R       
 753:quantum/quantum.c ****                                                                          KC_P, KC_Q, KC_R, KC_S, KC
 754:quantum/quantum.c ****                                                                          // X     Y        Z       
 755:quantum/quantum.c ****                                                                          KC_X, KC_Y, KC_Z, KC_LBRC,
 756:quantum/quantum.c ****                                                                          // `     a        b       
 757:quantum/quantum.c ****                                                                          KC_GRV, KC_A, KC_B, KC_C, 
 758:quantum/quantum.c ****                                                                          // h     i        j       
 759:quantum/quantum.c ****                                                                          KC_H, KC_I, KC_J, KC_K, KC
 760:quantum/quantum.c ****                                                                          // p     q        r       
 761:quantum/quantum.c ****                                                                          KC_P, KC_Q, KC_R, KC_S, KC
 762:quantum/quantum.c ****                                                                          // x     y        z       
 763:quantum/quantum.c ****                                                                          KC_X, KC_Y, KC_Z, KC_LBRC,
 764:quantum/quantum.c **** 
 765:quantum/quantum.c **** void send_string(const char *str) { send_string_with_delay(str, 0); }
 766:quantum/quantum.c **** 
 767:quantum/quantum.c **** void send_string_P(const char *str) { send_string_with_delay_P(str, 0); }
 768:quantum/quantum.c **** 
 769:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 770:quantum/quantum.c ****     while (1) {
 771:quantum/quantum.c ****         char ascii_code = *str;
 772:quantum/quantum.c ****         if (!ascii_code) break;
 773:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 774:quantum/quantum.c ****             // tap
 775:quantum/quantum.c ****             uint8_t keycode = *(++str);
 776:quantum/quantum.c ****             register_code(keycode);
 777:quantum/quantum.c ****             unregister_code(keycode);
 778:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 779:quantum/quantum.c ****             // down
 780:quantum/quantum.c ****             uint8_t keycode = *(++str);
 781:quantum/quantum.c ****             register_code(keycode);
 782:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 783:quantum/quantum.c ****             // up
 784:quantum/quantum.c ****             uint8_t keycode = *(++str);
 785:quantum/quantum.c ****             unregister_code(keycode);
 786:quantum/quantum.c ****         } else {
 787:quantum/quantum.c ****             send_char(ascii_code);
 788:quantum/quantum.c ****         }
 789:quantum/quantum.c ****         ++str;
 790:quantum/quantum.c ****         // interval
 791:quantum/quantum.c ****         {
 792:quantum/quantum.c ****             uint8_t ms = interval;
 793:quantum/quantum.c ****             while (ms--) wait_ms(1);
 794:quantum/quantum.c ****         }
 795:quantum/quantum.c ****     }
 796:quantum/quantum.c **** }
 797:quantum/quantum.c **** 
 798:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 799:quantum/quantum.c ****     while (1) {
 800:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 801:quantum/quantum.c ****         if (!ascii_code) break;
 802:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 803:quantum/quantum.c ****             // tap
 804:quantum/quantum.c ****             uint8_t keycode = pgm_read_byte(++str);
 805:quantum/quantum.c ****             register_code(keycode);
 806:quantum/quantum.c ****             unregister_code(keycode);
 807:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 808:quantum/quantum.c ****             // down
 809:quantum/quantum.c ****             uint8_t keycode = pgm_read_byte(++str);
 810:quantum/quantum.c ****             register_code(keycode);
 811:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 812:quantum/quantum.c ****             // up
 813:quantum/quantum.c ****             uint8_t keycode = pgm_read_byte(++str);
 814:quantum/quantum.c ****             unregister_code(keycode);
 815:quantum/quantum.c ****         } else {
 816:quantum/quantum.c ****             send_char(ascii_code);
 817:quantum/quantum.c ****         }
 818:quantum/quantum.c ****         ++str;
 819:quantum/quantum.c ****         // interval
 820:quantum/quantum.c ****         {
 821:quantum/quantum.c ****             uint8_t ms = interval;
 822:quantum/quantum.c ****             while (ms--) wait_ms(1);
 823:quantum/quantum.c ****         }
 824:quantum/quantum.c ****     }
 825:quantum/quantum.c **** }
 826:quantum/quantum.c **** 
 827:quantum/quantum.c **** void send_char(char ascii_code) {
 606               		.loc 1 827 0
 607               		.cfi_startproc
 608               	.LVL46:
 609 0000 1F93      		push r17
 610               	.LCFI11:
 611               		.cfi_def_cfa_offset 3
 612               		.cfi_offset 17, -2
 613 0002 CF93      		push r28
 614               	.LCFI12:
 615               		.cfi_def_cfa_offset 4
 616               		.cfi_offset 28, -3
 617 0004 DF93      		push r29
 618               	.LCFI13:
 619               		.cfi_def_cfa_offset 5
 620               		.cfi_offset 29, -4
 621               	/* prologue: function */
 622               	/* frame size = 0 */
 623               	/* stack size = 3 */
 624               	.L__stack_usage = 3
 625               	.LBB30:
 828:quantum/quantum.c ****     uint8_t keycode    = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 626               		.loc 1 828 0
 627 0006 282F      		mov r18,r24
 628 0008 30E0      		ldi r19,0
 629               	.LVL47:
 630 000a F901      		movw r30,r18
 631 000c E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 632 000e F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 633               	.LVL48:
 634               	/* #APP */
 635               	 ;  828 "quantum/quantum.c" 1
 636 0010 1491      		lpm r17, Z
 637               		
 638               	 ;  0 "" 2
 639               	.LVL49:
 640               	/* #NOAPP */
 641               	.LBE30:
 642               	.LBB31:
 829:quantum/quantum.c ****     bool    is_shifted = pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code]);
 643               		.loc 1 829 0
 644 0012 F901      		movw r30,r18
 645               	.LVL50:
 646 0014 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 647 0016 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 648               	.LVL51:
 649               	/* #APP */
 650               	 ;  829 "quantum/quantum.c" 1
 651 0018 E491      		lpm r30, Z
 652               		
 653               	 ;  0 "" 2
 654               	.LVL52:
 655               	/* #NOAPP */
 656               	.LBE31:
 657 001a C1E0      		ldi r28,lo8(1)
 658 001c E111      		cpse r30,__zero_reg__
 659 001e 00C0      		rjmp .L62
 660 0020 C0E0      		ldi r28,0
 661               	.L62:
 662               	.LVL53:
 663               	.LBB32:
 830:quantum/quantum.c ****     bool    is_altgred = pgm_read_byte(&ascii_to_altgr_lut[(uint8_t)ascii_code]);
 664               		.loc 1 830 0
 665 0022 F901      		movw r30,r18
 666               	.LVL54:
 667 0024 E050      		subi r30,lo8(-(ascii_to_altgr_lut))
 668 0026 F040      		sbci r31,hi8(-(ascii_to_altgr_lut))
 669               	.LVL55:
 670               	/* #APP */
 671               	 ;  830 "quantum/quantum.c" 1
 672 0028 2491      		lpm r18, Z
 673               		
 674               	 ;  0 "" 2
 675               	.LVL56:
 676               	/* #NOAPP */
 677               	.LBE32:
 678 002a D1E0      		ldi r29,lo8(1)
 679 002c 2111      		cpse r18,__zero_reg__
 680 002e 00C0      		rjmp .L63
 681 0030 D0E0      		ldi r29,0
 682               	.L63:
 683               	.LVL57:
 831:quantum/quantum.c **** 
 832:quantum/quantum.c ****     if (is_shifted) {
 684               		.loc 1 832 0
 685 0032 CC23      		tst r28
 686 0034 01F0      		breq .L64
 833:quantum/quantum.c ****         register_code(KC_LSFT);
 687               		.loc 1 833 0
 688 0036 81EE      		ldi r24,lo8(-31)
 689               	.LVL58:
 690 0038 0E94 0000 		call register_code
 691               	.LVL59:
 692               	.L64:
 834:quantum/quantum.c ****     }
 835:quantum/quantum.c ****     if (is_altgred) {
 693               		.loc 1 835 0
 694 003c DD23      		tst r29
 695 003e 01F0      		breq .L65
 836:quantum/quantum.c ****         register_code(KC_RALT);
 696               		.loc 1 836 0
 697 0040 86EE      		ldi r24,lo8(-26)
 698 0042 0E94 0000 		call register_code
 699               	.LVL60:
 700               	.L65:
 837:quantum/quantum.c ****     }
 838:quantum/quantum.c ****     tap_code(keycode);
 701               		.loc 1 838 0
 702 0046 812F      		mov r24,r17
 703 0048 0E94 0000 		call tap_code
 704               	.LVL61:
 839:quantum/quantum.c ****     if (is_altgred) {
 705               		.loc 1 839 0
 706 004c DD23      		tst r29
 707 004e 01F0      		breq .L66
 840:quantum/quantum.c ****         unregister_code(KC_RALT);
 708               		.loc 1 840 0
 709 0050 86EE      		ldi r24,lo8(-26)
 710 0052 0E94 0000 		call unregister_code
 711               	.LVL62:
 712               	.L66:
 841:quantum/quantum.c ****     }
 842:quantum/quantum.c ****     if (is_shifted) {
 713               		.loc 1 842 0
 714 0056 CC23      		tst r28
 715 0058 01F0      		breq .L61
 843:quantum/quantum.c ****         unregister_code(KC_LSFT);
 716               		.loc 1 843 0
 717 005a 81EE      		ldi r24,lo8(-31)
 718               	/* epilogue start */
 844:quantum/quantum.c ****     }
 845:quantum/quantum.c **** }
 719               		.loc 1 845 0
 720 005c DF91      		pop r29
 721               	.LVL63:
 722 005e CF91      		pop r28
 723               	.LVL64:
 724 0060 1F91      		pop r17
 725               	.LVL65:
 843:quantum/quantum.c ****         unregister_code(KC_LSFT);
 726               		.loc 1 843 0
 727 0062 0C94 0000 		jmp unregister_code
 728               	.LVL66:
 729               	.L61:
 730               	/* epilogue start */
 731               		.loc 1 845 0
 732 0066 DF91      		pop r29
 733               	.LVL67:
 734 0068 CF91      		pop r28
 735               	.LVL68:
 736 006a 1F91      		pop r17
 737               	.LVL69:
 738 006c 0895      		ret
 739               		.cfi_endproc
 740               	.LFE45:
 742               		.section	.text.send_string_with_delay,"ax",@progbits
 743               	.global	send_string_with_delay
 745               	send_string_with_delay:
 746               	.LFB43:
 769:quantum/quantum.c ****     while (1) {
 747               		.loc 1 769 0
 748               		.cfi_startproc
 749               	.LVL70:
 750 0000 FF92      		push r15
 751               	.LCFI14:
 752               		.cfi_def_cfa_offset 3
 753               		.cfi_offset 15, -2
 754 0002 0F93      		push r16
 755               	.LCFI15:
 756               		.cfi_def_cfa_offset 4
 757               		.cfi_offset 16, -3
 758 0004 1F93      		push r17
 759               	.LCFI16:
 760               		.cfi_def_cfa_offset 5
 761               		.cfi_offset 17, -4
 762 0006 CF93      		push r28
 763               	.LCFI17:
 764               		.cfi_def_cfa_offset 6
 765               		.cfi_offset 28, -5
 766 0008 DF93      		push r29
 767               	.LCFI18:
 768               		.cfi_def_cfa_offset 7
 769               		.cfi_offset 29, -6
 770               	/* prologue: function */
 771               	/* frame size = 0 */
 772               	/* stack size = 5 */
 773               	.L__stack_usage = 5
 774 000a EC01      		movw r28,r24
 775 000c F62E      		mov r15,r22
 776               	.LVL71:
 777               	.L85:
 778               	.LBB33:
 771:quantum/quantum.c ****         if (!ascii_code) break;
 779               		.loc 1 771 0
 780 000e 8881      		ld r24,Y
 781               	.LVL72:
 772:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 782               		.loc 1 772 0
 783 0010 8823      		tst r24
 784 0012 01F0      		breq .L77
 785 0014 8E01      		movw r16,r28
 786 0016 0F5F      		subi r16,-1
 787 0018 1F4F      		sbci r17,-1
 773:quantum/quantum.c ****             // tap
 788               		.loc 1 773 0
 789 001a 8130      		cpi r24,lo8(1)
 790 001c 01F4      		brne .L79
 791               	.LVL73:
 792               	.LBB34:
 775:quantum/quantum.c ****             register_code(keycode);
 793               		.loc 1 775 0
 794 001e C981      		ldd r28,Y+1
 795               	.LVL74:
 776:quantum/quantum.c ****             unregister_code(keycode);
 796               		.loc 1 776 0
 797 0020 8C2F      		mov r24,r28
 798               	.LVL75:
 799 0022 0E94 0000 		call register_code
 800               	.LVL76:
 777:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 801               		.loc 1 777 0
 802 0026 8C2F      		mov r24,r28
 803 0028 00C0      		rjmp .L87
 804               	.LVL77:
 805               	.L79:
 806               	.LBE34:
 778:quantum/quantum.c ****             // down
 807               		.loc 1 778 0
 808 002a 8230      		cpi r24,lo8(2)
 809 002c 01F4      		brne .L81
 810               	.LVL78:
 811               	.LBB35:
 781:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 812               		.loc 1 781 0
 813 002e 8981      		ldd r24,Y+1
 814               	.LVL79:
 815 0030 0E94 0000 		call register_code
 816               	.LVL80:
 817               	.L86:
 780:quantum/quantum.c ****             register_code(keycode);
 818               		.loc 1 780 0
 819 0034 E801      		movw r28,r16
 820               	.LBE35:
 821 0036 00C0      		rjmp .L80
 822               	.LVL81:
 823               	.L81:
 782:quantum/quantum.c ****             // up
 824               		.loc 1 782 0
 825 0038 8330      		cpi r24,lo8(3)
 826 003a 01F4      		brne .L82
 827               	.LVL82:
 828               	.LBB36:
 785:quantum/quantum.c ****         } else {
 829               		.loc 1 785 0
 830 003c 8981      		ldd r24,Y+1
 831               	.LVL83:
 832               	.L87:
 833 003e 0E94 0000 		call unregister_code
 834               	.LVL84:
 835 0042 00C0      		rjmp .L86
 836               	.LVL85:
 837               	.L82:
 838               	.LBE36:
 787:quantum/quantum.c ****         }
 839               		.loc 1 787 0
 840 0044 0E94 0000 		call send_char
 841               	.LVL86:
 842               	.L80:
 789:quantum/quantum.c ****         // interval
 843               		.loc 1 789 0
 844 0048 2196      		adiw r28,1
 845               	.LVL87:
 846               	.LBB37:
 793:quantum/quantum.c ****         }
 847               		.loc 1 793 0
 848 004a 8F2D      		mov r24,r15
 849               	.LVL88:
 850               	.L83:
 793:quantum/quantum.c ****         }
 851               		.loc 1 793 0 is_stmt 0 discriminator 1
 852 004c 8823      		tst r24
 853 004e 01F0      		breq .L85
 854               	.LVL89:
 855               	.LBB38:
 856               	.LBB39:
 857               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 858               		.loc 3 163 0 is_stmt 1
 859 0050 EFE9      		ldi r30,lo8(3999)
 860 0052 FFE0      		ldi r31,hi8(3999)
 861 0054 3197      	1:	sbiw r30,1
 862 0056 01F4      		brne 1b
 863 0058 00C0      		rjmp .
 864 005a 0000      		nop
 865 005c 8150      		subi r24,lo8(-(-1))
 866               	.LVL90:
 867 005e 00C0      		rjmp .L83
 868               	.LVL91:
 869               	.L77:
 870               	/* epilogue start */
 871               	.LBE39:
 872               	.LBE38:
 873               	.LBE37:
 874               	.LBE33:
 796:quantum/quantum.c **** 
 875               		.loc 1 796 0
 876 0060 DF91      		pop r29
 877 0062 CF91      		pop r28
 878               	.LVL92:
 879 0064 1F91      		pop r17
 880 0066 0F91      		pop r16
 881 0068 FF90      		pop r15
 882               	.LVL93:
 883 006a 0895      		ret
 884               		.cfi_endproc
 885               	.LFE43:
 887               		.section	.text.send_string,"ax",@progbits
 888               	.global	send_string
 890               	send_string:
 891               	.LFB41:
 765:quantum/quantum.c **** 
 892               		.loc 1 765 0
 893               		.cfi_startproc
 894               	.LVL94:
 895               	/* prologue: function */
 896               	/* frame size = 0 */
 897               	/* stack size = 0 */
 898               	.L__stack_usage = 0
 765:quantum/quantum.c **** 
 899               		.loc 1 765 0
 900 0000 60E0      		ldi r22,0
 901 0002 0C94 0000 		jmp send_string_with_delay
 902               	.LVL95:
 903               		.cfi_endproc
 904               	.LFE41:
 906               		.section	.text.send_string_with_delay_P,"ax",@progbits
 907               	.global	send_string_with_delay_P
 909               	send_string_with_delay_P:
 910               	.LFB44:
 798:quantum/quantum.c ****     while (1) {
 911               		.loc 1 798 0
 912               		.cfi_startproc
 913               	.LVL96:
 914 0000 0F93      		push r16
 915               	.LCFI19:
 916               		.cfi_def_cfa_offset 3
 917               		.cfi_offset 16, -2
 918 0002 1F93      		push r17
 919               	.LCFI20:
 920               		.cfi_def_cfa_offset 4
 921               		.cfi_offset 17, -3
 922 0004 CF93      		push r28
 923               	.LCFI21:
 924               		.cfi_def_cfa_offset 5
 925               		.cfi_offset 28, -4
 926 0006 DF93      		push r29
 927               	.LCFI22:
 928               		.cfi_def_cfa_offset 6
 929               		.cfi_offset 29, -5
 930               	/* prologue: function */
 931               	/* frame size = 0 */
 932               	/* stack size = 4 */
 933               	.L__stack_usage = 4
 934 0008 EC01      		movw r28,r24
 935 000a 062F      		mov r16,r22
 936               	.LVL97:
 937               	.L97:
 938               	.LBB40:
 939               	.LBB41:
 800:quantum/quantum.c ****         if (!ascii_code) break;
 940               		.loc 1 800 0
 941 000c FE01      		movw r30,r28
 942               	/* #APP */
 943               	 ;  800 "quantum/quantum.c" 1
 944 000e 8491      		lpm r24, Z
 945               		
 946               	 ;  0 "" 2
 947               	.LVL98:
 948               	/* #NOAPP */
 949               	.LBE41:
 801:quantum/quantum.c ****         if (ascii_code == SS_TAP_CODE) {
 950               		.loc 1 801 0
 951 0010 8823      		tst r24
 952 0012 01F0      		breq .L89
 953 0014 9E01      		movw r18,r28
 954 0016 2F5F      		subi r18,-1
 955 0018 3F4F      		sbci r19,-1
 802:quantum/quantum.c ****             // tap
 956               		.loc 1 802 0
 957 001a 8130      		cpi r24,lo8(1)
 958 001c 01F4      		brne .L91
 959               	.LBB42:
 960               	.LBB43:
 804:quantum/quantum.c ****             register_code(keycode);
 961               		.loc 1 804 0
 962 001e E901      		movw r28,r18
 963               	.LVL99:
 964 0020 F901      		movw r30,r18
 965               	.LVL100:
 966               	/* #APP */
 967               	 ;  804 "quantum/quantum.c" 1
 968 0022 1491      		lpm r17, Z
 969               		
 970               	 ;  0 "" 2
 971               	.LVL101:
 972               	/* #NOAPP */
 973               	.LBE43:
 805:quantum/quantum.c ****             unregister_code(keycode);
 974               		.loc 1 805 0
 975 0024 812F      		mov r24,r17
 976               	.LVL102:
 977 0026 0E94 0000 		call register_code
 978               	.LVL103:
 806:quantum/quantum.c ****         } else if (ascii_code == SS_DOWN_CODE) {
 979               		.loc 1 806 0
 980 002a 812F      		mov r24,r17
 981 002c 00C0      		rjmp .L98
 982               	.LVL104:
 983               	.L91:
 984               	.LBE42:
 807:quantum/quantum.c ****             // down
 985               		.loc 1 807 0
 986 002e 8230      		cpi r24,lo8(2)
 987 0030 01F4      		brne .L93
 988               	.LBB44:
 989               	.LBB45:
 809:quantum/quantum.c ****             register_code(keycode);
 990               		.loc 1 809 0
 991 0032 E901      		movw r28,r18
 992               	.LVL105:
 993 0034 F901      		movw r30,r18
 994               	.LVL106:
 995               	/* #APP */
 996               	 ;  809 "quantum/quantum.c" 1
 997 0036 8491      		lpm r24, Z
 998               		
 999               	 ;  0 "" 2
 1000               	.LVL107:
 1001               	/* #NOAPP */
 1002               	.LBE45:
 810:quantum/quantum.c ****         } else if (ascii_code == SS_UP_CODE) {
 1003               		.loc 1 810 0
 1004 0038 0E94 0000 		call register_code
 1005               	.LVL108:
 1006               	.LBE44:
 1007 003c 00C0      		rjmp .L92
 1008               	.LVL109:
 1009               	.L93:
 811:quantum/quantum.c ****             // up
 1010               		.loc 1 811 0
 1011 003e 8330      		cpi r24,lo8(3)
 1012 0040 01F4      		brne .L94
 1013               	.LBB46:
 1014               	.LBB47:
 813:quantum/quantum.c ****             unregister_code(keycode);
 1015               		.loc 1 813 0
 1016 0042 E901      		movw r28,r18
 1017               	.LVL110:
 1018 0044 F901      		movw r30,r18
 1019               	.LVL111:
 1020               	/* #APP */
 1021               	 ;  813 "quantum/quantum.c" 1
 1022 0046 8491      		lpm r24, Z
 1023               		
 1024               	 ;  0 "" 2
 1025               	.LVL112:
 1026               	/* #NOAPP */
 1027               	.L98:
 1028               	.LBE47:
 814:quantum/quantum.c ****         } else {
 1029               		.loc 1 814 0
 1030 0048 0E94 0000 		call unregister_code
 1031               	.LVL113:
 1032               	.LBE46:
 1033 004c 00C0      		rjmp .L92
 1034               	.LVL114:
 1035               	.L94:
 816:quantum/quantum.c ****         }
 1036               		.loc 1 816 0
 1037 004e 0E94 0000 		call send_char
 1038               	.LVL115:
 1039               	.L92:
 818:quantum/quantum.c ****         // interval
 1040               		.loc 1 818 0
 1041 0052 2196      		adiw r28,1
 1042               	.LVL116:
 1043               	.LBB48:
 822:quantum/quantum.c ****         }
 1044               		.loc 1 822 0
 1045 0054 802F      		mov r24,r16
 1046               	.LVL117:
 1047               	.L95:
 822:quantum/quantum.c ****         }
 1048               		.loc 1 822 0 is_stmt 0 discriminator 1
 1049 0056 8823      		tst r24
 1050 0058 01F0      		breq .L97
 1051               	.LVL118:
 1052               	.LBB49:
 1053               	.LBB50:
 1054               		.loc 3 163 0 is_stmt 1
 1055 005a EFE9      		ldi r30,lo8(3999)
 1056 005c FFE0      		ldi r31,hi8(3999)
 1057 005e 3197      	1:	sbiw r30,1
 1058 0060 01F4      		brne 1b
 1059 0062 00C0      		rjmp .
 1060 0064 0000      		nop
 1061 0066 8150      		subi r24,lo8(-(-1))
 1062               	.LVL119:
 1063 0068 00C0      		rjmp .L95
 1064               	.LVL120:
 1065               	.L89:
 1066               	/* epilogue start */
 1067               	.LBE50:
 1068               	.LBE49:
 1069               	.LBE48:
 1070               	.LBE40:
 825:quantum/quantum.c **** 
 1071               		.loc 1 825 0
 1072 006a DF91      		pop r29
 1073 006c CF91      		pop r28
 1074               	.LVL121:
 1075 006e 1F91      		pop r17
 1076 0070 0F91      		pop r16
 1077               	.LVL122:
 1078 0072 0895      		ret
 1079               		.cfi_endproc
 1080               	.LFE44:
 1082               		.section	.text.send_string_P,"ax",@progbits
 1083               	.global	send_string_P
 1085               	send_string_P:
 1086               	.LFB42:
 767:quantum/quantum.c **** 
 1087               		.loc 1 767 0
 1088               		.cfi_startproc
 1089               	.LVL123:
 1090               	/* prologue: function */
 1091               	/* frame size = 0 */
 1092               	/* stack size = 0 */
 1093               	.L__stack_usage = 0
 767:quantum/quantum.c **** 
 1094               		.loc 1 767 0
 1095 0000 60E0      		ldi r22,0
 1096 0002 0C94 0000 		jmp send_string_with_delay_P
 1097               	.LVL124:
 1098               		.cfi_endproc
 1099               	.LFE42:
 1101               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1102               	.global	set_single_persistent_default_layer
 1104               	set_single_persistent_default_layer:
 1105               	.LFB46:
 846:quantum/quantum.c **** 
 847:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1106               		.loc 1 847 0
 1107               		.cfi_startproc
 1108               	.LVL125:
 1109 0000 CF93      		push r28
 1110               	.LCFI23:
 1111               		.cfi_def_cfa_offset 3
 1112               		.cfi_offset 28, -2
 1113 0002 DF93      		push r29
 1114               	.LCFI24:
 1115               		.cfi_def_cfa_offset 4
 1116               		.cfi_offset 29, -3
 1117               	/* prologue: function */
 1118               	/* frame size = 0 */
 1119               	/* stack size = 2 */
 1120               	.L__stack_usage = 2
 848:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 849:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 850:quantum/quantum.c **** #endif
 851:quantum/quantum.c ****     eeconfig_update_default_layer(1U << default_layer);
 1121               		.loc 1 851 0
 1122 0004 61E0      		ldi r22,lo8(1)
 1123 0006 70E0      		ldi r23,0
 1124 0008 EB01      		movw r28,r22
 1125 000a 00C0      		rjmp 2f
 1126               		1:
 1127 000c CC0F      		lsl r28
 1128 000e DD1F      		rol r29
 1129               		2:
 1130 0010 8A95      		dec r24
 1131 0012 02F4      		brpl 1b
 1132 0014 8C2F      		mov r24,r28
 1133               	.LVL126:
 1134 0016 0E94 0000 		call eeconfig_update_default_layer
 1135               	.LVL127:
 852:quantum/quantum.c ****     default_layer_set(1U << default_layer);
 1136               		.loc 1 852 0
 1137 001a BE01      		movw r22,r28
 1138 001c 80E0      		ldi r24,0
 1139 001e 90E0      		ldi r25,0
 1140               	/* epilogue start */
 853:quantum/quantum.c **** }
 1141               		.loc 1 853 0
 1142 0020 DF91      		pop r29
 1143 0022 CF91      		pop r28
 852:quantum/quantum.c ****     default_layer_set(1U << default_layer);
 1144               		.loc 1 852 0
 1145 0024 0C94 0000 		jmp default_layer_set
 1146               	.LVL128:
 1147               		.cfi_endproc
 1148               	.LFE46:
 1150               		.section	.text.update_tri_layer_state,"ax",@progbits
 1151               	.global	update_tri_layer_state
 1153               	update_tri_layer_state:
 1154               	.LFB47:
 854:quantum/quantum.c **** 
 855:quantum/quantum.c **** layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t l
 1155               		.loc 1 855 0
 1156               		.cfi_startproc
 1157               	.LVL129:
 1158 0000 8F92      		push r8
 1159               	.LCFI25:
 1160               		.cfi_def_cfa_offset 3
 1161               		.cfi_offset 8, -2
 1162 0002 9F92      		push r9
 1163               	.LCFI26:
 1164               		.cfi_def_cfa_offset 4
 1165               		.cfi_offset 9, -3
 1166 0004 AF92      		push r10
 1167               	.LCFI27:
 1168               		.cfi_def_cfa_offset 5
 1169               		.cfi_offset 10, -4
 1170 0006 BF92      		push r11
 1171               	.LCFI28:
 1172               		.cfi_def_cfa_offset 6
 1173               		.cfi_offset 11, -5
 1174 0008 CF92      		push r12
 1175               	.LCFI29:
 1176               		.cfi_def_cfa_offset 7
 1177               		.cfi_offset 12, -6
 1178 000a DF92      		push r13
 1179               	.LCFI30:
 1180               		.cfi_def_cfa_offset 8
 1181               		.cfi_offset 13, -7
 1182 000c EF92      		push r14
 1183               	.LCFI31:
 1184               		.cfi_def_cfa_offset 9
 1185               		.cfi_offset 14, -8
 1186 000e FF92      		push r15
 1187               	.LCFI32:
 1188               		.cfi_def_cfa_offset 10
 1189               		.cfi_offset 15, -9
 1190 0010 0F93      		push r16
 1191               	.LCFI33:
 1192               		.cfi_def_cfa_offset 11
 1193               		.cfi_offset 16, -10
 1194 0012 1F93      		push r17
 1195               	.LCFI34:
 1196               		.cfi_def_cfa_offset 12
 1197               		.cfi_offset 17, -11
 1198               	/* prologue: function */
 1199               	/* frame size = 0 */
 1200               	/* stack size = 10 */
 1201               	.L__stack_usage = 10
 1202 0014 6B01      		movw r12,r22
 1203 0016 7C01      		movw r14,r24
 856:quantum/quantum.c ****     layer_state_t mask12 = (1UL << layer1) | (1UL << layer2);
 1204               		.loc 1 856 0
 1205 0018 81E0      		ldi r24,lo8(1)
 1206 001a 90E0      		ldi r25,0
 1207 001c A0E0      		ldi r26,0
 1208 001e B0E0      		ldi r27,0
 1209 0020 4C01      		movw r8,r24
 1210 0022 5D01      		movw r10,r26
 1211 0024 00C0      		rjmp 2f
 1212               		1:
 1213 0026 880C      		lsl r8
 1214 0028 991C      		rol r9
 1215 002a AA1C      		rol r10
 1216 002c BB1C      		rol r11
 1217               		2:
 1218 002e 4A95      		dec r20
 1219 0030 02F4      		brpl 1b
 1220 0032 AC01      		movw r20,r24
 1221 0034 BD01      		movw r22,r26
 1222               	.LVL130:
 1223 0036 00C0      		rjmp 2f
 1224               		1:
 1225 0038 440F      		lsl r20
 1226 003a 551F      		rol r21
 1227 003c 661F      		rol r22
 1228 003e 771F      		rol r23
 1229               		2:
 1230 0040 2A95      		dec r18
 1231 0042 02F4      		brpl 1b
 1232 0044 4829      		or r20,r8
 1233 0046 5929      		or r21,r9
 1234 0048 6A29      		or r22,r10
 1235 004a 7B29      		or r23,r11
 1236               	.LVL131:
 857:quantum/quantum.c ****     layer_state_t mask3  = 1UL << layer3;
 1237               		.loc 1 857 0
 1238 004c 00C0      		rjmp 2f
 1239               		1:
 1240 004e 880F      		lsl r24
 1241 0050 991F      		rol r25
 1242 0052 AA1F      		rol r26
 1243 0054 BB1F      		rol r27
 1244               		2:
 1245 0056 0A95      		dec r16
 1246 0058 02F4      		brpl 1b
 1247               	.LVL132:
 858:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1248               		.loc 1 858 0
 1249 005a 8A01      		movw r16,r20
 1250 005c 9B01      		movw r18,r22
 1251               	.LVL133:
 1252 005e 0C21      		and r16,r12
 1253 0060 1D21      		and r17,r13
 1254 0062 2E21      		and r18,r14
 1255 0064 3F21      		and r19,r15
 1256 0066 0417      		cp r16,r20
 1257 0068 1507      		cpc r17,r21
 1258 006a 2607      		cpc r18,r22
 1259 006c 3707      		cpc r19,r23
 1260 006e 01F4      		brne .L102
 1261               		.loc 1 858 0 is_stmt 0 discriminator 1
 1262 0070 BC01      		movw r22,r24
 1263 0072 CD01      		movw r24,r26
 1264               	.LVL134:
 1265 0074 6C29      		or r22,r12
 1266 0076 7D29      		or r23,r13
 1267 0078 8E29      		or r24,r14
 1268 007a 9F29      		or r25,r15
 1269 007c 00C0      		rjmp .L103
 1270               	.L102:
 1271               		.loc 1 858 0 discriminator 2
 1272 007e 8095      		com r24
 1273 0080 9095      		com r25
 1274 0082 A095      		com r26
 1275 0084 B095      		com r27
 1276               	.LVL135:
 1277 0086 BC01      		movw r22,r24
 1278 0088 CD01      		movw r24,r26
 1279 008a 6C21      		and r22,r12
 1280 008c 7D21      		and r23,r13
 1281 008e 8E21      		and r24,r14
 1282 0090 9F21      		and r25,r15
 1283               	.LVL136:
 1284               	.L103:
 1285               	/* epilogue start */
 859:quantum/quantum.c **** }
 1286               		.loc 1 859 0 is_stmt 1 discriminator 4
 1287 0092 1F91      		pop r17
 1288 0094 0F91      		pop r16
 1289 0096 FF90      		pop r15
 1290 0098 EF90      		pop r14
 1291 009a DF90      		pop r13
 1292 009c CF90      		pop r12
 1293               	.LVL137:
 1294 009e BF90      		pop r11
 1295 00a0 AF90      		pop r10
 1296 00a2 9F90      		pop r9
 1297 00a4 8F90      		pop r8
 1298 00a6 0895      		ret
 1299               		.cfi_endproc
 1300               	.LFE47:
 1302               		.section	.text.update_tri_layer,"ax",@progbits
 1303               	.global	update_tri_layer
 1305               	update_tri_layer:
 1306               	.LFB48:
 860:quantum/quantum.c **** 
 861:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) { layer_state_set(update_tri_
 1307               		.loc 1 861 0
 1308               		.cfi_startproc
 1309               	.LVL138:
 1310 0000 0F93      		push r16
 1311               	.LCFI35:
 1312               		.cfi_def_cfa_offset 3
 1313               		.cfi_offset 16, -2
 1314               	/* prologue: function */
 1315               	/* frame size = 0 */
 1316               	/* stack size = 1 */
 1317               	.L__stack_usage = 1
 1318 0002 382F      		mov r19,r24
 1319 0004 262F      		mov r18,r22
 1320               		.loc 1 861 0
 1321 0006 6091 0000 		lds r22,layer_state
 1322 000a 7091 0000 		lds r23,layer_state+1
 1323 000e 8091 0000 		lds r24,layer_state+2
 1324 0012 9091 0000 		lds r25,layer_state+3
 1325               	.LVL139:
 1326 0016 042F      		mov r16,r20
 1327 0018 432F      		mov r20,r19
 1328               	.LVL140:
 1329 001a 0E94 0000 		call update_tri_layer_state
 1330               	.LVL141:
 1331               	/* epilogue start */
 1332 001e 0F91      		pop r16
 1333               	.LVL142:
 1334 0020 0C94 0000 		jmp layer_state_set
 1335               	.LVL143:
 1336               		.cfi_endproc
 1337               	.LFE48:
 1339               		.section	.text.tap_random_base64,"ax",@progbits
 1340               	.global	tap_random_base64
 1342               	tap_random_base64:
 1343               	.LFB49:
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void tap_random_base64(void) {
 1344               		.loc 1 863 0
 1345               		.cfi_startproc
 1346 0000 CF93      		push r28
 1347               	.LCFI36:
 1348               		.cfi_def_cfa_offset 3
 1349               		.cfi_offset 28, -2
 1350 0002 DF93      		push r29
 1351               	.LCFI37:
 1352               		.cfi_def_cfa_offset 4
 1353               		.cfi_offset 29, -3
 1354               	/* prologue: function */
 1355               	/* frame size = 0 */
 1356               	/* stack size = 2 */
 1357               	.L__stack_usage = 2
 864:quantum/quantum.c **** #if defined(__AVR_ATmega32U4__)
 865:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1358               		.loc 1 865 0
 1359 0004 26B5      		in r18,0x26
 1360 0006 C091 8400 		lds r28,132
 1361 000a D091 8500 		lds r29,132+1
 1362 000e 4091 9400 		lds r20,148
 1363 0012 5091 9500 		lds r21,148+1
 1364 0016 8091 BE00 		lds r24,190
 1365 001a 9091 BF00 		lds r25,190+1
 1366 001e C40F      		add r28,r20
 1367 0020 C20F      		add r28,r18
 1368 0022 8C0F      		add r24,r28
 1369 0024 C82F      		mov r28,r24
 1370 0026 CF73      		andi r28,lo8(63)
 1371               	.LVL144:
 866:quantum/quantum.c **** #else
 867:quantum/quantum.c ****     uint8_t key = rand() % 64;
 868:quantum/quantum.c **** #endif
 869:quantum/quantum.c ****     switch (key) {
 1372               		.loc 1 869 0
 1373 0028 CE33      		cpi r28,lo8(62)
 1374 002a 00F4      		brsh .L107
 1375 002c C533      		cpi r28,lo8(53)
 1376 002e 00F4      		brsh .L108
 1377 0030 CA31      		cpi r28,lo8(26)
 1378 0032 00F0      		brlo .L106
 1379 0034 C433      		cpi r28,lo8(52)
 1380 0036 00F4      		brsh .L113
 870:quantum/quantum.c ****         case 0 ... 25:
 871:quantum/quantum.c ****             register_code(KC_LSFT);
 872:quantum/quantum.c ****             register_code(key + KC_A);
 873:quantum/quantum.c ****             unregister_code(key + KC_A);
 874:quantum/quantum.c ****             unregister_code(KC_LSFT);
 875:quantum/quantum.c ****             break;
 876:quantum/quantum.c ****         case 26 ... 51:
 877:quantum/quantum.c ****             register_code(key - 26 + KC_A);
 1381               		.loc 1 877 0
 1382 0038 C651      		subi r28,lo8(-(-22))
 1383               	.LVL145:
 1384 003a 00C0      		rjmp .L116
 1385               	.LVL146:
 1386               	.L107:
 869:quantum/quantum.c ****         case 0 ... 25:
 1387               		.loc 1 869 0
 1388 003c CE33      		cpi r28,lo8(62)
 1389 003e 01F0      		breq .L111
 1390 0040 CF33      		cpi r28,lo8(63)
 1391 0042 01F0      		breq .L112
 1392               	.L106:
 871:quantum/quantum.c ****             register_code(key + KC_A);
 1393               		.loc 1 871 0
 1394 0044 81EE      		ldi r24,lo8(-31)
 1395 0046 0E94 0000 		call register_code
 1396               	.LVL147:
 872:quantum/quantum.c ****             unregister_code(key + KC_A);
 1397               		.loc 1 872 0
 1398 004a CC5F      		subi r28,lo8(-(4))
 1399               	.LVL148:
 1400 004c 8C2F      		mov r24,r28
 1401 004e 0E94 0000 		call register_code
 1402               	.LVL149:
 873:quantum/quantum.c ****             unregister_code(KC_LSFT);
 1403               		.loc 1 873 0
 1404 0052 8C2F      		mov r24,r28
 1405 0054 00C0      		rjmp .L115
 1406               	.LVL150:
 1407               	.L113:
 878:quantum/quantum.c ****             unregister_code(key - 26 + KC_A);
 879:quantum/quantum.c ****             break;
 880:quantum/quantum.c ****         case 52:
 881:quantum/quantum.c ****             register_code(KC_0);
 1408               		.loc 1 881 0
 1409 0056 87E2      		ldi r24,lo8(39)
 1410 0058 0E94 0000 		call register_code
 1411               	.LVL151:
 882:quantum/quantum.c ****             unregister_code(KC_0);
 1412               		.loc 1 882 0
 1413 005c 87E2      		ldi r24,lo8(39)
 1414 005e 00C0      		rjmp .L114
 1415               	.L108:
 883:quantum/quantum.c ****             break;
 884:quantum/quantum.c ****         case 53 ... 61:
 885:quantum/quantum.c ****             register_code(key - 53 + KC_1);
 1416               		.loc 1 885 0
 1417 0060 C751      		subi r28,lo8(-(-23))
 1418               	.LVL152:
 1419               	.L116:
 1420 0062 8C2F      		mov r24,r28
 1421               	.LVL153:
 1422 0064 0E94 0000 		call register_code
 1423               	.LVL154:
 886:quantum/quantum.c ****             unregister_code(key - 53 + KC_1);
 1424               		.loc 1 886 0
 1425 0068 8C2F      		mov r24,r28
 1426 006a 00C0      		rjmp .L114
 1427               	.LVL155:
 1428               	.L111:
 887:quantum/quantum.c ****             break;
 888:quantum/quantum.c ****         case 62:
 889:quantum/quantum.c ****             register_code(KC_LSFT);
 1429               		.loc 1 889 0
 1430 006c 81EE      		ldi r24,lo8(-31)
 1431 006e 0E94 0000 		call register_code
 1432               	.LVL156:
 890:quantum/quantum.c ****             register_code(KC_EQL);
 1433               		.loc 1 890 0
 1434 0072 8EE2      		ldi r24,lo8(46)
 1435 0074 0E94 0000 		call register_code
 1436               	.LVL157:
 891:quantum/quantum.c ****             unregister_code(KC_EQL);
 1437               		.loc 1 891 0
 1438 0078 8EE2      		ldi r24,lo8(46)
 1439               	.LVL158:
 1440               	.L115:
 1441 007a 0E94 0000 		call unregister_code
 1442               	.LVL159:
 892:quantum/quantum.c ****             unregister_code(KC_LSFT);
 1443               		.loc 1 892 0
 1444 007e 81EE      		ldi r24,lo8(-31)
 1445 0080 00C0      		rjmp .L114
 1446               	.LVL160:
 1447               	.L112:
 893:quantum/quantum.c ****             break;
 894:quantum/quantum.c ****         case 63:
 895:quantum/quantum.c ****             register_code(KC_SLSH);
 1448               		.loc 1 895 0
 1449 0082 88E3      		ldi r24,lo8(56)
 1450 0084 0E94 0000 		call register_code
 1451               	.LVL161:
 896:quantum/quantum.c ****             unregister_code(KC_SLSH);
 1452               		.loc 1 896 0
 1453 0088 88E3      		ldi r24,lo8(56)
 1454               	.LVL162:
 1455               	.L114:
 1456               	/* epilogue start */
 897:quantum/quantum.c ****             break;
 898:quantum/quantum.c ****     }
 899:quantum/quantum.c **** }
 1457               		.loc 1 899 0
 1458 008a DF91      		pop r29
 1459 008c CF91      		pop r28
 896:quantum/quantum.c ****             unregister_code(KC_SLSH);
 1460               		.loc 1 896 0
 1461 008e 0C94 0000 		jmp unregister_code
 1462               	.LVL163:
 1463               		.cfi_endproc
 1464               	.LFE49:
 1466               		.section	.text.bootmagic_lite,"ax",@progbits
 1467               		.weak	bootmagic_lite
 1469               	bootmagic_lite:
 1470               	.LFB50:
 900:quantum/quantum.c **** 
 901:quantum/quantum.c **** __attribute__((weak)) void bootmagic_lite(void) {
 1471               		.loc 1 901 0
 1472               		.cfi_startproc
 1473               	/* prologue: function */
 1474               	/* frame size = 0 */
 1475               	/* stack size = 0 */
 1476               	.L__stack_usage = 0
 902:quantum/quantum.c ****     // The lite version of TMK's bootmagic based on Wilba.
 903:quantum/quantum.c ****     // 100% less potential for accidentally making the
 904:quantum/quantum.c ****     // keyboard do stupid things.
 905:quantum/quantum.c **** 
 906:quantum/quantum.c ****     // We need multiple scans because debouncing can't be turned off.
 907:quantum/quantum.c ****     matrix_scan();
 1477               		.loc 1 907 0
 1478 0000 0E94 0000 		call matrix_scan
 1479               	.LVL164:
 1480               	.LBB51:
 1481               	.LBB52:
 1482               		.loc 3 163 0
 1483 0004 2FEF      		ldi r18,lo8(95999)
 1484 0006 86E7      		ldi r24,hi8(95999)
 1485 0008 91E0      		ldi r25,hlo8(95999)
 1486 000a 2150      	1:	subi r18,1
 1487 000c 8040      		sbci r24,0
 1488 000e 9040      		sbci r25,0
 1489 0010 01F4      		brne 1b
 1490 0012 00C0      		rjmp .
 1491 0014 0000      		nop
 1492               	.LBE52:
 1493               	.LBE51:
 908:quantum/quantum.c **** #if defined(DEBOUNCING_DELAY) && DEBOUNCING_DELAY > 0
 909:quantum/quantum.c ****     wait_ms(DEBOUNCING_DELAY * 2);
 910:quantum/quantum.c **** #elif defined(DEBOUNCE) && DEBOUNCE > 0
 911:quantum/quantum.c ****     wait_ms(DEBOUNCE * 2);
 912:quantum/quantum.c **** #else
 913:quantum/quantum.c ****     wait_ms(30);
 914:quantum/quantum.c **** #endif
 915:quantum/quantum.c ****     matrix_scan();
 1494               		.loc 1 915 0
 1495 0016 0E94 0000 		call matrix_scan
 1496               	.LVL165:
 916:quantum/quantum.c **** 
 917:quantum/quantum.c ****     // If the Esc and space bar are held down on power up,
 918:quantum/quantum.c ****     // reset the EEPROM valid state and jump to bootloader.
 919:quantum/quantum.c ****     // Assumes Esc is at [0,0].
 920:quantum/quantum.c ****     // This isn't very generalized, but we need something that doesn't
 921:quantum/quantum.c ****     // rely on user's keymaps in firmware or EEPROM.
 922:quantum/quantum.c ****     if (matrix_get_row(BOOTMAGIC_LITE_ROW) & (1 << BOOTMAGIC_LITE_COLUMN)) {
 1497               		.loc 1 922 0
 1498 001a 80E0      		ldi r24,0
 1499 001c 0E94 0000 		call matrix_get_row
 1500               	.LVL166:
 1501 0020 80FF      		sbrs r24,0
 1502 0022 00C0      		rjmp .L117
 923:quantum/quantum.c ****         eeconfig_disable();
 1503               		.loc 1 923 0
 1504 0024 0E94 0000 		call eeconfig_disable
 1505               	.LVL167:
 924:quantum/quantum.c ****         // Jump to bootloader.
 925:quantum/quantum.c ****         bootloader_jump();
 1506               		.loc 1 925 0
 1507 0028 0C94 0000 		jmp bootloader_jump
 1508               	.LVL168:
 1509               	.L117:
 1510 002c 0895      		ret
 1511               		.cfi_endproc
 1512               	.LFE50:
 1514               		.section	.text.matrix_init_quantum,"ax",@progbits
 1515               	.global	matrix_init_quantum
 1517               	matrix_init_quantum:
 1518               	.LFB51:
 926:quantum/quantum.c ****     }
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** void matrix_init_quantum() {
 1519               		.loc 1 929 0
 1520               		.cfi_startproc
 1521               	/* prologue: function */
 1522               	/* frame size = 0 */
 1523               	/* stack size = 0 */
 1524               	.L__stack_usage = 0
 930:quantum/quantum.c **** #ifdef BOOTMAGIC_LITE
 931:quantum/quantum.c ****     bootmagic_lite();
 1525               		.loc 1 931 0
 1526 0000 0E94 0000 		call bootmagic_lite
 1527               	.LVL169:
 932:quantum/quantum.c **** #endif
 933:quantum/quantum.c ****     if (!eeconfig_is_enabled()) {
 1528               		.loc 1 933 0
 1529 0004 0E94 0000 		call eeconfig_is_enabled
 1530               	.LVL170:
 1531 0008 8111      		cpse r24,__zero_reg__
 1532 000a 00C0      		rjmp .L120
 934:quantum/quantum.c ****         eeconfig_init();
 1533               		.loc 1 934 0
 1534 000c 0E94 0000 		call eeconfig_init
 1535               	.LVL171:
 1536               	.L120:
 935:quantum/quantum.c ****     }
 936:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
 937:quantum/quantum.c **** #    ifdef LED_MATRIX_ENABLE
 938:quantum/quantum.c ****     led_matrix_init();
 939:quantum/quantum.c **** #    else
 940:quantum/quantum.c ****     backlight_init_ports();
 1537               		.loc 1 940 0
 1538 0010 0E94 0000 		call backlight_init_ports
 1539               	.LVL172:
 941:quantum/quantum.c **** #    endif
 942:quantum/quantum.c **** #endif
 943:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 944:quantum/quantum.c ****     audio_init();
 945:quantum/quantum.c **** #endif
 946:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 947:quantum/quantum.c ****     rgb_matrix_init();
 948:quantum/quantum.c **** #endif
 949:quantum/quantum.c **** #ifdef ENCODER_ENABLE
 950:quantum/quantum.c ****     encoder_init();
 951:quantum/quantum.c **** #endif
 952:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 953:quantum/quantum.c ****     unicode_input_mode_init();
 954:quantum/quantum.c **** #endif
 955:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 956:quantum/quantum.c ****     haptic_init();
 957:quantum/quantum.c **** #endif
 958:quantum/quantum.c **** #ifdef OUTPUT_AUTO_ENABLE
 959:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 960:quantum/quantum.c **** #endif
 961:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
 962:quantum/quantum.c ****     dip_switch_init();
 963:quantum/quantum.c **** #endif
 964:quantum/quantum.c **** 
 965:quantum/quantum.c ****     matrix_init_kb();
 1540               		.loc 1 965 0
 1541 0014 0C94 0000 		jmp matrix_init_kb
 1542               	.LVL173:
 1543               		.cfi_endproc
 1544               	.LFE51:
 1546               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1547               	.global	matrix_scan_quantum
 1549               	matrix_scan_quantum:
 1550               	.LFB52:
 966:quantum/quantum.c **** }
 967:quantum/quantum.c **** 
 968:quantum/quantum.c **** void matrix_scan_quantum() {
 1551               		.loc 1 968 0
 1552               		.cfi_startproc
 1553               	/* prologue: function */
 1554               	/* frame size = 0 */
 1555               	/* stack size = 0 */
 1556               	.L__stack_usage = 0
 969:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 970:quantum/quantum.c ****     matrix_scan_music();
 971:quantum/quantum.c **** #endif
 972:quantum/quantum.c **** 
 973:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 974:quantum/quantum.c ****     matrix_scan_tap_dance();
 1557               		.loc 1 974 0
 1558 0000 0E94 0000 		call matrix_scan_tap_dance
 1559               	.LVL174:
 975:quantum/quantum.c **** #endif
 976:quantum/quantum.c **** 
 977:quantum/quantum.c **** #ifdef COMBO_ENABLE
 978:quantum/quantum.c ****     matrix_scan_combo();
 979:quantum/quantum.c **** #endif
 980:quantum/quantum.c **** 
 981:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE)
 982:quantum/quantum.c **** #    if defined(LED_MATRIX_ENABLE)
 983:quantum/quantum.c ****     led_matrix_task();
 984:quantum/quantum.c **** #    elif defined(BACKLIGHT_PIN) || defined(BACKLIGHT_PINS)
 985:quantum/quantum.c ****     backlight_task();
 1560               		.loc 1 985 0
 1561 0004 0E94 0000 		call backlight_task
 1562               	.LVL175:
 986:quantum/quantum.c **** #    endif
 987:quantum/quantum.c **** #endif
 988:quantum/quantum.c **** 
 989:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 990:quantum/quantum.c ****     rgb_matrix_task();
 991:quantum/quantum.c **** #endif
 992:quantum/quantum.c **** 
 993:quantum/quantum.c **** #ifdef ENCODER_ENABLE
 994:quantum/quantum.c ****     encoder_read();
 995:quantum/quantum.c **** #endif
 996:quantum/quantum.c **** 
 997:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 998:quantum/quantum.c ****     haptic_task();
 999:quantum/quantum.c **** #endif
1000:quantum/quantum.c **** 
1001:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
1002:quantum/quantum.c ****     dip_switch_read(false);
1003:quantum/quantum.c **** #endif
1004:quantum/quantum.c **** 
1005:quantum/quantum.c ****     matrix_scan_kb();
 1563               		.loc 1 1005 0
 1564 0008 0C94 0000 		jmp matrix_scan_kb
 1565               	.LVL176:
 1566               		.cfi_endproc
 1567               	.LFE52:
 1569               		.section	.text.send_nibble,"ax",@progbits
 1570               	.global	send_nibble
 1572               	send_nibble:
 1573               	.LFB56:
1006:quantum/quantum.c **** }
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef HD44780_ENABLED
1009:quantum/quantum.c **** #    include "hd44780.h"
1010:quantum/quantum.c **** #endif
1011:quantum/quantum.c **** 
1012:quantum/quantum.c **** // Functions for spitting out values
1013:quantum/quantum.c **** //
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** void send_dword(uint32_t number) {  // this might not actually work
1016:quantum/quantum.c ****     uint16_t word = (number >> 16);
1017:quantum/quantum.c ****     send_word(word);
1018:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1019:quantum/quantum.c **** }
1020:quantum/quantum.c **** 
1021:quantum/quantum.c **** void send_word(uint16_t number) {
1022:quantum/quantum.c ****     uint8_t byte = number >> 8;
1023:quantum/quantum.c ****     send_byte(byte);
1024:quantum/quantum.c ****     send_byte(number & 0xFF);
1025:quantum/quantum.c **** }
1026:quantum/quantum.c **** 
1027:quantum/quantum.c **** void send_byte(uint8_t number) {
1028:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1029:quantum/quantum.c ****     send_nibble(nibble);
1030:quantum/quantum.c ****     send_nibble(number & 0xF);
1031:quantum/quantum.c **** }
1032:quantum/quantum.c **** 
1033:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1574               		.loc 1 1033 0
 1575               		.cfi_startproc
 1576               	.LVL177:
 1577 0000 CF93      		push r28
 1578               	.LCFI38:
 1579               		.cfi_def_cfa_offset 3
 1580               		.cfi_offset 28, -2
 1581               	/* prologue: function */
 1582               	/* frame size = 0 */
 1583               	/* stack size = 1 */
 1584               	.L__stack_usage = 1
1034:quantum/quantum.c ****     switch (number) {
 1585               		.loc 1 1034 0
 1586 0002 8A30      		cpi r24,lo8(10)
 1587 0004 00F4      		brsh .L124
 1588 0006 8130      		cpi r24,lo8(1)
 1589 0008 00F4      		brsh .L132
1035:quantum/quantum.c ****         case 0:
1036:quantum/quantum.c ****             register_code(KC_0);
 1590               		.loc 1 1036 0
 1591 000a 87E2      		ldi r24,lo8(39)
 1592               	.LVL178:
 1593 000c 0E94 0000 		call register_code
 1594               	.LVL179:
1037:quantum/quantum.c ****             unregister_code(KC_0);
 1595               		.loc 1 1037 0
 1596 0010 87E2      		ldi r24,lo8(39)
 1597 0012 00C0      		rjmp .L130
 1598               	.LVL180:
 1599               	.L124:
1034:quantum/quantum.c ****     switch (number) {
 1600               		.loc 1 1034 0
 1601 0014 8031      		cpi r24,lo8(16)
 1602 0016 00F4      		brsh .L133
1038:quantum/quantum.c ****             break;
1039:quantum/quantum.c ****         case 1 ... 9:
1040:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1041:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1042:quantum/quantum.c ****             break;
1043:quantum/quantum.c ****         case 0xA ... 0xF:
1044:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 1603               		.loc 1 1044 0
 1604 0018 CAEF      		ldi r28,lo8(-6)
 1605 001a 00C0      		rjmp .L131
 1606               	.L132:
1040:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 1607               		.loc 1 1040 0
 1608 001c CDE1      		ldi r28,lo8(29)
 1609               	.L131:
 1610               		.loc 1 1044 0
 1611 001e C80F      		add r28,r24
 1612 0020 8C2F      		mov r24,r28
 1613               	.LVL181:
 1614 0022 0E94 0000 		call register_code
 1615               	.LVL182:
1045:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1616               		.loc 1 1045 0
 1617 0026 8C2F      		mov r24,r28
 1618               	.L130:
 1619               	/* epilogue start */
1046:quantum/quantum.c ****             break;
1047:quantum/quantum.c ****     }
1048:quantum/quantum.c **** }
 1620               		.loc 1 1048 0
 1621 0028 CF91      		pop r28
1045:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 1622               		.loc 1 1045 0
 1623 002a 0C94 0000 		jmp unregister_code
 1624               	.LVL183:
 1625               	.L133:
 1626               	/* epilogue start */
 1627               		.loc 1 1048 0
 1628 002e CF91      		pop r28
 1629 0030 0895      		ret
 1630               		.cfi_endproc
 1631               	.LFE56:
 1633               		.section	.text.send_byte,"ax",@progbits
 1634               	.global	send_byte
 1636               	send_byte:
 1637               	.LFB55:
1027:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 1638               		.loc 1 1027 0
 1639               		.cfi_startproc
 1640               	.LVL184:
 1641 0000 CF93      		push r28
 1642               	.LCFI39:
 1643               		.cfi_def_cfa_offset 3
 1644               		.cfi_offset 28, -2
 1645               	/* prologue: function */
 1646               	/* frame size = 0 */
 1647               	/* stack size = 1 */
 1648               	.L__stack_usage = 1
 1649 0002 C82F      		mov r28,r24
 1650               	.LVL185:
1029:quantum/quantum.c ****     send_nibble(number & 0xF);
 1651               		.loc 1 1029 0
 1652 0004 8295      		swap r24
 1653               	.LVL186:
 1654 0006 8F70      		andi r24,lo8(15)
 1655 0008 0E94 0000 		call send_nibble
 1656               	.LVL187:
1030:quantum/quantum.c **** }
 1657               		.loc 1 1030 0
 1658 000c 8C2F      		mov r24,r28
 1659 000e 8F70      		andi r24,lo8(15)
 1660               	/* epilogue start */
1031:quantum/quantum.c **** 
 1661               		.loc 1 1031 0
 1662 0010 CF91      		pop r28
 1663               	.LVL188:
1030:quantum/quantum.c **** }
 1664               		.loc 1 1030 0
 1665 0012 0C94 0000 		jmp send_nibble
 1666               	.LVL189:
 1667               		.cfi_endproc
 1668               	.LFE55:
 1670               		.section	.text.send_word,"ax",@progbits
 1671               	.global	send_word
 1673               	send_word:
 1674               	.LFB54:
1021:quantum/quantum.c ****     uint8_t byte = number >> 8;
 1675               		.loc 1 1021 0
 1676               		.cfi_startproc
 1677               	.LVL190:
 1678 0000 CF93      		push r28
 1679               	.LCFI40:
 1680               		.cfi_def_cfa_offset 3
 1681               		.cfi_offset 28, -2
 1682               	/* prologue: function */
 1683               	/* frame size = 0 */
 1684               	/* stack size = 1 */
 1685               	.L__stack_usage = 1
 1686 0002 C82F      		mov r28,r24
 1687               	.LVL191:
1023:quantum/quantum.c ****     send_byte(number & 0xFF);
 1688               		.loc 1 1023 0
 1689 0004 892F      		mov r24,r25
 1690               	.LVL192:
 1691 0006 0E94 0000 		call send_byte
 1692               	.LVL193:
1024:quantum/quantum.c **** }
 1693               		.loc 1 1024 0
 1694 000a 8C2F      		mov r24,r28
 1695               	/* epilogue start */
1025:quantum/quantum.c **** 
 1696               		.loc 1 1025 0
 1697 000c CF91      		pop r28
1024:quantum/quantum.c **** }
 1698               		.loc 1 1024 0
 1699 000e 0C94 0000 		jmp send_byte
 1700               	.LVL194:
 1701               		.cfi_endproc
 1702               	.LFE54:
 1704               		.section	.text.send_dword,"ax",@progbits
 1705               	.global	send_dword
 1707               	send_dword:
 1708               	.LFB53:
1015:quantum/quantum.c ****     uint16_t word = (number >> 16);
 1709               		.loc 1 1015 0
 1710               		.cfi_startproc
 1711               	.LVL195:
 1712 0000 CF92      		push r12
 1713               	.LCFI41:
 1714               		.cfi_def_cfa_offset 3
 1715               		.cfi_offset 12, -2
 1716 0002 DF92      		push r13
 1717               	.LCFI42:
 1718               		.cfi_def_cfa_offset 4
 1719               		.cfi_offset 13, -3
 1720 0004 EF92      		push r14
 1721               	.LCFI43:
 1722               		.cfi_def_cfa_offset 5
 1723               		.cfi_offset 14, -4
 1724 0006 FF92      		push r15
 1725               	.LCFI44:
 1726               		.cfi_def_cfa_offset 6
 1727               		.cfi_offset 15, -5
 1728               	/* prologue: function */
 1729               	/* frame size = 0 */
 1730               	/* stack size = 4 */
 1731               	.L__stack_usage = 4
 1732 0008 6B01      		movw r12,r22
 1733 000a 7C01      		movw r14,r24
 1734               	.LVL196:
1017:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 1735               		.loc 1 1017 0
 1736 000c C701      		movw r24,r14
 1737 000e 0E94 0000 		call send_word
 1738               	.LVL197:
1018:quantum/quantum.c **** }
 1739               		.loc 1 1018 0
 1740 0012 C601      		movw r24,r12
 1741               	/* epilogue start */
1019:quantum/quantum.c **** 
 1742               		.loc 1 1019 0
 1743 0014 FF90      		pop r15
 1744 0016 EF90      		pop r14
 1745 0018 DF90      		pop r13
 1746 001a CF90      		pop r12
 1747               	.LVL198:
1018:quantum/quantum.c **** }
 1748               		.loc 1 1018 0
 1749 001c 0C94 0000 		jmp send_word
 1750               	.LVL199:
 1751               		.cfi_endproc
 1752               	.LFE53:
 1754               		.section	.text.hex_to_keycode,"ax",@progbits
 1755               		.weak	hex_to_keycode
 1757               	hex_to_keycode:
 1758               	.LFB57:
1049:quantum/quantum.c **** 
1050:quantum/quantum.c **** __attribute__((weak)) uint16_t hex_to_keycode(uint8_t hex) {
 1759               		.loc 1 1050 0
 1760               		.cfi_startproc
 1761               	.LVL200:
 1762               	/* prologue: function */
 1763               	/* frame size = 0 */
 1764               	/* stack size = 0 */
 1765               	.L__stack_usage = 0
1051:quantum/quantum.c ****     hex = hex & 0xF;
 1766               		.loc 1 1051 0
 1767 0000 282F      		mov r18,r24
 1768 0002 2F70      		andi r18,lo8(15)
 1769               	.LVL201:
1052:quantum/quantum.c ****     if (hex == 0x0) {
 1770               		.loc 1 1052 0
 1771 0004 01F0      		breq .L140
 1772 0006 822F      		mov r24,r18
 1773 0008 90E0      		ldi r25,0
1053:quantum/quantum.c ****         return KC_0;
1054:quantum/quantum.c ****     } else if (hex < 0xA) {
 1774               		.loc 1 1054 0
 1775 000a 2A30      		cpi r18,lo8(10)
 1776 000c 00F4      		brsh .L139
1055:quantum/quantum.c ****         return KC_1 + (hex - 0x1);
 1777               		.loc 1 1055 0
 1778 000e 4D96      		adiw r24,29
 1779 0010 0895      		ret
 1780               	.L139:
1056:quantum/quantum.c ****     } else {
1057:quantum/quantum.c ****         return KC_A + (hex - 0xA);
 1781               		.loc 1 1057 0
 1782 0012 0697      		sbiw r24,6
 1783 0014 0895      		ret
 1784               	.L140:
1053:quantum/quantum.c ****     } else if (hex < 0xA) {
 1785               		.loc 1 1053 0
 1786 0016 87E2      		ldi r24,lo8(39)
 1787 0018 90E0      		ldi r25,0
1058:quantum/quantum.c ****     }
1059:quantum/quantum.c **** }
 1788               		.loc 1 1059 0
 1789 001a 0895      		ret
 1790               		.cfi_endproc
 1791               	.LFE57:
 1793               		.section	.text.api_send_unicode,"ax",@progbits
 1794               	.global	api_send_unicode
 1796               	api_send_unicode:
 1797               	.LFB58:
1060:quantum/quantum.c **** 
1061:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 1798               		.loc 1 1061 0
 1799               		.cfi_startproc
 1800               	.LVL202:
 1801               	/* prologue: function */
 1802               	/* frame size = 0 */
 1803               	/* stack size = 0 */
 1804               	.L__stack_usage = 0
 1805 0000 0895      		ret
 1806               		.cfi_endproc
 1807               	.LFE58:
 1809               		.section	.text.led_set_user,"ax",@progbits
 1810               		.weak	led_set_user
 1812               	led_set_user:
 1813               	.LFB59:
1062:quantum/quantum.c **** #ifdef API_ENABLE
1063:quantum/quantum.c ****     uint8_t chunk[4];
1064:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1065:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1066:quantum/quantum.c **** #endif
1067:quantum/quantum.c **** }
1068:quantum/quantum.c **** 
1069:quantum/quantum.c **** __attribute__((weak)) void led_set_user(uint8_t usb_led) {}
 1814               		.loc 1 1069 0
 1815               		.cfi_startproc
 1816               	.LVL203:
 1817               	/* prologue: function */
 1818               	/* frame size = 0 */
 1819               	/* stack size = 0 */
 1820               	.L__stack_usage = 0
 1821 0000 0895      		ret
 1822               		.cfi_endproc
 1823               	.LFE59:
 1825               		.section	.text.led_set_kb,"ax",@progbits
 1826               		.weak	led_set_kb
 1828               	led_set_kb:
 1829               	.LFB60:
1070:quantum/quantum.c **** 
1071:quantum/quantum.c **** __attribute__((weak)) void led_set_kb(uint8_t usb_led) { led_set_user(usb_led); }
 1830               		.loc 1 1071 0
 1831               		.cfi_startproc
 1832               	.LVL204:
 1833               	/* prologue: function */
 1834               	/* frame size = 0 */
 1835               	/* stack size = 0 */
 1836               	.L__stack_usage = 0
 1837               		.loc 1 1071 0
 1838 0000 0C94 0000 		jmp led_set_user
 1839               	.LVL205:
 1840               		.cfi_endproc
 1841               	.LFE60:
 1843               		.section	.text.led_init_ports,"ax",@progbits
 1844               		.weak	led_init_ports
 1846               	led_init_ports:
 1847               	.LFB61:
1072:quantum/quantum.c **** 
1073:quantum/quantum.c **** __attribute__((weak)) void led_init_ports(void) {}
 1848               		.loc 1 1073 0
 1849               		.cfi_startproc
 1850               	/* prologue: function */
 1851               	/* frame size = 0 */
 1852               	/* stack size = 0 */
 1853               	.L__stack_usage = 0
 1854 0000 0895      		ret
 1855               		.cfi_endproc
 1856               	.LFE61:
 1858               		.section	.text.led_set,"ax",@progbits
 1859               		.weak	led_set
 1861               	led_set:
 1862               	.LFB62:
1074:quantum/quantum.c **** 
1075:quantum/quantum.c **** __attribute__((weak)) void led_set(uint8_t usb_led) {
 1863               		.loc 1 1075 0
 1864               		.cfi_startproc
 1865               	.LVL206:
 1866               	/* prologue: function */
 1867               	/* frame size = 0 */
 1868               	/* stack size = 0 */
 1869               	.L__stack_usage = 0
1076:quantum/quantum.c **** #if defined(BACKLIGHT_CAPS_LOCK) && defined(BACKLIGHT_ENABLE)
1077:quantum/quantum.c ****     // Use backlight as Caps Lock indicator
1078:quantum/quantum.c ****     uint8_t bl_toggle_lvl = 0;
1079:quantum/quantum.c **** 
1080:quantum/quantum.c ****     if (IS_LED_ON(usb_led, USB_LED_CAPS_LOCK) && !backlight_config.enable) {
1081:quantum/quantum.c ****         // Turning Caps Lock ON and backlight is disabled in config
1082:quantum/quantum.c ****         // Toggling backlight to the brightest level
1083:quantum/quantum.c ****         bl_toggle_lvl = BACKLIGHT_LEVELS;
1084:quantum/quantum.c ****     } else if (IS_LED_OFF(usb_led, USB_LED_CAPS_LOCK) && backlight_config.enable) {
1085:quantum/quantum.c ****         // Turning Caps Lock OFF and backlight is enabled in config
1086:quantum/quantum.c ****         // Toggling backlight and restoring config level
1087:quantum/quantum.c ****         bl_toggle_lvl = backlight_config.level;
1088:quantum/quantum.c ****     }
1089:quantum/quantum.c **** 
1090:quantum/quantum.c ****     // Set level without modify backlight_config to keep ability to restore state
1091:quantum/quantum.c ****     backlight_set(bl_toggle_lvl);
1092:quantum/quantum.c **** #endif
1093:quantum/quantum.c **** 
1094:quantum/quantum.c ****     led_set_kb(usb_led);
 1870               		.loc 1 1094 0
 1871 0000 0C94 0000 		jmp led_set_kb
 1872               	.LVL207:
 1873               		.cfi_endproc
 1874               	.LFE62:
 1876               		.section	.text.startup_user,"ax",@progbits
 1877               		.weak	startup_user
 1879               	startup_user:
 1880               	.LFB63:
1095:quantum/quantum.c **** }
1096:quantum/quantum.c **** 
1097:quantum/quantum.c **** //------------------------------------------------------------------------------
1098:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1099:quantum/quantum.c **** // different events such as startup and bootloader jump
1100:quantum/quantum.c **** 
1101:quantum/quantum.c **** __attribute__((weak)) void startup_user() {}
 1881               		.loc 1 1101 0
 1882               		.cfi_startproc
 1883               	/* prologue: function */
 1884               	/* frame size = 0 */
 1885               	/* stack size = 0 */
 1886               	.L__stack_usage = 0
 1887 0000 0895      		ret
 1888               		.cfi_endproc
 1889               	.LFE63:
 1891               		.section	.text.shutdown_user,"ax",@progbits
 1892               		.weak	shutdown_user
 1894               	shutdown_user:
 1895               	.LFB64:
1102:quantum/quantum.c **** 
1103:quantum/quantum.c **** __attribute__((weak)) void shutdown_user() {}
 1896               		.loc 1 1103 0
 1897               		.cfi_startproc
 1898               	/* prologue: function */
 1899               	/* frame size = 0 */
 1900               	/* stack size = 0 */
 1901               	.L__stack_usage = 0
 1902 0000 0895      		ret
 1903               		.cfi_endproc
 1904               	.LFE64:
 1906               		.section	.text.reset_keyboard,"ax",@progbits
 1907               	.global	reset_keyboard
 1909               	reset_keyboard:
 1910               	.LFB37:
 139:quantum/quantum.c ****     clear_keyboard();
 1911               		.loc 1 139 0
 1912               		.cfi_startproc
 1913               	/* prologue: function */
 1914               	/* frame size = 0 */
 1915               	/* stack size = 0 */
 1916               	.L__stack_usage = 0
 140:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 1917               		.loc 1 140 0
 1918 0000 0E94 0000 		call clear_keyboard
 1919               	.LVL208:
 154:quantum/quantum.c ****     wait_ms(250);
 1920               		.loc 1 154 0
 1921 0004 0E94 0000 		call shutdown_user
 1922               	.LVL209:
 1923               	.LBB53:
 1924               	.LBB54:
 1925               		.loc 3 163 0
 1926 0008 2FEF      		ldi r18,lo8(799999)
 1927 000a 84E3      		ldi r24,hi8(799999)
 1928 000c 9CE0      		ldi r25,hlo8(799999)
 1929 000e 2150      	1:	subi r18,1
 1930 0010 8040      		sbci r24,0
 1931 0012 9040      		sbci r25,0
 1932 0014 01F4      		brne 1b
 1933 0016 00C0      		rjmp .
 1934 0018 0000      		nop
 1935               	.LBE54:
 1936               	.LBE53:
 164:quantum/quantum.c **** }
 1937               		.loc 1 164 0
 1938 001a 0C94 0000 		jmp bootloader_jump
 1939               	.LVL210:
 1940               		.cfi_endproc
 1941               	.LFE37:
 1943               		.section	.text.process_record_quantum,"ax",@progbits
 1944               	.global	process_record_quantum
 1946               	process_record_quantum:
 1947               	.LFB40:
 199:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record);
 1948               		.loc 1 199 0
 1949               		.cfi_startproc
 1950               	.LVL211:
 1951 0000 0F93      		push r16
 1952               	.LCFI45:
 1953               		.cfi_def_cfa_offset 3
 1954               		.cfi_offset 16, -2
 1955 0002 1F93      		push r17
 1956               	.LCFI46:
 1957               		.cfi_def_cfa_offset 4
 1958               		.cfi_offset 17, -3
 1959 0004 CF93      		push r28
 1960               	.LCFI47:
 1961               		.cfi_def_cfa_offset 5
 1962               		.cfi_offset 28, -4
 1963 0006 DF93      		push r29
 1964               	.LCFI48:
 1965               		.cfi_def_cfa_offset 6
 1966               		.cfi_offset 29, -5
 1967               	/* prologue: function */
 1968               	/* frame size = 0 */
 1969               	/* stack size = 4 */
 1970               	.L__stack_usage = 4
 1971 0008 8C01      		movw r16,r24
 200:quantum/quantum.c **** 
 1972               		.loc 1 200 0
 1973 000a 0E94 0000 		call get_record_keycode
 1974               	.LVL212:
 1975 000e EC01      		movw r28,r24
 1976               	.LVL213:
 217:quantum/quantum.c **** #endif
 1977               		.loc 1 217 0
 1978 0010 B801      		movw r22,r16
 1979 0012 0E94 0000 		call preprocess_tap_dance
 1980               	.LVL214:
 234:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 1981               		.loc 1 234 0
 1982 0016 B801      		movw r22,r16
 1983 0018 CE01      		movw r24,r28
 1984 001a 0E94 0000 		call process_record_kb
 1985               	.LVL215:
 248:quantum/quantum.c **** #endif
 1986               		.loc 1 248 0
 1987 001e 8823      		tst r24
 1988 0020 01F4      		brne .+2
 1989 0022 00C0      		rjmp .L216
 248:quantum/quantum.c **** #endif
 1990               		.loc 1 248 0 is_stmt 0 discriminator 2
 1991 0024 B801      		movw r22,r16
 1992 0026 CE01      		movw r24,r28
 1993 0028 0E94 0000 		call process_tap_dance
 1994               	.LVL216:
 234:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 1995               		.loc 1 234 0 is_stmt 1 discriminator 2
 1996 002c 8823      		tst r24
 1997 002e 01F4      		brne .+2
 1998 0030 00C0      		rjmp .L216
 269:quantum/quantum.c **** #endif
 1999               		.loc 1 269 0 discriminator 3
 2000 0032 B801      		movw r22,r16
 2001 0034 CE01      		movw r24,r28
 2002 0036 0E94 0000 		call process_space_cadet
 2003               	.LVL217:
 248:quantum/quantum.c **** #endif
 2004               		.loc 1 248 0 discriminator 3
 2005 003a 8823      		tst r24
 2006 003c 01F4      		brne .+2
 2007 003e 00C0      		rjmp .L216
 277:quantum/quantum.c ****         case RESET:
 2008               		.loc 1 277 0
 2009 0040 C631      		cpi r28,22
 2010 0042 FCE5      		ldi r31,92
 2011 0044 DF07      		cpc r29,r31
 2012 0046 01F4      		brne .L245
 2013               	.LBB55:
 667:quantum/quantum.c **** 
 2014               		.loc 1 667 0
 2015 0048 0E94 0000 		call get_mods
 2016               	.LVL218:
 2017 004c 282F      		mov r18,r24
 2018               	.LVL219:
 699:quantum/quantum.c ****                 grave_esc_was_shifted = shifted;
 2019               		.loc 1 699 0
 2020 004e F801      		movw r30,r16
 2021 0050 8281      		ldd r24,Z+2
 2022 0052 4091 0000 		lds r20,keyboard_report
 2023 0056 5091 0000 		lds r21,keyboard_report+1
 2024 005a 8823      		tst r24
 2025 005c 01F0      		breq .L199
 667:quantum/quantum.c **** 
 2026               		.loc 1 667 0
 2027 005e 2A7A      		andi r18,lo8(-86)
 2028               	.LVL220:
 700:quantum/quantum.c ****                 add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 2029               		.loc 1 700 0
 2030 0060 91E0      		ldi r25,lo8(1)
 2031 0062 01F4      		brne .L200
 2032 0064 90E0      		ldi r25,0
 2033               	.L200:
 2034 0066 9093 0000 		sts grave_esc_was_shifted,r25
 701:quantum/quantum.c ****             } else {
 2035               		.loc 1 701 0
 2036 006a 9111      		cpse r25,__zero_reg__
 2037 006c 00C0      		rjmp .L206
 2038 006e 69E2      		ldi r22,lo8(41)
 2039 0070 00C0      		rjmp .L201
 2040               	.L206:
 2041 0072 65E3      		ldi r22,lo8(53)
 2042               	.L201:
 2043               	.LVL221:
 2044               	.LBB56:
 2045               	.LBB57:
 2046               		.file 4 "tmk_core/common/action_util.h"
   1:tmk_core/common/action_util.h **** /*
   2:tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action_util.h **** 
   4:tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action_util.h **** (at your option) any later version.
   8:tmk_core/common/action_util.h **** 
   9:tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:tmk_core/common/action_util.h **** 
  14:tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action_util.h **** */
  17:tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:tmk_core/common/action_util.h **** 
  20:tmk_core/common/action_util.h **** #include <stdint.h>
  21:tmk_core/common/action_util.h **** #include "report.h"
  22:tmk_core/common/action_util.h **** 
  23:tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:tmk_core/common/action_util.h **** extern "C" {
  25:tmk_core/common/action_util.h **** #endif
  26:tmk_core/common/action_util.h **** 
  27:tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:tmk_core/common/action_util.h **** 
  29:tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:tmk_core/common/action_util.h **** 
  31:tmk_core/common/action_util.h **** /* key */
  32:tmk_core/common/action_util.h **** inline void add_key(uint8_t key) { add_key_to_report(keyboard_report, key); }
 2047               		.loc 4 32 0 discriminator 4
 2048 0074 CA01      		movw r24,r20
 2049 0076 0E94 0000 		call add_key_to_report
 2050               	.LVL222:
 2051 007a 00C0      		rjmp .L202
 2052               	.LVL223:
 2053               	.L199:
 2054               	.LBE57:
 2055               	.LBE56:
 703:quantum/quantum.c ****             }
 2056               		.loc 1 703 0
 2057 007c 8091 0000 		lds r24,grave_esc_was_shifted
 2058 0080 8111      		cpse r24,__zero_reg__
 2059 0082 00C0      		rjmp .L207
 2060 0084 69E2      		ldi r22,lo8(41)
 2061 0086 00C0      		rjmp .L203
 2062               	.L207:
 2063 0088 65E3      		ldi r22,lo8(53)
 2064               	.L203:
 2065               	.LVL224:
 2066               	.LBB58:
 2067               	.LBB59:
  33:tmk_core/common/action_util.h **** 
  34:tmk_core/common/action_util.h **** inline void del_key(uint8_t key) { del_key_from_report(keyboard_report, key); }
 2068               		.loc 4 34 0 discriminator 4
 2069 008a CA01      		movw r24,r20
 2070 008c 0E94 0000 		call del_key_from_report
 2071               	.LVL225:
 2072               	.L202:
 2073               	.LBE59:
 2074               	.LBE58:
 706:quantum/quantum.c ****             return false;
 2075               		.loc 1 706 0
 2076 0090 0E94 0000 		call send_keyboard_report
 2077               	.LVL226:
 707:quantum/quantum.c ****         }
 2078               		.loc 1 707 0
 2079 0094 00C0      		rjmp .L216
 2080               	.L245:
 2081               	.LBE55:
 277:quantum/quantum.c ****         case RESET:
 2082               		.loc 1 277 0
 2083 0096 C731      		cpi r28,23
 2084 0098 8CE5      		ldi r24,92
 2085 009a D807      		cpc r29,r24
 2086 009c 00F0      		brlo .+2
 2087 009e 00C0      		rjmp .L204
 2088 00a0 C130      		cpi r28,1
 2089 00a2 ECE5      		ldi r30,92
 2090 00a4 DE07      		cpc r29,r30
 2091 00a6 01F4      		brne .L246
 284:quantum/quantum.c ****                 debug_enable ^= 1;
 2092               		.loc 1 284 0
 2093 00a8 F801      		movw r30,r16
 2094 00aa 8281      		ldd r24,Z+2
 2095 00ac 8823      		tst r24
 2096 00ae 01F4      		brne .+2
 2097 00b0 00C0      		rjmp .L216
 285:quantum/quantum.c ****                 if (debug_enable) {
 2098               		.loc 1 285 0
 2099 00b2 8091 0000 		lds r24,debug_config
 2100 00b6 982F      		mov r25,r24
 2101 00b8 9095      		com r25
 2102 00ba 90FB      		bst r25,0
 2103 00bc 80F9      		bld r24,0
 2104 00be 8093 0000 		sts debug_config,r24
 2105 00c2 00C0      		rjmp .L216
 2106               	.L246:
 277:quantum/quantum.c ****         case RESET:
 2107               		.loc 1 277 0
 2108 00c4 C230      		cpi r28,2
 2109 00c6 FCE5      		ldi r31,92
 2110 00c8 DF07      		cpc r29,r31
 2111 00ca 00F4      		brsh .+2
 2112 00cc 00C0      		rjmp .L247
 2113               	.L158:
 530:quantum/quantum.c ****                 // MAGIC actions (BOOTMAGIC without the boot)
 2114               		.loc 1 530 0
 2115 00ce F801      		movw r30,r16
 2116 00d0 8281      		ldd r24,Z+2
 2117 00d2 8823      		tst r24
 2118 00d4 01F4      		brne .+2
 2119 00d6 00C0      		rjmp .L159
 532:quantum/quantum.c ****                     eeconfig_init();
 2120               		.loc 1 532 0
 2121 00d8 0E94 0000 		call eeconfig_is_enabled
 2122               	.LVL227:
 2123 00dc 8111      		cpse r24,__zero_reg__
 2124 00de 00C0      		rjmp .L160
 533:quantum/quantum.c ****                 }
 2125               		.loc 1 533 0
 2126 00e0 0E94 0000 		call eeconfig_init
 2127               	.LVL228:
 2128               	.L160:
 536:quantum/quantum.c ****                 switch (keycode) {
 2129               		.loc 1 536 0
 2130 00e4 0E94 0000 		call eeconfig_read_keymap
 2131               	.LVL229:
 2132 00e8 9093 0000 		sts keymap_config+1,r25
 2133 00ec 8093 0000 		sts keymap_config,r24
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2134               		.loc 1 537 0
 2135 00f0 C031      		cpi r28,16
 2136 00f2 FCE5      		ldi r31,92
 2137 00f4 DF07      		cpc r29,r31
 2138 00f6 01F4      		brne .+2
 2139 00f8 00C0      		rjmp .L162
 2140 00fa 00F0      		brlo .+2
 2141 00fc 00C0      		rjmp .L163
 2142 00fe C830      		cpi r28,8
 2143 0100 ECE5      		ldi r30,92
 2144 0102 DE07      		cpc r29,r30
 2145 0104 01F4      		brne .+2
 2146 0106 00C0      		rjmp .L164
 2147 0108 00F4      		brsh .L165
 2148 010a C430      		cpi r28,4
 2149 010c 8CE5      		ldi r24,92
 2150 010e D807      		cpc r29,r24
 2151 0110 01F4      		brne .+2
 2152 0112 00C0      		rjmp .L166
 2153 0114 00F4      		brsh .L167
 2154 0116 C230      		cpi r28,2
 2155 0118 FCE5      		ldi r31,92
 2156 011a DF07      		cpc r29,r31
 2157 011c 01F4      		brne .+2
 2158 011e 00C0      		rjmp .L168
 2159 0120 C330      		cpi r28,3
 2160 0122 DC45      		sbci r29,92
 2161 0124 01F0      		breq .+2
 2162 0126 00C0      		rjmp .L161
 542:quantum/quantum.c ****                         break;
 2163               		.loc 1 542 0
 2164 0128 8091 0000 		lds r24,keymap_config
 2165 012c 8260      		ori r24,lo8(1<<1)
 2166 012e 00C0      		rjmp .L237
 2167               	.L167:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2168               		.loc 1 537 0
 2169 0130 C630      		cpi r28,6
 2170 0132 ECE5      		ldi r30,92
 2171 0134 DE07      		cpc r29,r30
 2172 0136 01F4      		brne .+2
 2173 0138 00C0      		rjmp .L170
 2174 013a 00F0      		brlo .+2
 2175 013c 00C0      		rjmp .L248
 548:quantum/quantum.c ****                         break;
 2176               		.loc 1 548 0
 2177 013e 8091 0000 		lds r24,keymap_config
 2178 0142 8860      		ori r24,lo8(1<<3)
 2179 0144 00C0      		rjmp .L237
 2180               	.L165:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2181               		.loc 1 537 0
 2182 0146 CC30      		cpi r28,12
 2183 0148 8CE5      		ldi r24,92
 2184 014a D807      		cpc r29,r24
 2185 014c 01F4      		brne .+2
 2186 014e 00C0      		rjmp .L173
 2187 0150 00F4      		brsh .L174
 2188 0152 CA30      		cpi r28,10
 2189 0154 FCE5      		ldi r31,92
 2190 0156 DF07      		cpc r29,r31
 2191 0158 01F4      		brne .+2
 2192 015a 00C0      		rjmp .L175
 2193 015c 00F0      		brlo .+2
 2194 015e 00C0      		rjmp .L249
 566:quantum/quantum.c ****                         keymap_config.nkro = true;
 2195               		.loc 1 566 0
 2196 0160 0E94 0000 		call clear_keyboard
 2197               	.LVL230:
 567:quantum/quantum.c ****                         break;
 2198               		.loc 1 567 0
 2199 0164 8091 0000 		lds r24,keymap_config
 2200 0168 8068      		ori r24,lo8(1<<7)
 2201 016a 00C0      		rjmp .L237
 2202               	.L174:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2203               		.loc 1 537 0
 2204 016c CE30      		cpi r28,14
 2205 016e ECE5      		ldi r30,92
 2206 0170 DE07      		cpc r29,r30
 2207 0172 01F4      		brne .+2
 2208 0174 00C0      		rjmp .L178
 2209 0176 00F0      		brlo .+2
 2210 0178 00C0      		rjmp .L250
 588:quantum/quantum.c ****                         break;
 2211               		.loc 1 588 0
 2212 017a 8091 0000 		lds r24,keymap_config
 2213 017e 00C0      		rjmp .L242
 2214               	.L163:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2215               		.loc 1 537 0
 2216 0180 CB3F      		cpi r28,-5
 2217 0182 8CE5      		ldi r24,92
 2218 0184 D807      		cpc r29,r24
 2219 0186 01F4      		brne .+2
 2220 0188 00C0      		rjmp .L181
 2221 018a 00F4      		brsh .L182
 2222 018c C331      		cpi r28,19
 2223 018e FCE5      		ldi r31,92
 2224 0190 DF07      		cpc r29,r31
 2225 0192 01F4      		brne .+2
 2226 0194 00C0      		rjmp .L183
 2227 0196 00F4      		brsh .L184
 2228 0198 C131      		cpi r28,17
 2229 019a ECE5      		ldi r30,92
 2230 019c DE07      		cpc r29,r30
 2231 019e 01F4      		brne .+2
 2232 01a0 00C0      		rjmp .L185
 2233 01a2 C231      		cpi r28,18
 2234 01a4 DC45      		sbci r29,92
 2235 01a6 01F0      		breq .+2
 2236 01a8 00C0      		rjmp .L161
 609:quantum/quantum.c ****                         keymap_config.nkro = false;
 2237               		.loc 1 609 0
 2238 01aa 0E94 0000 		call clear_keyboard
 2239               	.LVL231:
 610:quantum/quantum.c ****                         break;
 2240               		.loc 1 610 0
 2241 01ae 8091 0000 		lds r24,keymap_config
 2242 01b2 8F77      		andi r24,lo8(~(1<<7))
 2243 01b4 00C0      		rjmp .L237
 2244               	.L184:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2245               		.loc 1 537 0
 2246 01b6 C531      		cpi r28,21
 2247 01b8 8CE5      		ldi r24,92
 2248 01ba D807      		cpc r29,r24
 2249 01bc 01F4      		brne .+2
 2250 01be 00C0      		rjmp .L187
 2251 01c0 00F4      		brsh .+2
 2252 01c2 00C0      		rjmp .L188
 2253 01c4 CA3F      		cpi r28,-6
 2254 01c6 DC45      		sbci r29,92
 2255 01c8 01F0      		breq .+2
 2256 01ca 00C0      		rjmp .L161
 551:quantum/quantum.c ****                         break;
 2257               		.loc 1 551 0
 2258 01cc 8091 0000 		lds r24,keymap_config+1
 2259 01d0 00C0      		rjmp .L243
 2260               	.L182:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2261               		.loc 1 537 0
 2262 01d2 CF3F      		cpi r28,-1
 2263 01d4 8CE5      		ldi r24,92
 2264 01d6 D807      		cpc r29,r24
 2265 01d8 01F4      		brne .+2
 2266 01da 00C0      		rjmp .L190
 2267 01dc 00F4      		brsh .L191
 2268 01de CD3F      		cpi r28,-3
 2269 01e0 FCE5      		ldi r31,92
 2270 01e2 DF07      		cpc r29,r31
 2271 01e4 01F4      		brne .+2
 2272 01e6 00C0      		rjmp .L192
 2273 01e8 00F4      		brsh .+2
 2274 01ea 00C0      		rjmp .L236
 576:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2275               		.loc 1 576 0
 2276 01ec 8091 0000 		lds r24,keymap_config+1
 2277 01f0 8260      		ori r24,lo8(2)
 2278 01f2 00C0      		rjmp .L243
 2279               	.L191:
 537:quantum/quantum.c ****                     case MAGIC_SWAP_CONTROL_CAPSLOCK:
 2280               		.loc 1 537 0
 2281 01f4 C130      		cpi r28,1
 2282 01f6 EDE5      		ldi r30,93
 2283 01f8 DE07      		cpc r29,r30
 2284 01fa 01F4      		brne .+2
 2285 01fc 00C0      		rjmp .L195
 2286 01fe 00F4      		brsh .+2
 2287 0200 00C0      		rjmp .L196
 2288 0202 C230      		cpi r28,2
 2289 0204 DD45      		sbci r29,93
 2290 0206 01F0      		breq .+2
 2291 0208 00C0      		rjmp .L161
 654:quantum/quantum.c ****                         break;
 2292               		.loc 1 654 0
 2293 020a 80E0      		ldi r24,0
 2294 020c 00C0      		rjmp .L238
 2295               	.L168:
 539:quantum/quantum.c ****                         break;
 2296               		.loc 1 539 0
 2297 020e 8091 0000 		lds r24,keymap_config
 2298 0212 8160      		ori r24,lo8(1<<0)
 2299 0214 00C0      		rjmp .L237
 2300               	.L170:
 557:quantum/quantum.c ****                         break;
 2301               		.loc 1 557 0
 2302 0216 8091 0000 		lds r24,keymap_config
 2303 021a 8061      		ori r24,lo8(1<<4)
 2304               	.L237:
 542:quantum/quantum.c ****                         break;
 2305               		.loc 1 542 0
 2306 021c 8093 0000 		sts keymap_config,r24
 543:quantum/quantum.c ****                     case MAGIC_SWAP_LALT_LGUI:
 2307               		.loc 1 543 0
 2308 0220 00C0      		rjmp .L161
 2309               	.L166:
 545:quantum/quantum.c ****                         break;
 2310               		.loc 1 545 0
 2311 0222 8091 0000 		lds r24,keymap_config
 2312 0226 00C0      		rjmp .L241
 2313               	.L181:
 554:quantum/quantum.c ****                         break;
 2314               		.loc 1 554 0
 2315 0228 8091 0000 		lds r24,keymap_config+1
 2316 022c 8260      		ori r24,lo8(1<<1)
 2317               	.L239:
 2318 022e 8093 0000 		sts keymap_config+1,r24
 555:quantum/quantum.c ****                     case MAGIC_NO_GUI:
 2319               		.loc 1 555 0
 2320 0232 00C0      		rjmp .L161
 2321               	.L248:
 560:quantum/quantum.c ****                         break;
 2322               		.loc 1 560 0
 2323 0234 8091 0000 		lds r24,keymap_config
 2324 0238 8062      		ori r24,lo8(1<<5)
 2325 023a 00C0      		rjmp .L237
 2326               	.L164:
 563:quantum/quantum.c ****                         break;
 2327               		.loc 1 563 0
 2328 023c 8091 0000 		lds r24,keymap_config
 2329 0240 8064      		ori r24,lo8(1<<6)
 2330 0242 00C0      		rjmp .L237
 2331               	.L175:
 570:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2332               		.loc 1 570 0
 2333 0244 8091 0000 		lds r24,keymap_config
 2334 0248 8860      		ori r24,lo8(8)
 2335               	.L241:
 2336 024a 8460      		ori r24,lo8(1<<2)
 2337 024c 00C0      		rjmp .L237
 2338               	.L243:
 576:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2339               		.loc 1 576 0
 2340 024e 8160      		ori r24,lo8(1<<0)
 2341 0250 00C0      		rjmp .L239
 2342               	.L249:
 582:quantum/quantum.c ****                         break;
 2343               		.loc 1 582 0
 2344 0252 8091 0000 		lds r24,keymap_config
 2345 0256 8E7F      		andi r24,lo8(~(1<<0))
 2346 0258 00C0      		rjmp .L237
 2347               	.L173:
 585:quantum/quantum.c ****                         break;
 2348               		.loc 1 585 0
 2349 025a 8091 0000 		lds r24,keymap_config
 2350 025e 8D7F      		andi r24,lo8(~(1<<1))
 2351 0260 00C0      		rjmp .L237
 2352               	.L178:
 591:quantum/quantum.c ****                         break;
 2353               		.loc 1 591 0
 2354 0262 8091 0000 		lds r24,keymap_config
 2355 0266 877F      		andi r24,lo8(~(1<<3))
 2356 0268 00C0      		rjmp .L237
 2357               	.L236:
 594:quantum/quantum.c ****                         break;
 2358               		.loc 1 594 0
 2359 026a 8091 0000 		lds r24,keymap_config+1
 2360 026e 00C0      		rjmp .L244
 2361               	.L192:
 597:quantum/quantum.c ****                         break;
 2362               		.loc 1 597 0
 2363 0270 8091 0000 		lds r24,keymap_config+1
 2364 0274 8D7F      		andi r24,lo8(~(1<<1))
 2365 0276 00C0      		rjmp .L239
 2366               	.L250:
 600:quantum/quantum.c ****                         break;
 2367               		.loc 1 600 0
 2368 0278 8091 0000 		lds r24,keymap_config
 2369 027c 8F7E      		andi r24,lo8(~(1<<4))
 2370 027e 00C0      		rjmp .L237
 2371               	.L162:
 603:quantum/quantum.c ****                         break;
 2372               		.loc 1 603 0
 2373 0280 8091 0000 		lds r24,keymap_config
 2374 0284 8F7D      		andi r24,lo8(~(1<<5))
 2375 0286 00C0      		rjmp .L237
 2376               	.L185:
 606:quantum/quantum.c ****                         break;
 2377               		.loc 1 606 0
 2378 0288 8091 0000 		lds r24,keymap_config
 2379 028c 8F7B      		andi r24,lo8(~(1<<6))
 2380 028e 00C0      		rjmp .L237
 2381               	.L183:
 613:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2382               		.loc 1 613 0
 2383 0290 8091 0000 		lds r24,keymap_config
 2384 0294 877F      		andi r24,lo8(-9)
 2385               	.L242:
 2386 0296 8B7F      		andi r24,lo8(~(1<<2))
 2387 0298 00C0      		rjmp .L237
 2388               	.L190:
 619:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2389               		.loc 1 619 0
 2390 029a 8091 0000 		lds r24,keymap_config+1
 2391 029e 8D7F      		andi r24,lo8(-3)
 2392               	.L244:
 2393 02a0 8E7F      		andi r24,lo8(~(1<<0))
 2394 02a2 00C0      		rjmp .L239
 2395               	.L187:
 625:quantum/quantum.c ****                         keymap_config.swap_ralt_rgui = keymap_config.swap_lalt_lgui;
 2396               		.loc 1 625 0
 2397 02a4 8091 0000 		lds r24,keymap_config
 2398 02a8 82FB      		bst r24,2
 2399 02aa 2227      		clr r18
 2400 02ac 20F9      		bld r18,0
 2401 02ae 91E0      		ldi r25,lo8(1)
 2402 02b0 9227      		eor r25,r18
 2403 02b2 90FB      		bst r25,0
 2404 02b4 82F9      		bld r24,2
 626:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2405               		.loc 1 626 0
 2406 02b6 90FB      		bst r25,0
 2407 02b8 83F9      		bld r24,3
 2408 02ba 00C0      		rjmp .L237
 2409               	.L196:
 636:quantum/quantum.c ****                         keymap_config.swap_rctl_rgui = keymap_config.swap_lctl_lgui;
 2410               		.loc 1 636 0
 2411 02bc 8091 0000 		lds r24,keymap_config+1
 2412 02c0 982F      		mov r25,r24
 2413 02c2 9095      		com r25
 2414 02c4 9170      		andi r25,lo8(1)
 2415 02c6 8E7F      		andi r24,lo8(-2)
 637:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 2416               		.loc 1 637 0
 2417 02c8 892B      		or r24,r25
 2418 02ca 90FB      		bst r25,0
 2419 02cc 81F9      		bld r24,1
 2420 02ce 00C0      		rjmp .L239
 2421               	.L188:
 647:quantum/quantum.c ****                         keymap_config.nkro = !keymap_config.nkro;
 2422               		.loc 1 647 0
 2423 02d0 0E94 0000 		call clear_keyboard
 2424               	.LVL232:
 648:quantum/quantum.c ****                         break;
 2425               		.loc 1 648 0
 2426 02d4 8091 0000 		lds r24,keymap_config
 2427 02d8 87FB      		bst r24,7
 2428 02da 2227      		clr r18
 2429 02dc 20F9      		bld r18,0
 2430 02de 91E0      		ldi r25,lo8(1)
 2431 02e0 9227      		eor r25,r18
 2432 02e2 90FB      		bst r25,0
 2433 02e4 87F9      		bld r24,7
 2434 02e6 00C0      		rjmp .L237
 2435               	.L195:
 651:quantum/quantum.c ****                         break;
 2436               		.loc 1 651 0
 2437 02e8 81E0      		ldi r24,lo8(1)
 2438               	.L238:
 654:quantum/quantum.c ****                         break;
 2439               		.loc 1 654 0
 2440 02ea 0E94 0000 		call eeconfig_update_handedness
 2441               	.LVL233:
 2442               	.L161:
 659:quantum/quantum.c ****                 clear_keyboard();  // clear to prevent stuck keys
 2443               		.loc 1 659 0
 2444 02ee 8091 0000 		lds r24,keymap_config
 2445 02f2 9091 0000 		lds r25,keymap_config+1
 2446 02f6 0E94 0000 		call eeconfig_update_keymap
 2447               	.LVL234:
 660:quantum/quantum.c **** 
 2448               		.loc 1 660 0
 2449 02fa 0E94 0000 		call clear_keyboard
 2450               	.LVL235:
 662:quantum/quantum.c ****             }
 2451               		.loc 1 662 0
 2452 02fe 00C0      		rjmp .L216
 2453               	.L247:
 277:quantum/quantum.c ****         case RESET:
 2454               		.loc 1 277 0
 2455 0300 C115      		cp r28,__zero_reg__
 2456 0302 DC45      		sbci r29,92
 2457 0304 01F0      		breq .L152
 2458               	.L159:
 720:quantum/quantum.c **** }
 2459               		.loc 1 720 0
 2460 0306 C801      		movw r24,r16
 2461               	/* epilogue start */
 721:quantum/quantum.c **** 
 2462               		.loc 1 721 0
 2463 0308 DF91      		pop r29
 2464 030a CF91      		pop r28
 2465               	.LVL236:
 2466 030c 1F91      		pop r17
 2467 030e 0F91      		pop r16
 2468               	.LVL237:
 720:quantum/quantum.c **** }
 2469               		.loc 1 720 0
 2470 0310 0C94 0000 		jmp process_action_kb
 2471               	.LVL238:
 2472               	.L152:
 279:quantum/quantum.c ****                 reset_keyboard();
 2473               		.loc 1 279 0
 2474 0314 F801      		movw r30,r16
 2475 0316 8281      		ldd r24,Z+2
 2476 0318 8823      		tst r24
 2477 031a 01F0      		breq .L216
 280:quantum/quantum.c ****             }
 2478               		.loc 1 280 0
 2479 031c 0E94 0000 		call reset_keyboard
 2480               	.LVL239:
 2481 0320 00C0      		rjmp .L216
 2482               	.L204:
 277:quantum/quantum.c ****         case RESET:
 2483               		.loc 1 277 0
 2484 0322 CE3D      		cpi r28,-34
 2485 0324 ECE5      		ldi r30,92
 2486 0326 DE07      		cpc r29,r30
 2487 0328 01F4      		brne .L251
 294:quantum/quantum.c ****                 eeconfig_init();
 2488               		.loc 1 294 0
 2489 032a F801      		movw r30,r16
 2490 032c 8281      		ldd r24,Z+2
 2491 032e 8823      		tst r24
 2492 0330 01F0      		breq .L216
 295:quantum/quantum.c ****             }
 2493               		.loc 1 295 0
 2494 0332 0E94 0000 		call eeconfig_init
 2495               	.LVL240:
 2496 0336 00C0      		rjmp .L216
 2497               	.L251:
 277:quantum/quantum.c ****         case RESET:
 2498               		.loc 1 277 0
 2499 0338 CF3D      		cpi r28,-33
 2500 033a FCE5      		ldi r31,92
 2501 033c DF07      		cpc r29,r31
 2502 033e 00F4      		brsh .L205
 2503 0340 CC3D      		cpi r28,-36
 2504 0342 8CE5      		ldi r24,92
 2505 0344 D807      		cpc r29,r24
 2506 0346 01F4      		brne .L252
 511:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 2507               		.loc 1 511 0
 2508 0348 F801      		movw r30,r16
 2509 034a 8281      		ldd r24,Z+2
 2510 034c 8823      		tst r24
 2511 034e 01F0      		breq .L216
 512:quantum/quantum.c ****             }
 2512               		.loc 1 512 0
 2513 0350 80E0      		ldi r24,0
 2514 0352 00C0      		rjmp .L240
 2515               	.L252:
 277:quantum/quantum.c ****         case RESET:
 2516               		.loc 1 277 0
 2517 0354 CD3D      		cpi r28,-35
 2518 0356 DC45      		sbci r29,92
 2519 0358 01F4      		brne .L159
 516:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 2520               		.loc 1 516 0
 2521 035a F801      		movw r30,r16
 2522 035c 8281      		ldd r24,Z+2
 2523 035e 8823      		tst r24
 2524 0360 01F0      		breq .L216
 517:quantum/quantum.c ****             }
 2525               		.loc 1 517 0
 2526 0362 82E0      		ldi r24,lo8(2)
 2527               	.L240:
 2528 0364 0E94 0000 		call set_output
 2529               	.LVL241:
 2530 0368 00C0      		rjmp .L216
 2531               	.L205:
 277:quantum/quantum.c ****         case RESET:
 2532               		.loc 1 277 0
 2533 036a CE01      		movw r24,r28
 2534 036c 8A5F      		subi r24,-6
 2535 036e 9C45      		sbci r25,92
 2536 0370 0997      		sbiw r24,9
 2537 0372 00F4      		brsh .+2
 2538 0374 00C0      		rjmp .L158
 2539 0376 00C0      		rjmp .L159
 2540               	.L216:
 721:quantum/quantum.c **** 
 2541               		.loc 1 721 0
 2542 0378 80E0      		ldi r24,0
 2543               	/* epilogue start */
 2544 037a DF91      		pop r29
 2545 037c CF91      		pop r28
 2546               	.LVL242:
 2547 037e 1F91      		pop r17
 2548 0380 0F91      		pop r16
 2549               	.LVL243:
 2550 0382 0895      		ret
 2551               		.cfi_endproc
 2552               	.LFE40:
 2554               		.weak	ascii_to_keycode_lut
 2555               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2558               	ascii_to_keycode_lut:
 2559 0000 00        		.byte	0
 2560 0001 00        		.byte	0
 2561 0002 00        		.byte	0
 2562 0003 00        		.byte	0
 2563 0004 00        		.byte	0
 2564 0005 00        		.byte	0
 2565 0006 00        		.byte	0
 2566 0007 00        		.byte	0
 2567 0008 2A        		.byte	42
 2568 0009 2B        		.byte	43
 2569 000a 28        		.byte	40
 2570 000b 00        		.byte	0
 2571 000c 00        		.byte	0
 2572 000d 00        		.byte	0
 2573 000e 00        		.byte	0
 2574 000f 00        		.byte	0
 2575 0010 00        		.byte	0
 2576 0011 00        		.byte	0
 2577 0012 00        		.byte	0
 2578 0013 00        		.byte	0
 2579 0014 00        		.byte	0
 2580 0015 00        		.byte	0
 2581 0016 00        		.byte	0
 2582 0017 00        		.byte	0
 2583 0018 00        		.byte	0
 2584 0019 00        		.byte	0
 2585 001a 00        		.byte	0
 2586 001b 29        		.byte	41
 2587 001c 00        		.byte	0
 2588 001d 00        		.byte	0
 2589 001e 00        		.byte	0
 2590 001f 00        		.byte	0
 2591 0020 2C        		.byte	44
 2592 0021 1E        		.byte	30
 2593 0022 34        		.byte	52
 2594 0023 20        		.byte	32
 2595 0024 21        		.byte	33
 2596 0025 22        		.byte	34
 2597 0026 24        		.byte	36
 2598 0027 34        		.byte	52
 2599 0028 26        		.byte	38
 2600 0029 27        		.byte	39
 2601 002a 25        		.byte	37
 2602 002b 2E        		.byte	46
 2603 002c 36        		.byte	54
 2604 002d 2D        		.byte	45
 2605 002e 37        		.byte	55
 2606 002f 38        		.byte	56
 2607 0030 27        		.byte	39
 2608 0031 1E        		.byte	30
 2609 0032 1F        		.byte	31
 2610 0033 20        		.byte	32
 2611 0034 21        		.byte	33
 2612 0035 22        		.byte	34
 2613 0036 23        		.byte	35
 2614 0037 24        		.byte	36
 2615 0038 25        		.byte	37
 2616 0039 26        		.byte	38
 2617 003a 33        		.byte	51
 2618 003b 33        		.byte	51
 2619 003c 36        		.byte	54
 2620 003d 2E        		.byte	46
 2621 003e 37        		.byte	55
 2622 003f 38        		.byte	56
 2623 0040 1F        		.byte	31
 2624 0041 04        		.byte	4
 2625 0042 05        		.byte	5
 2626 0043 06        		.byte	6
 2627 0044 07        		.byte	7
 2628 0045 08        		.byte	8
 2629 0046 09        		.byte	9
 2630 0047 0A        		.byte	10
 2631 0048 0B        		.byte	11
 2632 0049 0C        		.byte	12
 2633 004a 0D        		.byte	13
 2634 004b 0E        		.byte	14
 2635 004c 0F        		.byte	15
 2636 004d 10        		.byte	16
 2637 004e 11        		.byte	17
 2638 004f 12        		.byte	18
 2639 0050 13        		.byte	19
 2640 0051 14        		.byte	20
 2641 0052 15        		.byte	21
 2642 0053 16        		.byte	22
 2643 0054 17        		.byte	23
 2644 0055 18        		.byte	24
 2645 0056 19        		.byte	25
 2646 0057 1A        		.byte	26
 2647 0058 1B        		.byte	27
 2648 0059 1C        		.byte	28
 2649 005a 1D        		.byte	29
 2650 005b 2F        		.byte	47
 2651 005c 31        		.byte	49
 2652 005d 30        		.byte	48
 2653 005e 23        		.byte	35
 2654 005f 2D        		.byte	45
 2655 0060 35        		.byte	53
 2656 0061 04        		.byte	4
 2657 0062 05        		.byte	5
 2658 0063 06        		.byte	6
 2659 0064 07        		.byte	7
 2660 0065 08        		.byte	8
 2661 0066 09        		.byte	9
 2662 0067 0A        		.byte	10
 2663 0068 0B        		.byte	11
 2664 0069 0C        		.byte	12
 2665 006a 0D        		.byte	13
 2666 006b 0E        		.byte	14
 2667 006c 0F        		.byte	15
 2668 006d 10        		.byte	16
 2669 006e 11        		.byte	17
 2670 006f 12        		.byte	18
 2671 0070 13        		.byte	19
 2672 0071 14        		.byte	20
 2673 0072 15        		.byte	21
 2674 0073 16        		.byte	22
 2675 0074 17        		.byte	23
 2676 0075 18        		.byte	24
 2677 0076 19        		.byte	25
 2678 0077 1A        		.byte	26
 2679 0078 1B        		.byte	27
 2680 0079 1C        		.byte	28
 2681 007a 1D        		.byte	29
 2682 007b 2F        		.byte	47
 2683 007c 31        		.byte	49
 2684 007d 30        		.byte	48
 2685 007e 35        		.byte	53
 2686 007f 4C        		.byte	76
 2687               		.weak	ascii_to_altgr_lut
 2688               		.section	.progmem.data.ascii_to_altgr_lut,"a",@progbits
 2691               	ascii_to_altgr_lut:
 2692 0000 0000 0000 		.zero	128
 2692      0000 0000 
 2692      0000 0000 
 2692      0000 0000 
 2692      0000 0000 
 2693               		.weak	ascii_to_shift_lut
 2694               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2697               	ascii_to_shift_lut:
 2698 0000 00        		.byte	0
 2699 0001 00        		.byte	0
 2700 0002 00        		.byte	0
 2701 0003 00        		.byte	0
 2702 0004 00        		.byte	0
 2703 0005 00        		.byte	0
 2704 0006 00        		.byte	0
 2705 0007 00        		.byte	0
 2706 0008 00        		.byte	0
 2707 0009 00        		.byte	0
 2708 000a 00        		.byte	0
 2709 000b 00        		.byte	0
 2710 000c 00        		.byte	0
 2711 000d 00        		.byte	0
 2712 000e 00        		.byte	0
 2713 000f 00        		.byte	0
 2714 0010 00        		.byte	0
 2715 0011 00        		.byte	0
 2716 0012 00        		.byte	0
 2717 0013 00        		.byte	0
 2718 0014 00        		.byte	0
 2719 0015 00        		.byte	0
 2720 0016 00        		.byte	0
 2721 0017 00        		.byte	0
 2722 0018 00        		.byte	0
 2723 0019 00        		.byte	0
 2724 001a 00        		.byte	0
 2725 001b 00        		.byte	0
 2726 001c 00        		.byte	0
 2727 001d 00        		.byte	0
 2728 001e 00        		.byte	0
 2729 001f 00        		.byte	0
 2730 0020 00        		.byte	0
 2731 0021 01        		.byte	1
 2732 0022 01        		.byte	1
 2733 0023 01        		.byte	1
 2734 0024 01        		.byte	1
 2735 0025 01        		.byte	1
 2736 0026 01        		.byte	1
 2737 0027 00        		.byte	0
 2738 0028 01        		.byte	1
 2739 0029 01        		.byte	1
 2740 002a 01        		.byte	1
 2741 002b 01        		.byte	1
 2742 002c 00        		.byte	0
 2743 002d 00        		.byte	0
 2744 002e 00        		.byte	0
 2745 002f 00        		.byte	0
 2746 0030 00        		.byte	0
 2747 0031 00        		.byte	0
 2748 0032 00        		.byte	0
 2749 0033 00        		.byte	0
 2750 0034 00        		.byte	0
 2751 0035 00        		.byte	0
 2752 0036 00        		.byte	0
 2753 0037 00        		.byte	0
 2754 0038 00        		.byte	0
 2755 0039 00        		.byte	0
 2756 003a 01        		.byte	1
 2757 003b 00        		.byte	0
 2758 003c 01        		.byte	1
 2759 003d 00        		.byte	0
 2760 003e 01        		.byte	1
 2761 003f 01        		.byte	1
 2762 0040 01        		.byte	1
 2763 0041 01        		.byte	1
 2764 0042 01        		.byte	1
 2765 0043 01        		.byte	1
 2766 0044 01        		.byte	1
 2767 0045 01        		.byte	1
 2768 0046 01        		.byte	1
 2769 0047 01        		.byte	1
 2770 0048 01        		.byte	1
 2771 0049 01        		.byte	1
 2772 004a 01        		.byte	1
 2773 004b 01        		.byte	1
 2774 004c 01        		.byte	1
 2775 004d 01        		.byte	1
 2776 004e 01        		.byte	1
 2777 004f 01        		.byte	1
 2778 0050 01        		.byte	1
 2779 0051 01        		.byte	1
 2780 0052 01        		.byte	1
 2781 0053 01        		.byte	1
 2782 0054 01        		.byte	1
 2783 0055 01        		.byte	1
 2784 0056 01        		.byte	1
 2785 0057 01        		.byte	1
 2786 0058 01        		.byte	1
 2787 0059 01        		.byte	1
 2788 005a 01        		.byte	1
 2789 005b 00        		.byte	0
 2790 005c 00        		.byte	0
 2791 005d 00        		.byte	0
 2792 005e 01        		.byte	1
 2793 005f 01        		.byte	1
 2794 0060 00        		.byte	0
 2795 0061 00        		.byte	0
 2796 0062 00        		.byte	0
 2797 0063 00        		.byte	0
 2798 0064 00        		.byte	0
 2799 0065 00        		.byte	0
 2800 0066 00        		.byte	0
 2801 0067 00        		.byte	0
 2802 0068 00        		.byte	0
 2803 0069 00        		.byte	0
 2804 006a 00        		.byte	0
 2805 006b 00        		.byte	0
 2806 006c 00        		.byte	0
 2807 006d 00        		.byte	0
 2808 006e 00        		.byte	0
 2809 006f 00        		.byte	0
 2810 0070 00        		.byte	0
 2811 0071 00        		.byte	0
 2812 0072 00        		.byte	0
 2813 0073 00        		.byte	0
 2814 0074 00        		.byte	0
 2815 0075 00        		.byte	0
 2816 0076 00        		.byte	0
 2817 0077 00        		.byte	0
 2818 0078 00        		.byte	0
 2819 0079 00        		.byte	0
 2820 007a 00        		.byte	0
 2821 007b 01        		.byte	1
 2822 007c 01        		.byte	1
 2823 007d 01        		.byte	1
 2824 007e 01        		.byte	1
 2825 007f 00        		.byte	0
 2826               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2829               	grave_esc_was_shifted:
 2830 0000 00        		.zero	1
 2831               		.text
 2832               	.Letext0:
 2833               		.file 5 "/usr/lib/avr/include/stdint.h"
 2834               		.file 6 "tmk_core/common/matrix.h"
 2835               		.file 7 "tmk_core/common/keyboard.h"
 2836               		.file 8 "tmk_core/common/action.h"
 2837               		.file 9 "tmk_core/common/report.h"
 2838               		.file 10 "tmk_core/common/debug.h"
 2839               		.file 11 "quantum/keycode_config.h"
 2840               		.file 12 "tmk_core/common/keycode.h"
 2841               		.file 13 "quantum/quantum_keycodes.h"
 2842               		.file 14 "tmk_core/common/action_layer.h"
 2843               		.file 15 "tmk_core/protocol/lufa/outputselect.h"
 2844               		.file 16 "quantum/quantum.h"
 2845               		.file 17 "quantum/keymap.h"
 2846               		.file 18 "tmk_core/common/eeconfig.h"
 2847               		.file 19 "tmk_core/common/bootloader.h"
 2848               		.file 20 "quantum/process_keycode/process_tap_dance.h"
 2849               		.file 21 "quantum/process_keycode/process_space_cadet.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/cc8svNrf.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8svNrf.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8svNrf.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8svNrf.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8svNrf.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8svNrf.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/cc8svNrf.s:114    .text.rgblight_toggle:0000000000000000 rgblight_toggle
     /tmp/cc8svNrf.s:130    .text.rgblight_step:0000000000000000 rgblight_step
     /tmp/cc8svNrf.s:145    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
     /tmp/cc8svNrf.s:160    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
     /tmp/cc8svNrf.s:175    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
     /tmp/cc8svNrf.s:190    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
     /tmp/cc8svNrf.s:205    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
     /tmp/cc8svNrf.s:220    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
     /tmp/cc8svNrf.s:235    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
     /tmp/cc8svNrf.s:250    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
     /tmp/cc8svNrf.s:265    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
     /tmp/cc8svNrf.s:280    .text.register_code16:0000000000000000 register_code16
     /tmp/cc8svNrf.s:337    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/cc8svNrf.s:392    .text.tap_code16:0000000000000000 tap_code16
     /tmp/cc8svNrf.s:429    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/cc8svNrf.s:448    .text.process_record_user:0000000000000000 process_record_user
     /tmp/cc8svNrf.s:467    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/cc8svNrf.s:485    .text.get_event_keycode:0000000000000000 get_event_keycode
     /tmp/cc8svNrf.s:579    .text.get_record_keycode:0000000000000000 get_record_keycode
     /tmp/cc8svNrf.s:604    .text.send_char:0000000000000000 send_char
     /tmp/cc8svNrf.s:2558   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/cc8svNrf.s:2697   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/cc8svNrf.s:2691   .progmem.data.ascii_to_altgr_lut:0000000000000000 ascii_to_altgr_lut
     /tmp/cc8svNrf.s:745    .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/cc8svNrf.s:890    .text.send_string:0000000000000000 send_string
     /tmp/cc8svNrf.s:909    .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/cc8svNrf.s:1085   .text.send_string_P:0000000000000000 send_string_P
     /tmp/cc8svNrf.s:1104   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/cc8svNrf.s:1153   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/cc8svNrf.s:1305   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/cc8svNrf.s:1342   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/cc8svNrf.s:1469   .text.bootmagic_lite:0000000000000000 bootmagic_lite
     /tmp/cc8svNrf.s:1517   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/cc8svNrf.s:1549   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/cc8svNrf.s:1572   .text.send_nibble:0000000000000000 send_nibble
     /tmp/cc8svNrf.s:1636   .text.send_byte:0000000000000000 send_byte
     /tmp/cc8svNrf.s:1673   .text.send_word:0000000000000000 send_word
     /tmp/cc8svNrf.s:1707   .text.send_dword:0000000000000000 send_dword
     /tmp/cc8svNrf.s:1757   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/cc8svNrf.s:1796   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/cc8svNrf.s:1812   .text.led_set_user:0000000000000000 led_set_user
     /tmp/cc8svNrf.s:1828   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/cc8svNrf.s:1846   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/cc8svNrf.s:1861   .text.led_set:0000000000000000 led_set
     /tmp/cc8svNrf.s:1879   .text.startup_user:0000000000000000 startup_user
     /tmp/cc8svNrf.s:1894   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/cc8svNrf.s:1909   .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/cc8svNrf.s:1946   .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/cc8svNrf.s:2829   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted

UNDEFINED SYMBOLS
register_mods
register_weak_mods
register_code
unregister_code
unregister_mods
unregister_weak_mods
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
tap_code
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan
matrix_get_row
eeconfig_disable
bootloader_jump
eeconfig_is_enabled
eeconfig_init
backlight_init_ports
matrix_init_kb
matrix_scan_tap_dance
backlight_task
matrix_scan_kb
clear_keyboard
preprocess_tap_dance
process_tap_dance
process_space_cadet
get_mods
keyboard_report
add_key_to_report
del_key_from_report
send_keyboard_report
debug_config
eeconfig_read_keymap
keymap_config
eeconfig_update_handedness
eeconfig_update_keymap
set_output
__do_clear_bss
