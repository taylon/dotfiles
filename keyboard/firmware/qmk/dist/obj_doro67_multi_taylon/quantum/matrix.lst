   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB23:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2018 Jun Wako, Jack Humbert, Yiancar
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #include "wait.h"
  20:quantum/matrix.c **** #include "print.h"
  21:quantum/matrix.c **** #include "debug.h"
  22:quantum/matrix.c **** #include "util.h"
  23:quantum/matrix.c **** #include "matrix.h"
  24:quantum/matrix.c **** #include "debounce.h"
  25:quantum/matrix.c **** #include "quantum.h"
  26:quantum/matrix.c **** 
  27:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  28:quantum/matrix.c **** #    define print_matrix_header() print("\nr/c 01234567\n")
  29:quantum/matrix.c **** #    define print_matrix_row(row) print_bin_reverse8(matrix_get_row(row))
  30:quantum/matrix.c **** #    define matrix_bitpop(i) bitpop(matrix[i])
  31:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  32:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  33:quantum/matrix.c **** #    define print_matrix_header() print("\nr/c 0123456789ABCDEF\n")
  34:quantum/matrix.c **** #    define print_matrix_row(row) print_bin_reverse16(matrix_get_row(row))
  35:quantum/matrix.c **** #    define matrix_bitpop(i) bitpop16(matrix[i])
  36:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  37:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  38:quantum/matrix.c **** #    define print_matrix_header() print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  39:quantum/matrix.c **** #    define print_matrix_row(row) print_bin_reverse32(matrix_get_row(row))
  40:quantum/matrix.c **** #    define matrix_bitpop(i) bitpop32(matrix[i])
  41:quantum/matrix.c **** #    define ROW_SHIFTER ((uint32_t)1)
  42:quantum/matrix.c **** #endif
  43:quantum/matrix.c **** 
  44:quantum/matrix.c **** #ifdef MATRIX_MASKED
  45:quantum/matrix.c **** extern const matrix_row_t matrix_mask[];
  46:quantum/matrix.c **** #endif
  47:quantum/matrix.c **** 
  48:quantum/matrix.c **** #ifdef DIRECT_PINS
  49:quantum/matrix.c **** static pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  50:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  51:quantum/matrix.c **** static const pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  52:quantum/matrix.c **** static const pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  53:quantum/matrix.c **** #endif
  54:quantum/matrix.c **** 
  55:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  56:quantum/matrix.c **** static matrix_row_t raw_matrix[MATRIX_ROWS];  // raw values
  57:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];      // debounced values
  58:quantum/matrix.c **** 
  59:quantum/matrix.c **** __attribute__((weak)) void matrix_init_quantum(void) { matrix_init_kb(); }
  60:quantum/matrix.c **** 
  61:quantum/matrix.c **** __attribute__((weak)) void matrix_scan_quantum(void) { matrix_scan_kb(); }
  62:quantum/matrix.c **** 
  63:quantum/matrix.c **** __attribute__((weak)) void matrix_init_kb(void) { matrix_init_user(); }
  64:quantum/matrix.c **** 
  65:quantum/matrix.c **** __attribute__((weak)) void matrix_scan_kb(void) { matrix_scan_user(); }
  66:quantum/matrix.c **** 
  67:quantum/matrix.c **** __attribute__((weak)) void matrix_init_user(void) {}
  16               		.loc 1 67 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE23:
  26               		.section	.text.matrix_init_kb,"ax",@progbits
  27               		.weak	matrix_init_kb
  29               	matrix_init_kb:
  30               	.LFB21:
  63:quantum/matrix.c **** 
  31               		.loc 1 63 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  63:quantum/matrix.c **** 
  37               		.loc 1 63 0
  38 0000 0C94 0000 		jmp matrix_init_user
  39               	.LVL0:
  40               		.cfi_endproc
  41               	.LFE21:
  43               		.section	.text.matrix_init_quantum,"ax",@progbits
  44               		.weak	matrix_init_quantum
  46               	matrix_init_quantum:
  47               	.LFB19:
  59:quantum/matrix.c **** 
  48               		.loc 1 59 0
  49               		.cfi_startproc
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
  59:quantum/matrix.c **** 
  54               		.loc 1 59 0
  55 0000 0C94 0000 		jmp matrix_init_kb
  56               	.LVL1:
  57               		.cfi_endproc
  58               	.LFE19:
  60               		.section	.text.matrix_scan_user,"ax",@progbits
  61               		.weak	matrix_scan_user
  63               	matrix_scan_user:
  64               	.LFB24:
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** __attribute__((weak)) void matrix_scan_user(void) {}
  65               		.loc 1 69 0
  66               		.cfi_startproc
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  71 0000 0895      		ret
  72               		.cfi_endproc
  73               	.LFE24:
  75               		.section	.text.matrix_scan_kb,"ax",@progbits
  76               		.weak	matrix_scan_kb
  78               	matrix_scan_kb:
  79               	.LFB22:
  65:quantum/matrix.c **** 
  80               		.loc 1 65 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
  65:quantum/matrix.c **** 
  86               		.loc 1 65 0
  87 0000 0C94 0000 		jmp matrix_scan_user
  88               	.LVL2:
  89               		.cfi_endproc
  90               	.LFE22:
  92               		.section	.text.matrix_scan_quantum,"ax",@progbits
  93               		.weak	matrix_scan_quantum
  95               	matrix_scan_quantum:
  96               	.LFB20:
  61:quantum/matrix.c **** 
  97               		.loc 1 61 0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  61:quantum/matrix.c **** 
 103               		.loc 1 61 0
 104 0000 0C94 0000 		jmp matrix_scan_kb
 105               	.LVL3:
 106               		.cfi_endproc
 107               	.LFE20:
 109               		.section	.text.matrix_rows,"ax",@progbits
 110               	.global	matrix_rows
 112               	matrix_rows:
 113               	.LFB25:
  70:quantum/matrix.c **** 
  71:quantum/matrix.c **** inline uint8_t matrix_rows(void) { return MATRIX_ROWS; }
 114               		.loc 1 71 0
 115               		.cfi_startproc
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
 120               		.loc 1 71 0
 121 0000 85E0      		ldi r24,lo8(5)
 122 0002 0895      		ret
 123               		.cfi_endproc
 124               	.LFE25:
 126               		.section	.text.matrix_cols,"ax",@progbits
 127               	.global	matrix_cols
 129               	matrix_cols:
 130               	.LFB26:
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** inline uint8_t matrix_cols(void) { return MATRIX_COLS; }
 131               		.loc 1 73 0
 132               		.cfi_startproc
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 137               		.loc 1 73 0
 138 0000 8FE0      		ldi r24,lo8(15)
 139 0002 0895      		ret
 140               		.cfi_endproc
 141               	.LFE26:
 143               		.section	.text.matrix_is_modified,"ax",@progbits
 144               	.global	matrix_is_modified
 146               	matrix_is_modified:
 147               	.LFB27:
  74:quantum/matrix.c **** 
  75:quantum/matrix.c **** // Deprecated.
  76:quantum/matrix.c **** bool matrix_is_modified(void) {
 148               		.loc 1 76 0
 149               		.cfi_startproc
 150               	/* prologue: function */
 151               	/* frame size = 0 */
 152               	/* stack size = 0 */
 153               	.L__stack_usage = 0
  77:quantum/matrix.c ****     if (debounce_active()) return false;
 154               		.loc 1 77 0
 155 0000 0E94 0000 		call debounce_active
 156               	.LVL4:
  78:quantum/matrix.c ****     return true;
  79:quantum/matrix.c **** }
 157               		.loc 1 79 0
 158 0004 91E0      		ldi r25,lo8(1)
 159 0006 8927      		eor r24,r25
 160 0008 0895      		ret
 161               		.cfi_endproc
 162               	.LFE27:
 164               		.section	.text.matrix_is_on,"ax",@progbits
 165               	.global	matrix_is_on
 167               	matrix_is_on:
 168               	.LFB28:
  80:quantum/matrix.c **** 
  81:quantum/matrix.c **** inline bool matrix_is_on(uint8_t row, uint8_t col) { return (matrix[row] & ((matrix_row_t)1 << col)
 169               		.loc 1 81 0
 170               		.cfi_startproc
 171               	.LVL5:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
 176               		.loc 1 81 0
 177 0000 E82F      		mov r30,r24
 178 0002 F0E0      		ldi r31,0
 179 0004 EE0F      		lsl r30
 180 0006 FF1F      		rol r31
 181               	.LVL6:
 182 0008 E050      		subi r30,lo8(-(matrix))
 183 000a F040      		sbci r31,hi8(-(matrix))
 184 000c 21E0      		ldi r18,lo8(1)
 185 000e 30E0      		ldi r19,0
 186 0010 00C0      		rjmp 2f
 187               		1:
 188 0012 220F      		lsl r18
 189 0014 331F      		rol r19
 190               		2:
 191 0016 6A95      		dec r22
 192 0018 02F4      		brpl 1b
 193 001a 8081      		ld r24,Z
 194 001c 9181      		ldd r25,Z+1
 195 001e 2823      		and r18,r24
 196 0020 3923      		and r19,r25
 197 0022 81E0      		ldi r24,lo8(1)
 198 0024 232B      		or r18,r19
 199 0026 01F4      		brne .L11
 200 0028 80E0      		ldi r24,0
 201               	.L11:
 202 002a 0895      		ret
 203               		.cfi_endproc
 204               	.LFE28:
 206               		.section	.text.matrix_get_row,"ax",@progbits
 207               	.global	matrix_get_row
 209               	matrix_get_row:
 210               	.LFB29:
  82:quantum/matrix.c **** 
  83:quantum/matrix.c **** inline matrix_row_t matrix_get_row(uint8_t row) {
 211               		.loc 1 83 0
 212               		.cfi_startproc
 213               	.LVL7:
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 216               	/* stack size = 0 */
 217               	.L__stack_usage = 0
  84:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
  85:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
  86:quantum/matrix.c **** #ifdef MATRIX_MASKED
  87:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
  88:quantum/matrix.c **** #else
  89:quantum/matrix.c ****     return matrix[row];
 218               		.loc 1 89 0
 219 0000 E82F      		mov r30,r24
 220 0002 F0E0      		ldi r31,0
 221 0004 EE0F      		lsl r30
 222 0006 FF1F      		rol r31
 223               	.LVL8:
 224 0008 E050      		subi r30,lo8(-(matrix))
 225 000a F040      		sbci r31,hi8(-(matrix))
  90:quantum/matrix.c **** #endif
  91:quantum/matrix.c **** }
 226               		.loc 1 91 0
 227 000c 8081      		ld r24,Z
 228 000e 9181      		ldd r25,Z+1
 229 0010 0895      		ret
 230               		.cfi_endproc
 231               	.LFE29:
 233               		.section	.text.matrix_print,"ax",@progbits
 234               	.global	matrix_print
 236               	matrix_print:
 237               	.LFB30:
  92:quantum/matrix.c **** 
  93:quantum/matrix.c **** void matrix_print(void) {
 238               		.loc 1 93 0
 239               		.cfi_startproc
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
 244               	.LVL9:
 245 0000 0895      		ret
 246               		.cfi_endproc
 247               	.LFE30:
 249               		.section	.text.matrix_key_count,"ax",@progbits
 250               	.global	matrix_key_count
 252               	matrix_key_count:
 253               	.LFB31:
  94:quantum/matrix.c ****     print_matrix_header();
  95:quantum/matrix.c **** 
  96:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
  97:quantum/matrix.c ****         phex(row);
  98:quantum/matrix.c ****         print(": ");
  99:quantum/matrix.c ****         print_matrix_row(row);
 100:quantum/matrix.c ****         print("\n");
 101:quantum/matrix.c ****     }
 102:quantum/matrix.c **** }
 103:quantum/matrix.c **** 
 104:quantum/matrix.c **** uint8_t matrix_key_count(void) {
 254               		.loc 1 104 0
 255               		.cfi_startproc
 256               		.loc 1 104 0
 257 0000 0F93      		push r16
 258               	.LCFI0:
 259               		.cfi_def_cfa_offset 3
 260               		.cfi_offset 16, -2
 261 0002 1F93      		push r17
 262               	.LCFI1:
 263               		.cfi_def_cfa_offset 4
 264               		.cfi_offset 17, -3
 265 0004 CF93      		push r28
 266               	.LCFI2:
 267               		.cfi_def_cfa_offset 5
 268               		.cfi_offset 28, -4
 269               	/* prologue: function */
 270               	/* frame size = 0 */
 271               	/* stack size = 3 */
 272               	.L__stack_usage = 3
 273               	.LVL10:
 274 0006 00E0      		ldi r16,lo8(matrix)
 275 0008 10E0      		ldi r17,hi8(matrix)
 105:quantum/matrix.c ****     uint8_t count = 0;
 276               		.loc 1 105 0
 277 000a C0E0      		ldi r28,0
 278               	.LVL11:
 279               	.L16:
 280               	.LBB10:
 106:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 107:quantum/matrix.c ****         count += matrix_bitpop(i);
 281               		.loc 1 107 0 discriminator 3
 282 000c F801      		movw r30,r16
 283 000e 8191      		ld r24,Z+
 284 0010 9191      		ld r25,Z+
 285 0012 8F01      		movw r16,r30
 286 0014 0E94 0000 		call bitpop16
 287               	.LVL12:
 288 0018 C80F      		add r28,r24
 289               	.LVL13:
 106:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 290               		.loc 1 106 0 discriminator 3
 291 001a F0E0      		ldi r31,hi8(matrix+10)
 292 001c 0030      		cpi r16,lo8(matrix+10)
 293 001e 1F07      		cpc r17,r31
 294 0020 01F4      		brne .L16
 295               	.LBE10:
 108:quantum/matrix.c ****     }
 109:quantum/matrix.c ****     return count;
 110:quantum/matrix.c **** }
 296               		.loc 1 110 0
 297 0022 8C2F      		mov r24,r28
 298               	/* epilogue start */
 299 0024 CF91      		pop r28
 300               	.LVL14:
 301 0026 1F91      		pop r17
 302 0028 0F91      		pop r16
 303 002a 0895      		ret
 304               		.cfi_endproc
 305               	.LFE31:
 307               		.section	.text.matrix_init,"ax",@progbits
 308               	.global	matrix_init
 310               	matrix_init:
 311               	.LFB37:
 111:quantum/matrix.c **** 
 112:quantum/matrix.c **** #ifdef DIRECT_PINS
 113:quantum/matrix.c **** 
 114:quantum/matrix.c **** static void init_pins(void) {
 115:quantum/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
 116:quantum/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
 117:quantum/matrix.c ****             pin_t pin = direct_pins[row][col];
 118:quantum/matrix.c ****             if (pin != NO_PIN) {
 119:quantum/matrix.c ****                 setPinInputHigh(pin);
 120:quantum/matrix.c ****             }
 121:quantum/matrix.c ****         }
 122:quantum/matrix.c ****     }
 123:quantum/matrix.c **** }
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 126:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 127:quantum/matrix.c ****     current_matrix[current_row] = 0;
 128:quantum/matrix.c **** 
 129:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 130:quantum/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
 131:quantum/matrix.c ****         if (pin != NO_PIN) {
 132:quantum/matrix.c ****             current_matrix[current_row] |= readPin(pin) ? 0 : (ROW_SHIFTER << col_index);
 133:quantum/matrix.c ****         }
 134:quantum/matrix.c ****     }
 135:quantum/matrix.c **** 
 136:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 137:quantum/matrix.c **** }
 138:quantum/matrix.c **** 
 139:quantum/matrix.c **** #elif (DIODE_DIRECTION == COL2ROW)
 140:quantum/matrix.c **** 
 141:quantum/matrix.c **** static void select_row(uint8_t row) {
 142:quantum/matrix.c ****     setPinOutput(row_pins[row]);
 143:quantum/matrix.c ****     writePinLow(row_pins[row]);
 144:quantum/matrix.c **** }
 145:quantum/matrix.c **** 
 146:quantum/matrix.c **** static void unselect_row(uint8_t row) { setPinInputHigh(row_pins[row]); }
 147:quantum/matrix.c **** 
 148:quantum/matrix.c **** static void unselect_rows(void) {
 149:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 150:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 151:quantum/matrix.c ****     }
 152:quantum/matrix.c **** }
 153:quantum/matrix.c **** 
 154:quantum/matrix.c **** static void init_pins(void) {
 155:quantum/matrix.c ****     unselect_rows();
 156:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 157:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 158:quantum/matrix.c ****     }
 159:quantum/matrix.c **** }
 160:quantum/matrix.c **** 
 161:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 162:quantum/matrix.c ****     // Store last value of row prior to reading
 163:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 164:quantum/matrix.c **** 
 165:quantum/matrix.c ****     // Clear data in matrix row
 166:quantum/matrix.c ****     current_matrix[current_row] = 0;
 167:quantum/matrix.c **** 
 168:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 169:quantum/matrix.c ****     select_row(current_row);
 170:quantum/matrix.c ****     wait_us(30);
 171:quantum/matrix.c **** 
 172:quantum/matrix.c ****     // For each col...
 173:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 174:quantum/matrix.c ****         // Select the col pin to read (active low)
 175:quantum/matrix.c ****         uint8_t pin_state = readPin(col_pins[col_index]);
 176:quantum/matrix.c **** 
 177:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 178:quantum/matrix.c ****         current_matrix[current_row] |= pin_state ? 0 : (ROW_SHIFTER << col_index);
 179:quantum/matrix.c ****     }
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     // Unselect row
 182:quantum/matrix.c ****     unselect_row(current_row);
 183:quantum/matrix.c **** 
 184:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 185:quantum/matrix.c **** }
 186:quantum/matrix.c **** 
 187:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 188:quantum/matrix.c **** 
 189:quantum/matrix.c **** static void select_col(uint8_t col) {
 190:quantum/matrix.c ****     setPinOutput(col_pins[col]);
 191:quantum/matrix.c ****     writePinLow(col_pins[col]);
 192:quantum/matrix.c **** }
 193:quantum/matrix.c **** 
 194:quantum/matrix.c **** static void unselect_col(uint8_t col) { setPinInputHigh(col_pins[col]); }
 195:quantum/matrix.c **** 
 196:quantum/matrix.c **** static void unselect_cols(void) {
 197:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 198:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 199:quantum/matrix.c ****     }
 200:quantum/matrix.c **** }
 201:quantum/matrix.c **** 
 202:quantum/matrix.c **** static void init_pins(void) {
 203:quantum/matrix.c ****     unselect_cols();
 204:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 205:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 206:quantum/matrix.c ****     }
 207:quantum/matrix.c **** }
 208:quantum/matrix.c **** 
 209:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col) {
 210:quantum/matrix.c ****     bool matrix_changed = false;
 211:quantum/matrix.c **** 
 212:quantum/matrix.c ****     // Select col and wait for col selecton to stabilize
 213:quantum/matrix.c ****     select_col(current_col);
 214:quantum/matrix.c ****     wait_us(30);
 215:quantum/matrix.c **** 
 216:quantum/matrix.c ****     // For each row...
 217:quantum/matrix.c ****     for (uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++) {
 218:quantum/matrix.c ****         // Store last value of row prior to reading
 219:quantum/matrix.c ****         matrix_row_t last_row_value = current_matrix[row_index];
 220:quantum/matrix.c **** 
 221:quantum/matrix.c ****         // Check row pin state
 222:quantum/matrix.c ****         if (readPin(row_pins[row_index]) == 0) {
 223:quantum/matrix.c ****             // Pin LO, set col bit
 224:quantum/matrix.c ****             current_matrix[row_index] |= (ROW_SHIFTER << current_col);
 225:quantum/matrix.c ****         } else {
 226:quantum/matrix.c ****             // Pin HI, clear col bit
 227:quantum/matrix.c ****             current_matrix[row_index] &= ~(ROW_SHIFTER << current_col);
 228:quantum/matrix.c ****         }
 229:quantum/matrix.c **** 
 230:quantum/matrix.c ****         // Determine if the matrix changed state
 231:quantum/matrix.c ****         if ((last_row_value != current_matrix[row_index]) && !(matrix_changed)) {
 232:quantum/matrix.c ****             matrix_changed = true;
 233:quantum/matrix.c ****         }
 234:quantum/matrix.c ****     }
 235:quantum/matrix.c **** 
 236:quantum/matrix.c ****     // Unselect col
 237:quantum/matrix.c ****     unselect_col(current_col);
 238:quantum/matrix.c **** 
 239:quantum/matrix.c ****     return matrix_changed;
 240:quantum/matrix.c **** }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c **** #endif
 243:quantum/matrix.c **** 
 244:quantum/matrix.c **** void matrix_init(void) {
 312               		.loc 1 244 0
 313               		.cfi_startproc
 314               	/* prologue: function */
 315               	/* frame size = 0 */
 316               	/* stack size = 0 */
 317               	.L__stack_usage = 0
 318               	.LVL15:
 319               		.loc 1 244 0
 320 0000 A0E0      		ldi r26,lo8(row_pins)
 321 0002 B0E0      		ldi r27,hi8(row_pins)
 322               	.LBB18:
 323               	.LBB19:
 324               	.LBB20:
 150:quantum/matrix.c ****     }
 325               		.loc 1 150 0
 326 0004 41E0      		ldi r20,lo8(1)
 327 0006 50E0      		ldi r21,0
 328 0008 25E0      		ldi r18,lo8(5)
 329 000a 2A0F      		add r18,r26
 330               	.LVL16:
 331               	.L19:
 332 000c 8D91      		ld r24,X+
 333               	.LVL17:
 334 000e E82F      		mov r30,r24
 335 0010 E295      		swap r30
 336 0012 EF70      		andi r30,lo8(15)
 337 0014 F0E0      		ldi r31,0
 338 0016 31A1      		ldd r19,Z+33
 339 0018 8F70      		andi r24,lo8(15)
 340 001a BA01      		movw r22,r20
 341 001c 00C0      		rjmp 2f
 342               		1:
 343 001e 660F      		lsl r22
 344 0020 771F      		rol r23
 345               		2:
 346 0022 8A95      		dec r24
 347 0024 02F4      		brpl 1b
 348 0026 CB01      		movw r24,r22
 349 0028 962F      		mov r25,r22
 350 002a 9095      		com r25
 351 002c 9323      		and r25,r19
 352 002e 91A3      		std Z+33,r25
 353 0030 92A1      		ldd r25,Z+34
 354 0032 892B      		or r24,r25
 355 0034 82A3      		std Z+34,r24
 356               	.LVL18:
 149:quantum/matrix.c ****         setPinInputHigh(row_pins[x]);
 357               		.loc 1 149 0
 358 0036 2A13      		cpse r18,r26
 359 0038 00C0      		rjmp .L19
 360 003a A0E0      		ldi r26,lo8(col_pins)
 361 003c B0E0      		ldi r27,hi8(col_pins)
 362               	.LVL19:
 363               	.LBE20:
 364               	.LBE19:
 365               	.LBB21:
 157:quantum/matrix.c ****     }
 366               		.loc 1 157 0
 367 003e 41E0      		ldi r20,lo8(1)
 368 0040 50E0      		ldi r21,0
 369 0042 2FE0      		ldi r18,lo8(15)
 370 0044 2A0F      		add r18,r26
 371               	.L20:
 372               	.LVL20:
 373 0046 8D91      		ld r24,X+
 374               	.LVL21:
 375 0048 E82F      		mov r30,r24
 376 004a E295      		swap r30
 377 004c EF70      		andi r30,lo8(15)
 378 004e F0E0      		ldi r31,0
 379 0050 31A1      		ldd r19,Z+33
 380 0052 8F70      		andi r24,lo8(15)
 381 0054 BA01      		movw r22,r20
 382 0056 00C0      		rjmp 2f
 383               		1:
 384 0058 660F      		lsl r22
 385 005a 771F      		rol r23
 386               		2:
 387 005c 8A95      		dec r24
 388 005e 02F4      		brpl 1b
 389 0060 CB01      		movw r24,r22
 390 0062 962F      		mov r25,r22
 391 0064 9095      		com r25
 392 0066 9323      		and r25,r19
 393 0068 91A3      		std Z+33,r25
 394 006a 92A1      		ldd r25,Z+34
 395 006c 892B      		or r24,r25
 396 006e 82A3      		std Z+34,r24
 397               	.LVL22:
 156:quantum/matrix.c ****         setPinInputHigh(col_pins[x]);
 398               		.loc 1 156 0
 399 0070 2A13      		cpse r18,r26
 400 0072 00C0      		rjmp .L20
 401 0074 E0E0      		ldi r30,lo8(raw_matrix)
 402 0076 F0E0      		ldi r31,hi8(raw_matrix)
 403 0078 A0E0      		ldi r26,lo8(matrix)
 404 007a B0E0      		ldi r27,hi8(matrix)
 405               	.LVL23:
 406               	.L21:
 407               	.LBE21:
 408               	.LBE18:
 409               	.LBB22:
 245:quantum/matrix.c ****     // initialize key pins
 246:quantum/matrix.c ****     init_pins();
 247:quantum/matrix.c **** 
 248:quantum/matrix.c ****     // initialize matrix state: all keys off
 249:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 250:quantum/matrix.c ****         raw_matrix[i] = 0;
 410               		.loc 1 250 0 discriminator 3
 411 007c 1192      		st Z+,__zero_reg__
 412 007e 1192      		st Z+,__zero_reg__
 251:quantum/matrix.c ****         matrix[i]     = 0;
 413               		.loc 1 251 0 discriminator 3
 414 0080 1D92      		st X+,__zero_reg__
 415 0082 1D92      		st X+,__zero_reg__
 416               	.LVL24:
 249:quantum/matrix.c ****         raw_matrix[i] = 0;
 417               		.loc 1 249 0 discriminator 3
 418 0084 70E0      		ldi r23,hi8(raw_matrix+10)
 419 0086 E030      		cpi r30,lo8(raw_matrix+10)
 420 0088 F707      		cpc r31,r23
 421 008a 01F4      		brne .L21
 422               	.LBE22:
 252:quantum/matrix.c ****     }
 253:quantum/matrix.c **** 
 254:quantum/matrix.c ****     debounce_init(MATRIX_ROWS);
 423               		.loc 1 254 0
 424 008c 85E0      		ldi r24,lo8(5)
 425 008e 0E94 0000 		call debounce_init
 426               	.LVL25:
 255:quantum/matrix.c **** 
 256:quantum/matrix.c ****     matrix_init_quantum();
 427               		.loc 1 256 0
 428 0092 0C94 0000 		jmp matrix_init_quantum
 429               	.LVL26:
 430               		.cfi_endproc
 431               	.LFE37:
 433               		.section	.text.matrix_scan,"ax",@progbits
 434               	.global	matrix_scan
 436               	matrix_scan:
 437               	.LFB38:
 257:quantum/matrix.c **** }
 258:quantum/matrix.c **** 
 259:quantum/matrix.c **** uint8_t matrix_scan(void) {
 438               		.loc 1 259 0
 439               		.cfi_startproc
 440 0000 5F92      		push r5
 441               	.LCFI3:
 442               		.cfi_def_cfa_offset 3
 443               		.cfi_offset 5, -2
 444 0002 6F92      		push r6
 445               	.LCFI4:
 446               		.cfi_def_cfa_offset 4
 447               		.cfi_offset 6, -3
 448 0004 7F92      		push r7
 449               	.LCFI5:
 450               		.cfi_def_cfa_offset 5
 451               		.cfi_offset 7, -4
 452 0006 8F92      		push r8
 453               	.LCFI6:
 454               		.cfi_def_cfa_offset 6
 455               		.cfi_offset 8, -5
 456 0008 9F92      		push r9
 457               	.LCFI7:
 458               		.cfi_def_cfa_offset 7
 459               		.cfi_offset 9, -6
 460 000a AF92      		push r10
 461               	.LCFI8:
 462               		.cfi_def_cfa_offset 8
 463               		.cfi_offset 10, -7
 464 000c BF92      		push r11
 465               	.LCFI9:
 466               		.cfi_def_cfa_offset 9
 467               		.cfi_offset 11, -8
 468 000e CF92      		push r12
 469               	.LCFI10:
 470               		.cfi_def_cfa_offset 10
 471               		.cfi_offset 12, -9
 472 0010 DF92      		push r13
 473               	.LCFI11:
 474               		.cfi_def_cfa_offset 11
 475               		.cfi_offset 13, -10
 476 0012 EF92      		push r14
 477               	.LCFI12:
 478               		.cfi_def_cfa_offset 12
 479               		.cfi_offset 14, -11
 480 0014 FF92      		push r15
 481               	.LCFI13:
 482               		.cfi_def_cfa_offset 13
 483               		.cfi_offset 15, -12
 484 0016 0F93      		push r16
 485               	.LCFI14:
 486               		.cfi_def_cfa_offset 14
 487               		.cfi_offset 16, -13
 488 0018 1F93      		push r17
 489               	.LCFI15:
 490               		.cfi_def_cfa_offset 15
 491               		.cfi_offset 17, -14
 492 001a CF93      		push r28
 493               	.LCFI16:
 494               		.cfi_def_cfa_offset 16
 495               		.cfi_offset 28, -15
 496 001c DF93      		push r29
 497               	.LCFI17:
 498               		.cfi_def_cfa_offset 17
 499               		.cfi_offset 29, -16
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 15 */
 503               	.L__stack_usage = 15
 504               	.LVL27:
 505 001e 00E0      		ldi r16,lo8(row_pins)
 506 0020 10E0      		ldi r17,hi8(row_pins)
 507 0022 A0E0      		ldi r26,lo8(raw_matrix)
 508 0024 B0E0      		ldi r27,hi8(raw_matrix)
 260:quantum/matrix.c ****     bool changed = false;
 509               		.loc 1 260 0
 510 0026 612C      		mov r6,__zero_reg__
 511               	.LBB34:
 512               	.LBB35:
 513               	.LBB36:
 514               	.LBB37:
 515               	.LBB38:
 142:quantum/matrix.c ****     writePinLow(row_pins[row]);
 516               		.loc 1 142 0
 517 0028 EE24      		clr r14
 518 002a E394      		inc r14
 519 002c F12C      		mov r15,__zero_reg__
 520               	.LVL28:
 521               	.L29:
 522 002e 5D01      		movw r10,r26
 523               	.LBE38:
 524               	.LBE37:
 163:quantum/matrix.c **** 
 525               		.loc 1 163 0
 526 0030 8D90      		ld r8,X+
 527 0032 9C90      		ld r9,X
 528 0034 1197      		sbiw r26,1
 529               	.LVL29:
 166:quantum/matrix.c **** 
 530               		.loc 1 166 0
 531 0036 1196      		adiw r26,1
 532 0038 1C92      		st X,__zero_reg__
 533 003a 1E92      		st -X,__zero_reg__
 534               	.LVL30:
 535               	.LBB40:
 536               	.LBB39:
 142:quantum/matrix.c ****     writePinLow(row_pins[row]);
 537               		.loc 1 142 0
 538 003c E801      		movw r28,r16
 539 003e 8991      		ld r24,Y+
 540 0040 8E01      		movw r16,r28
 541               	.LVL31:
 542 0042 E82F      		mov r30,r24
 543 0044 E295      		swap r30
 544 0046 EF70      		andi r30,lo8(15)
 545 0048 F0E0      		ldi r31,0
 546 004a 91A1      		ldd r25,Z+33
 547 004c 8F70      		andi r24,lo8(15)
 548 004e A701      		movw r20,r14
 549 0050 00C0      		rjmp 2f
 550               		1:
 551 0052 440F      		lsl r20
 552               		2:
 553 0054 8A95      		dec r24
 554 0056 02F4      		brpl 1b
 555 0058 892F      		mov r24,r25
 556 005a 842B      		or r24,r20
 557 005c 81A3      		std Z+33,r24
 143:quantum/matrix.c **** }
 558               		.loc 1 143 0
 559 005e 82A1      		ldd r24,Z+34
 560 0060 542E      		mov r5,r20
 561 0062 5094      		com r5
 562 0064 8521      		and r24,r5
 563 0066 82A3      		std Z+34,r24
 564               	.LVL32:
 565               	.LBE39:
 566               	.LBE40:
 567               	.LBB41:
 568               	.LBB42:
 569               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 570               		.loc 2 245 0
 571 0068 D0EA      		ldi r29,lo8(-96)
 572 006a DA95      	1:	dec r29
 573 006c 01F4      		brne 1b
 574               	.LVL33:
 575 006e 80E0      		ldi r24,lo8(col_pins)
 576 0070 C82E      		mov r12,r24
 577 0072 80E0      		ldi r24,hi8(col_pins)
 578 0074 D82E      		mov r13,r24
 579 0076 80E0      		ldi r24,0
 580 0078 90E0      		ldi r25,0
 581               	.LVL34:
 582               	.L27:
 583               	.LBE42:
 584               	.LBE41:
 585               	.LBB43:
 586               	.LBB44:
 175:quantum/matrix.c **** 
 587               		.loc 1 175 0
 588 007a E601      		movw r28,r12
 589 007c 7990      		ld r7,Y+
 590 007e 6E01      		movw r12,r28
 591 0080 272D      		mov r18,r7
 592 0082 2295      		swap r18
 593 0084 2F70      		andi r18,lo8(15)
 594 0086 30E0      		ldi r19,0
 595 0088 E901      		movw r28,r18
 596 008a 68A1      		ldd r22,Y+32
 597               	.LVL35:
 178:quantum/matrix.c ****     }
 598               		.loc 1 178 0
 599 008c 2D91      		ld r18,X+
 600 008e 3C91      		ld r19,X
 601 0090 1197      		sbiw r26,1
 175:quantum/matrix.c **** 
 602               		.loc 1 175 0
 603 0092 70E0      		ldi r23,0
 604 0094 D72D      		mov r29,r7
 605 0096 DF70      		andi r29,lo8(15)
 606               	.LVL36:
 607 0098 00C0      		rjmp 2f
 608               		1:
 609 009a 7595      		asr r23
 610 009c 6795      		ror r22
 611               		2:
 612 009e DA95      		dec r29
 613 00a0 02F4      		brpl 1b
 614               	.LVL37:
 178:quantum/matrix.c ****     }
 615               		.loc 1 178 0
 616 00a2 60FD      		sbrc r22,0
 617 00a4 00C0      		rjmp .L30
 618 00a6 B701      		movw r22,r14
 619 00a8 082E      		mov r0,r24
 620 00aa 00C0      		rjmp 2f
 621               		1:
 622 00ac 660F      		lsl r22
 623 00ae 771F      		rol r23
 624               		2:
 625 00b0 0A94      		dec r0
 626 00b2 02F4      		brpl 1b
 627 00b4 00C0      		rjmp .L26
 628               	.L30:
 629 00b6 60E0      		ldi r22,0
 630 00b8 70E0      		ldi r23,0
 631               	.L26:
 632 00ba 262B      		or r18,r22
 633 00bc 372B      		or r19,r23
 634 00be 1196      		adiw r26,1
 635 00c0 3C93      		st X,r19
 636 00c2 2E93      		st -X,r18
 637               	.LVL38:
 638 00c4 0196      		adiw r24,1
 639               	.LVL39:
 640               	.LBE44:
 173:quantum/matrix.c ****         // Select the col pin to read (active low)
 641               		.loc 1 173 0
 642 00c6 8F30      		cpi r24,15
 643 00c8 9105      		cpc r25,__zero_reg__
 644 00ca 01F4      		brne .L27
 645               	.LVL40:
 646               	.LBE43:
 647               	.LBB45:
 648               	.LBB46:
 146:quantum/matrix.c **** 
 649               		.loc 1 146 0
 650 00cc 81A1      		ldd r24,Z+33
 651               	.LVL41:
 652 00ce D52D      		mov r29,r5
 653 00d0 D823      		and r29,r24
 654 00d2 D1A3      		std Z+33,r29
 655 00d4 82A1      		ldd r24,Z+34
 656 00d6 482B      		or r20,r24
 657 00d8 42A3      		std Z+34,r20
 658 00da 1296      		adiw r26,2
 659               	.LBE46:
 660               	.LBE45:
 184:quantum/matrix.c **** }
 661               		.loc 1 184 0
 662 00dc 81E0      		ldi r24,lo8(1)
 663 00de F501      		movw r30,r10
 664 00e0 2081      		ld r18,Z
 665 00e2 3181      		ldd r19,Z+1
 666 00e4 8216      		cp r8,r18
 667 00e6 9306      		cpc r9,r19
 668 00e8 01F4      		brne .L28
 669 00ea 80E0      		ldi r24,0
 670               	.L28:
 671               	.LBE36:
 672               	.LBE35:
 261:quantum/matrix.c **** 
 262:quantum/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 263:quantum/matrix.c ****     // Set row, read cols
 264:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 265:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 673               		.loc 1 265 0
 674 00ec 682A      		or r6,r24
 675               	.LVL42:
 264:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 676               		.loc 1 264 0
 677 00ee F0E0      		ldi r31,hi8(raw_matrix+10)
 678 00f0 A030      		cpi r26,lo8(raw_matrix+10)
 679 00f2 BF07      		cpc r27,r31
 680 00f4 01F0      		breq .+2
 681 00f6 00C0      		rjmp .L29
 682               	.LBE34:
 266:quantum/matrix.c ****     }
 267:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 268:quantum/matrix.c ****     // Set col, read rows
 269:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 270:quantum/matrix.c ****         changed |= read_rows_on_col(raw_matrix, current_col);
 271:quantum/matrix.c ****     }
 272:quantum/matrix.c **** #endif
 273:quantum/matrix.c **** 
 274:quantum/matrix.c ****     debounce(raw_matrix, matrix, MATRIX_ROWS, changed);
 683               		.loc 1 274 0
 684 00f8 262D      		mov r18,r6
 685 00fa 45E0      		ldi r20,lo8(5)
 686 00fc 60E0      		ldi r22,lo8(matrix)
 687 00fe 70E0      		ldi r23,hi8(matrix)
 688 0100 80E0      		ldi r24,lo8(raw_matrix)
 689 0102 90E0      		ldi r25,hi8(raw_matrix)
 690 0104 0E94 0000 		call debounce
 691               	.LVL43:
 275:quantum/matrix.c **** 
 276:quantum/matrix.c ****     matrix_scan_quantum();
 692               		.loc 1 276 0
 693 0108 0E94 0000 		call matrix_scan_quantum
 694               	.LVL44:
 277:quantum/matrix.c ****     return (uint8_t)changed;
 278:quantum/matrix.c **** }
 695               		.loc 1 278 0
 696 010c 862D      		mov r24,r6
 697               	/* epilogue start */
 698 010e DF91      		pop r29
 699 0110 CF91      		pop r28
 700 0112 1F91      		pop r17
 701 0114 0F91      		pop r16
 702               	.LVL45:
 703 0116 FF90      		pop r15
 704 0118 EF90      		pop r14
 705 011a DF90      		pop r13
 706 011c CF90      		pop r12
 707 011e BF90      		pop r11
 708 0120 AF90      		pop r10
 709 0122 9F90      		pop r9
 710 0124 8F90      		pop r8
 711               	.LVL46:
 712 0126 7F90      		pop r7
 713 0128 6F90      		pop r6
 714               	.LVL47:
 715 012a 5F90      		pop r5
 716 012c 0895      		ret
 717               		.cfi_endproc
 718               	.LFE38:
 720               		.section	.bss.matrix,"aw",@nobits
 723               	matrix:
 724 0000 0000 0000 		.zero	10
 724      0000 0000 
 724      0000 
 725               		.section	.bss.raw_matrix,"aw",@nobits
 728               	raw_matrix:
 729 0000 0000 0000 		.zero	10
 729      0000 0000 
 729      0000 
 730               		.section	.rodata.col_pins,"a",@progbits
 733               	col_pins:
 734 0000 30        		.byte	48
 735 0001 31        		.byte	49
 736 0002 32        		.byte	50
 737 0003 33        		.byte	51
 738 0004 94        		.byte	-108
 739 0005 96        		.byte	-106
 740 0006 97        		.byte	-105
 741 0007 34        		.byte	52
 742 0008 35        		.byte	53
 743 0009 36        		.byte	54
 744 000a 66        		.byte	102
 745 000b 67        		.byte	103
 746 000c F5        		.byte	-11
 747 000d F6        		.byte	-10
 748 000e F7        		.byte	-9
 749               		.section	.rodata.row_pins,"a",@progbits
 752               	row_pins:
 753 0000 90        		.byte	-112
 754 0001 91        		.byte	-111
 755 0002 92        		.byte	-110
 756 0003 93        		.byte	-109
 757 0004 95        		.byte	-107
 758               		.text
 759               	.Letext0:
 760               		.file 3 "/usr/lib/avr/include/stdint.h"
 761               		.file 4 "tmk_core/common/matrix.h"
 762               		.file 5 "tmk_core/common/report.h"
 763               		.file 6 "quantum/quantum.h"
 764               		.file 7 "tmk_core/common/action_util.h"
 765               		.file 8 "quantum/debounce.h"
 766               		.file 9 "tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccU8GOHs.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccU8GOHs.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccU8GOHs.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccU8GOHs.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccU8GOHs.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccU8GOHs.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccU8GOHs.s:29     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccU8GOHs.s:46     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccU8GOHs.s:63     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccU8GOHs.s:78     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccU8GOHs.s:95     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccU8GOHs.s:112    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccU8GOHs.s:129    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccU8GOHs.s:146    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccU8GOHs.s:167    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccU8GOHs.s:723    .bss.matrix:0000000000000000 matrix
     /tmp/ccU8GOHs.s:209    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccU8GOHs.s:236    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccU8GOHs.s:252    .text.matrix_key_count:0000000000000000 matrix_key_count
     /tmp/ccU8GOHs.s:310    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccU8GOHs.s:752    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccU8GOHs.s:733    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccU8GOHs.s:728    .bss.raw_matrix:0000000000000000 raw_matrix
     /tmp/ccU8GOHs.s:436    .text.matrix_scan:0000000000000000 matrix_scan

UNDEFINED SYMBOLS
debounce_active
bitpop16
debounce_init
debounce
__do_copy_data
__do_clear_bss
